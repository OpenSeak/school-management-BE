
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model assignments
 * 
 */
export type assignments = $Result.DefaultSelection<Prisma.$assignmentsPayload>
/**
 * Model attendance
 * This table contains check constraints and requires additional setup for migrations. Visit https://pris.ly/d/check-constraints for more info.
 */
export type attendance = $Result.DefaultSelection<Prisma.$attendancePayload>
/**
 * Model calendar
 * 
 */
export type calendar = $Result.DefaultSelection<Prisma.$calendarPayload>
/**
 * Model class_representatives
 * 
 */
export type class_representatives = $Result.DefaultSelection<Prisma.$class_representativesPayload>
/**
 * Model class_routine
 * 
 */
export type class_routine = $Result.DefaultSelection<Prisma.$class_routinePayload>
/**
 * Model class_teachers
 * 
 */
export type class_teachers = $Result.DefaultSelection<Prisma.$class_teachersPayload>
/**
 * Model exams
 * 
 */
export type exams = $Result.DefaultSelection<Prisma.$examsPayload>
/**
 * Model financecheckbook
 * 
 */
export type financecheckbook = $Result.DefaultSelection<Prisma.$financecheckbookPayload>
/**
 * Model finances
 * 
 */
export type finances = $Result.DefaultSelection<Prisma.$financesPayload>
/**
 * Model notes
 * 
 */
export type notes = $Result.DefaultSelection<Prisma.$notesPayload>
/**
 * Model notices
 * This table contains check constraints and requires additional setup for migrations. Visit https://pris.ly/d/check-constraints for more info.
 */
export type notices = $Result.DefaultSelection<Prisma.$noticesPayload>
/**
 * Model performance
 * 
 */
export type performance = $Result.DefaultSelection<Prisma.$performancePayload>
/**
 * Model student_performance
 * 
 */
export type student_performance = $Result.DefaultSelection<Prisma.$student_performancePayload>
/**
 * Model student_routine
 * 
 */
export type student_routine = $Result.DefaultSelection<Prisma.$student_routinePayload>
/**
 * Model students
 * 
 */
export type students = $Result.DefaultSelection<Prisma.$studentsPayload>
/**
 * Model teacher_routine
 * This table contains check constraints and requires additional setup for migrations. Visit https://pris.ly/d/check-constraints for more info.
 */
export type teacher_routine = $Result.DefaultSelection<Prisma.$teacher_routinePayload>
/**
 * Model teachers
 * 
 */
export type teachers = $Result.DefaultSelection<Prisma.$teachersPayload>
/**
 * Model upcoming_events
 * 
 */
export type upcoming_events = $Result.DefaultSelection<Prisma.$upcoming_eventsPayload>
/**
 * Model users
 * This table contains check constraints and requires additional setup for migrations. Visit https://pris.ly/d/check-constraints for more info.
 */
export type users = $Result.DefaultSelection<Prisma.$usersPayload>
/**
 * Model workroom_messages
 * 
 */
export type workroom_messages = $Result.DefaultSelection<Prisma.$workroom_messagesPayload>

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Assignments
 * const assignments = await prisma.assignments.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Assignments
   * const assignments = await prisma.assignments.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.assignments`: Exposes CRUD operations for the **assignments** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Assignments
    * const assignments = await prisma.assignments.findMany()
    * ```
    */
  get assignments(): Prisma.assignmentsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.attendance`: Exposes CRUD operations for the **attendance** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Attendances
    * const attendances = await prisma.attendance.findMany()
    * ```
    */
  get attendance(): Prisma.attendanceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.calendar`: Exposes CRUD operations for the **calendar** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Calendars
    * const calendars = await prisma.calendar.findMany()
    * ```
    */
  get calendar(): Prisma.calendarDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.class_representatives`: Exposes CRUD operations for the **class_representatives** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Class_representatives
    * const class_representatives = await prisma.class_representatives.findMany()
    * ```
    */
  get class_representatives(): Prisma.class_representativesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.class_routine`: Exposes CRUD operations for the **class_routine** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Class_routines
    * const class_routines = await prisma.class_routine.findMany()
    * ```
    */
  get class_routine(): Prisma.class_routineDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.class_teachers`: Exposes CRUD operations for the **class_teachers** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Class_teachers
    * const class_teachers = await prisma.class_teachers.findMany()
    * ```
    */
  get class_teachers(): Prisma.class_teachersDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.exams`: Exposes CRUD operations for the **exams** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Exams
    * const exams = await prisma.exams.findMany()
    * ```
    */
  get exams(): Prisma.examsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.financecheckbook`: Exposes CRUD operations for the **financecheckbook** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Financecheckbooks
    * const financecheckbooks = await prisma.financecheckbook.findMany()
    * ```
    */
  get financecheckbook(): Prisma.financecheckbookDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.finances`: Exposes CRUD operations for the **finances** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Finances
    * const finances = await prisma.finances.findMany()
    * ```
    */
  get finances(): Prisma.financesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notes`: Exposes CRUD operations for the **notes** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notes
    * const notes = await prisma.notes.findMany()
    * ```
    */
  get notes(): Prisma.notesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notices`: Exposes CRUD operations for the **notices** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notices
    * const notices = await prisma.notices.findMany()
    * ```
    */
  get notices(): Prisma.noticesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.performance`: Exposes CRUD operations for the **performance** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Performances
    * const performances = await prisma.performance.findMany()
    * ```
    */
  get performance(): Prisma.performanceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.student_performance`: Exposes CRUD operations for the **student_performance** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Student_performances
    * const student_performances = await prisma.student_performance.findMany()
    * ```
    */
  get student_performance(): Prisma.student_performanceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.student_routine`: Exposes CRUD operations for the **student_routine** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Student_routines
    * const student_routines = await prisma.student_routine.findMany()
    * ```
    */
  get student_routine(): Prisma.student_routineDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.students`: Exposes CRUD operations for the **students** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Students
    * const students = await prisma.students.findMany()
    * ```
    */
  get students(): Prisma.studentsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.teacher_routine`: Exposes CRUD operations for the **teacher_routine** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Teacher_routines
    * const teacher_routines = await prisma.teacher_routine.findMany()
    * ```
    */
  get teacher_routine(): Prisma.teacher_routineDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.teachers`: Exposes CRUD operations for the **teachers** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Teachers
    * const teachers = await prisma.teachers.findMany()
    * ```
    */
  get teachers(): Prisma.teachersDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.upcoming_events`: Exposes CRUD operations for the **upcoming_events** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Upcoming_events
    * const upcoming_events = await prisma.upcoming_events.findMany()
    * ```
    */
  get upcoming_events(): Prisma.upcoming_eventsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.users`: Exposes CRUD operations for the **users** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.users.findMany()
    * ```
    */
  get users(): Prisma.usersDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.workroom_messages`: Exposes CRUD operations for the **workroom_messages** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Workroom_messages
    * const workroom_messages = await prisma.workroom_messages.findMany()
    * ```
    */
  get workroom_messages(): Prisma.workroom_messagesDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.7.0
   * Query Engine version: 3cff47a7f5d65c3ea74883f1d736e41d68ce91ed
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    assignments: 'assignments',
    attendance: 'attendance',
    calendar: 'calendar',
    class_representatives: 'class_representatives',
    class_routine: 'class_routine',
    class_teachers: 'class_teachers',
    exams: 'exams',
    financecheckbook: 'financecheckbook',
    finances: 'finances',
    notes: 'notes',
    notices: 'notices',
    performance: 'performance',
    student_performance: 'student_performance',
    student_routine: 'student_routine',
    students: 'students',
    teacher_routine: 'teacher_routine',
    teachers: 'teachers',
    upcoming_events: 'upcoming_events',
    users: 'users',
    workroom_messages: 'workroom_messages'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "assignments" | "attendance" | "calendar" | "class_representatives" | "class_routine" | "class_teachers" | "exams" | "financecheckbook" | "finances" | "notes" | "notices" | "performance" | "student_performance" | "student_routine" | "students" | "teacher_routine" | "teachers" | "upcoming_events" | "users" | "workroom_messages"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      assignments: {
        payload: Prisma.$assignmentsPayload<ExtArgs>
        fields: Prisma.assignmentsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.assignmentsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$assignmentsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.assignmentsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$assignmentsPayload>
          }
          findFirst: {
            args: Prisma.assignmentsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$assignmentsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.assignmentsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$assignmentsPayload>
          }
          findMany: {
            args: Prisma.assignmentsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$assignmentsPayload>[]
          }
          create: {
            args: Prisma.assignmentsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$assignmentsPayload>
          }
          createMany: {
            args: Prisma.assignmentsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.assignmentsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$assignmentsPayload>[]
          }
          delete: {
            args: Prisma.assignmentsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$assignmentsPayload>
          }
          update: {
            args: Prisma.assignmentsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$assignmentsPayload>
          }
          deleteMany: {
            args: Prisma.assignmentsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.assignmentsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.assignmentsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$assignmentsPayload>[]
          }
          upsert: {
            args: Prisma.assignmentsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$assignmentsPayload>
          }
          aggregate: {
            args: Prisma.AssignmentsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAssignments>
          }
          groupBy: {
            args: Prisma.assignmentsGroupByArgs<ExtArgs>
            result: $Utils.Optional<AssignmentsGroupByOutputType>[]
          }
          count: {
            args: Prisma.assignmentsCountArgs<ExtArgs>
            result: $Utils.Optional<AssignmentsCountAggregateOutputType> | number
          }
        }
      }
      attendance: {
        payload: Prisma.$attendancePayload<ExtArgs>
        fields: Prisma.attendanceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.attendanceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$attendancePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.attendanceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$attendancePayload>
          }
          findFirst: {
            args: Prisma.attendanceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$attendancePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.attendanceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$attendancePayload>
          }
          findMany: {
            args: Prisma.attendanceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$attendancePayload>[]
          }
          create: {
            args: Prisma.attendanceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$attendancePayload>
          }
          createMany: {
            args: Prisma.attendanceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.attendanceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$attendancePayload>[]
          }
          delete: {
            args: Prisma.attendanceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$attendancePayload>
          }
          update: {
            args: Prisma.attendanceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$attendancePayload>
          }
          deleteMany: {
            args: Prisma.attendanceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.attendanceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.attendanceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$attendancePayload>[]
          }
          upsert: {
            args: Prisma.attendanceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$attendancePayload>
          }
          aggregate: {
            args: Prisma.AttendanceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAttendance>
          }
          groupBy: {
            args: Prisma.attendanceGroupByArgs<ExtArgs>
            result: $Utils.Optional<AttendanceGroupByOutputType>[]
          }
          count: {
            args: Prisma.attendanceCountArgs<ExtArgs>
            result: $Utils.Optional<AttendanceCountAggregateOutputType> | number
          }
        }
      }
      calendar: {
        payload: Prisma.$calendarPayload<ExtArgs>
        fields: Prisma.calendarFieldRefs
        operations: {
          findUnique: {
            args: Prisma.calendarFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$calendarPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.calendarFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$calendarPayload>
          }
          findFirst: {
            args: Prisma.calendarFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$calendarPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.calendarFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$calendarPayload>
          }
          findMany: {
            args: Prisma.calendarFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$calendarPayload>[]
          }
          create: {
            args: Prisma.calendarCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$calendarPayload>
          }
          createMany: {
            args: Prisma.calendarCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.calendarCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$calendarPayload>[]
          }
          delete: {
            args: Prisma.calendarDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$calendarPayload>
          }
          update: {
            args: Prisma.calendarUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$calendarPayload>
          }
          deleteMany: {
            args: Prisma.calendarDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.calendarUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.calendarUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$calendarPayload>[]
          }
          upsert: {
            args: Prisma.calendarUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$calendarPayload>
          }
          aggregate: {
            args: Prisma.CalendarAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCalendar>
          }
          groupBy: {
            args: Prisma.calendarGroupByArgs<ExtArgs>
            result: $Utils.Optional<CalendarGroupByOutputType>[]
          }
          count: {
            args: Prisma.calendarCountArgs<ExtArgs>
            result: $Utils.Optional<CalendarCountAggregateOutputType> | number
          }
        }
      }
      class_representatives: {
        payload: Prisma.$class_representativesPayload<ExtArgs>
        fields: Prisma.class_representativesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.class_representativesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$class_representativesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.class_representativesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$class_representativesPayload>
          }
          findFirst: {
            args: Prisma.class_representativesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$class_representativesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.class_representativesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$class_representativesPayload>
          }
          findMany: {
            args: Prisma.class_representativesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$class_representativesPayload>[]
          }
          create: {
            args: Prisma.class_representativesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$class_representativesPayload>
          }
          createMany: {
            args: Prisma.class_representativesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.class_representativesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$class_representativesPayload>[]
          }
          delete: {
            args: Prisma.class_representativesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$class_representativesPayload>
          }
          update: {
            args: Prisma.class_representativesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$class_representativesPayload>
          }
          deleteMany: {
            args: Prisma.class_representativesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.class_representativesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.class_representativesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$class_representativesPayload>[]
          }
          upsert: {
            args: Prisma.class_representativesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$class_representativesPayload>
          }
          aggregate: {
            args: Prisma.Class_representativesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClass_representatives>
          }
          groupBy: {
            args: Prisma.class_representativesGroupByArgs<ExtArgs>
            result: $Utils.Optional<Class_representativesGroupByOutputType>[]
          }
          count: {
            args: Prisma.class_representativesCountArgs<ExtArgs>
            result: $Utils.Optional<Class_representativesCountAggregateOutputType> | number
          }
        }
      }
      class_routine: {
        payload: Prisma.$class_routinePayload<ExtArgs>
        fields: Prisma.class_routineFieldRefs
        operations: {
          findUnique: {
            args: Prisma.class_routineFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$class_routinePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.class_routineFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$class_routinePayload>
          }
          findFirst: {
            args: Prisma.class_routineFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$class_routinePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.class_routineFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$class_routinePayload>
          }
          findMany: {
            args: Prisma.class_routineFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$class_routinePayload>[]
          }
          create: {
            args: Prisma.class_routineCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$class_routinePayload>
          }
          createMany: {
            args: Prisma.class_routineCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.class_routineCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$class_routinePayload>[]
          }
          delete: {
            args: Prisma.class_routineDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$class_routinePayload>
          }
          update: {
            args: Prisma.class_routineUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$class_routinePayload>
          }
          deleteMany: {
            args: Prisma.class_routineDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.class_routineUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.class_routineUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$class_routinePayload>[]
          }
          upsert: {
            args: Prisma.class_routineUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$class_routinePayload>
          }
          aggregate: {
            args: Prisma.Class_routineAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClass_routine>
          }
          groupBy: {
            args: Prisma.class_routineGroupByArgs<ExtArgs>
            result: $Utils.Optional<Class_routineGroupByOutputType>[]
          }
          count: {
            args: Prisma.class_routineCountArgs<ExtArgs>
            result: $Utils.Optional<Class_routineCountAggregateOutputType> | number
          }
        }
      }
      class_teachers: {
        payload: Prisma.$class_teachersPayload<ExtArgs>
        fields: Prisma.class_teachersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.class_teachersFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$class_teachersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.class_teachersFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$class_teachersPayload>
          }
          findFirst: {
            args: Prisma.class_teachersFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$class_teachersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.class_teachersFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$class_teachersPayload>
          }
          findMany: {
            args: Prisma.class_teachersFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$class_teachersPayload>[]
          }
          create: {
            args: Prisma.class_teachersCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$class_teachersPayload>
          }
          createMany: {
            args: Prisma.class_teachersCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.class_teachersCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$class_teachersPayload>[]
          }
          delete: {
            args: Prisma.class_teachersDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$class_teachersPayload>
          }
          update: {
            args: Prisma.class_teachersUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$class_teachersPayload>
          }
          deleteMany: {
            args: Prisma.class_teachersDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.class_teachersUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.class_teachersUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$class_teachersPayload>[]
          }
          upsert: {
            args: Prisma.class_teachersUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$class_teachersPayload>
          }
          aggregate: {
            args: Prisma.Class_teachersAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClass_teachers>
          }
          groupBy: {
            args: Prisma.class_teachersGroupByArgs<ExtArgs>
            result: $Utils.Optional<Class_teachersGroupByOutputType>[]
          }
          count: {
            args: Prisma.class_teachersCountArgs<ExtArgs>
            result: $Utils.Optional<Class_teachersCountAggregateOutputType> | number
          }
        }
      }
      exams: {
        payload: Prisma.$examsPayload<ExtArgs>
        fields: Prisma.examsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.examsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$examsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.examsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$examsPayload>
          }
          findFirst: {
            args: Prisma.examsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$examsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.examsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$examsPayload>
          }
          findMany: {
            args: Prisma.examsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$examsPayload>[]
          }
          create: {
            args: Prisma.examsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$examsPayload>
          }
          createMany: {
            args: Prisma.examsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.examsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$examsPayload>[]
          }
          delete: {
            args: Prisma.examsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$examsPayload>
          }
          update: {
            args: Prisma.examsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$examsPayload>
          }
          deleteMany: {
            args: Prisma.examsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.examsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.examsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$examsPayload>[]
          }
          upsert: {
            args: Prisma.examsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$examsPayload>
          }
          aggregate: {
            args: Prisma.ExamsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateExams>
          }
          groupBy: {
            args: Prisma.examsGroupByArgs<ExtArgs>
            result: $Utils.Optional<ExamsGroupByOutputType>[]
          }
          count: {
            args: Prisma.examsCountArgs<ExtArgs>
            result: $Utils.Optional<ExamsCountAggregateOutputType> | number
          }
        }
      }
      financecheckbook: {
        payload: Prisma.$financecheckbookPayload<ExtArgs>
        fields: Prisma.financecheckbookFieldRefs
        operations: {
          findUnique: {
            args: Prisma.financecheckbookFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$financecheckbookPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.financecheckbookFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$financecheckbookPayload>
          }
          findFirst: {
            args: Prisma.financecheckbookFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$financecheckbookPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.financecheckbookFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$financecheckbookPayload>
          }
          findMany: {
            args: Prisma.financecheckbookFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$financecheckbookPayload>[]
          }
          create: {
            args: Prisma.financecheckbookCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$financecheckbookPayload>
          }
          createMany: {
            args: Prisma.financecheckbookCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.financecheckbookCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$financecheckbookPayload>[]
          }
          delete: {
            args: Prisma.financecheckbookDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$financecheckbookPayload>
          }
          update: {
            args: Prisma.financecheckbookUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$financecheckbookPayload>
          }
          deleteMany: {
            args: Prisma.financecheckbookDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.financecheckbookUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.financecheckbookUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$financecheckbookPayload>[]
          }
          upsert: {
            args: Prisma.financecheckbookUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$financecheckbookPayload>
          }
          aggregate: {
            args: Prisma.FinancecheckbookAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFinancecheckbook>
          }
          groupBy: {
            args: Prisma.financecheckbookGroupByArgs<ExtArgs>
            result: $Utils.Optional<FinancecheckbookGroupByOutputType>[]
          }
          count: {
            args: Prisma.financecheckbookCountArgs<ExtArgs>
            result: $Utils.Optional<FinancecheckbookCountAggregateOutputType> | number
          }
        }
      }
      finances: {
        payload: Prisma.$financesPayload<ExtArgs>
        fields: Prisma.financesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.financesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$financesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.financesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$financesPayload>
          }
          findFirst: {
            args: Prisma.financesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$financesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.financesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$financesPayload>
          }
          findMany: {
            args: Prisma.financesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$financesPayload>[]
          }
          create: {
            args: Prisma.financesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$financesPayload>
          }
          createMany: {
            args: Prisma.financesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.financesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$financesPayload>[]
          }
          delete: {
            args: Prisma.financesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$financesPayload>
          }
          update: {
            args: Prisma.financesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$financesPayload>
          }
          deleteMany: {
            args: Prisma.financesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.financesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.financesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$financesPayload>[]
          }
          upsert: {
            args: Prisma.financesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$financesPayload>
          }
          aggregate: {
            args: Prisma.FinancesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFinances>
          }
          groupBy: {
            args: Prisma.financesGroupByArgs<ExtArgs>
            result: $Utils.Optional<FinancesGroupByOutputType>[]
          }
          count: {
            args: Prisma.financesCountArgs<ExtArgs>
            result: $Utils.Optional<FinancesCountAggregateOutputType> | number
          }
        }
      }
      notes: {
        payload: Prisma.$notesPayload<ExtArgs>
        fields: Prisma.notesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.notesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.notesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notesPayload>
          }
          findFirst: {
            args: Prisma.notesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.notesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notesPayload>
          }
          findMany: {
            args: Prisma.notesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notesPayload>[]
          }
          create: {
            args: Prisma.notesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notesPayload>
          }
          createMany: {
            args: Prisma.notesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.notesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notesPayload>[]
          }
          delete: {
            args: Prisma.notesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notesPayload>
          }
          update: {
            args: Prisma.notesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notesPayload>
          }
          deleteMany: {
            args: Prisma.notesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.notesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.notesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notesPayload>[]
          }
          upsert: {
            args: Prisma.notesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notesPayload>
          }
          aggregate: {
            args: Prisma.NotesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotes>
          }
          groupBy: {
            args: Prisma.notesGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotesGroupByOutputType>[]
          }
          count: {
            args: Prisma.notesCountArgs<ExtArgs>
            result: $Utils.Optional<NotesCountAggregateOutputType> | number
          }
        }
      }
      notices: {
        payload: Prisma.$noticesPayload<ExtArgs>
        fields: Prisma.noticesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.noticesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$noticesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.noticesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$noticesPayload>
          }
          findFirst: {
            args: Prisma.noticesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$noticesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.noticesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$noticesPayload>
          }
          findMany: {
            args: Prisma.noticesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$noticesPayload>[]
          }
          create: {
            args: Prisma.noticesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$noticesPayload>
          }
          createMany: {
            args: Prisma.noticesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.noticesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$noticesPayload>[]
          }
          delete: {
            args: Prisma.noticesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$noticesPayload>
          }
          update: {
            args: Prisma.noticesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$noticesPayload>
          }
          deleteMany: {
            args: Prisma.noticesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.noticesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.noticesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$noticesPayload>[]
          }
          upsert: {
            args: Prisma.noticesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$noticesPayload>
          }
          aggregate: {
            args: Prisma.NoticesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotices>
          }
          groupBy: {
            args: Prisma.noticesGroupByArgs<ExtArgs>
            result: $Utils.Optional<NoticesGroupByOutputType>[]
          }
          count: {
            args: Prisma.noticesCountArgs<ExtArgs>
            result: $Utils.Optional<NoticesCountAggregateOutputType> | number
          }
        }
      }
      performance: {
        payload: Prisma.$performancePayload<ExtArgs>
        fields: Prisma.performanceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.performanceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$performancePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.performanceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$performancePayload>
          }
          findFirst: {
            args: Prisma.performanceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$performancePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.performanceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$performancePayload>
          }
          findMany: {
            args: Prisma.performanceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$performancePayload>[]
          }
          create: {
            args: Prisma.performanceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$performancePayload>
          }
          createMany: {
            args: Prisma.performanceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.performanceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$performancePayload>[]
          }
          delete: {
            args: Prisma.performanceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$performancePayload>
          }
          update: {
            args: Prisma.performanceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$performancePayload>
          }
          deleteMany: {
            args: Prisma.performanceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.performanceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.performanceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$performancePayload>[]
          }
          upsert: {
            args: Prisma.performanceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$performancePayload>
          }
          aggregate: {
            args: Prisma.PerformanceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePerformance>
          }
          groupBy: {
            args: Prisma.performanceGroupByArgs<ExtArgs>
            result: $Utils.Optional<PerformanceGroupByOutputType>[]
          }
          count: {
            args: Prisma.performanceCountArgs<ExtArgs>
            result: $Utils.Optional<PerformanceCountAggregateOutputType> | number
          }
        }
      }
      student_performance: {
        payload: Prisma.$student_performancePayload<ExtArgs>
        fields: Prisma.student_performanceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.student_performanceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$student_performancePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.student_performanceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$student_performancePayload>
          }
          findFirst: {
            args: Prisma.student_performanceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$student_performancePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.student_performanceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$student_performancePayload>
          }
          findMany: {
            args: Prisma.student_performanceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$student_performancePayload>[]
          }
          create: {
            args: Prisma.student_performanceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$student_performancePayload>
          }
          createMany: {
            args: Prisma.student_performanceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.student_performanceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$student_performancePayload>[]
          }
          delete: {
            args: Prisma.student_performanceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$student_performancePayload>
          }
          update: {
            args: Prisma.student_performanceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$student_performancePayload>
          }
          deleteMany: {
            args: Prisma.student_performanceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.student_performanceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.student_performanceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$student_performancePayload>[]
          }
          upsert: {
            args: Prisma.student_performanceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$student_performancePayload>
          }
          aggregate: {
            args: Prisma.Student_performanceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStudent_performance>
          }
          groupBy: {
            args: Prisma.student_performanceGroupByArgs<ExtArgs>
            result: $Utils.Optional<Student_performanceGroupByOutputType>[]
          }
          count: {
            args: Prisma.student_performanceCountArgs<ExtArgs>
            result: $Utils.Optional<Student_performanceCountAggregateOutputType> | number
          }
        }
      }
      student_routine: {
        payload: Prisma.$student_routinePayload<ExtArgs>
        fields: Prisma.student_routineFieldRefs
        operations: {
          findUnique: {
            args: Prisma.student_routineFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$student_routinePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.student_routineFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$student_routinePayload>
          }
          findFirst: {
            args: Prisma.student_routineFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$student_routinePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.student_routineFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$student_routinePayload>
          }
          findMany: {
            args: Prisma.student_routineFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$student_routinePayload>[]
          }
          create: {
            args: Prisma.student_routineCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$student_routinePayload>
          }
          createMany: {
            args: Prisma.student_routineCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.student_routineCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$student_routinePayload>[]
          }
          delete: {
            args: Prisma.student_routineDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$student_routinePayload>
          }
          update: {
            args: Prisma.student_routineUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$student_routinePayload>
          }
          deleteMany: {
            args: Prisma.student_routineDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.student_routineUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.student_routineUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$student_routinePayload>[]
          }
          upsert: {
            args: Prisma.student_routineUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$student_routinePayload>
          }
          aggregate: {
            args: Prisma.Student_routineAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStudent_routine>
          }
          groupBy: {
            args: Prisma.student_routineGroupByArgs<ExtArgs>
            result: $Utils.Optional<Student_routineGroupByOutputType>[]
          }
          count: {
            args: Prisma.student_routineCountArgs<ExtArgs>
            result: $Utils.Optional<Student_routineCountAggregateOutputType> | number
          }
        }
      }
      students: {
        payload: Prisma.$studentsPayload<ExtArgs>
        fields: Prisma.studentsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.studentsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$studentsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.studentsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$studentsPayload>
          }
          findFirst: {
            args: Prisma.studentsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$studentsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.studentsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$studentsPayload>
          }
          findMany: {
            args: Prisma.studentsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$studentsPayload>[]
          }
          create: {
            args: Prisma.studentsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$studentsPayload>
          }
          createMany: {
            args: Prisma.studentsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.studentsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$studentsPayload>[]
          }
          delete: {
            args: Prisma.studentsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$studentsPayload>
          }
          update: {
            args: Prisma.studentsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$studentsPayload>
          }
          deleteMany: {
            args: Prisma.studentsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.studentsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.studentsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$studentsPayload>[]
          }
          upsert: {
            args: Prisma.studentsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$studentsPayload>
          }
          aggregate: {
            args: Prisma.StudentsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStudents>
          }
          groupBy: {
            args: Prisma.studentsGroupByArgs<ExtArgs>
            result: $Utils.Optional<StudentsGroupByOutputType>[]
          }
          count: {
            args: Prisma.studentsCountArgs<ExtArgs>
            result: $Utils.Optional<StudentsCountAggregateOutputType> | number
          }
        }
      }
      teacher_routine: {
        payload: Prisma.$teacher_routinePayload<ExtArgs>
        fields: Prisma.teacher_routineFieldRefs
        operations: {
          findUnique: {
            args: Prisma.teacher_routineFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$teacher_routinePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.teacher_routineFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$teacher_routinePayload>
          }
          findFirst: {
            args: Prisma.teacher_routineFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$teacher_routinePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.teacher_routineFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$teacher_routinePayload>
          }
          findMany: {
            args: Prisma.teacher_routineFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$teacher_routinePayload>[]
          }
          create: {
            args: Prisma.teacher_routineCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$teacher_routinePayload>
          }
          createMany: {
            args: Prisma.teacher_routineCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.teacher_routineCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$teacher_routinePayload>[]
          }
          delete: {
            args: Prisma.teacher_routineDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$teacher_routinePayload>
          }
          update: {
            args: Prisma.teacher_routineUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$teacher_routinePayload>
          }
          deleteMany: {
            args: Prisma.teacher_routineDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.teacher_routineUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.teacher_routineUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$teacher_routinePayload>[]
          }
          upsert: {
            args: Prisma.teacher_routineUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$teacher_routinePayload>
          }
          aggregate: {
            args: Prisma.Teacher_routineAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTeacher_routine>
          }
          groupBy: {
            args: Prisma.teacher_routineGroupByArgs<ExtArgs>
            result: $Utils.Optional<Teacher_routineGroupByOutputType>[]
          }
          count: {
            args: Prisma.teacher_routineCountArgs<ExtArgs>
            result: $Utils.Optional<Teacher_routineCountAggregateOutputType> | number
          }
        }
      }
      teachers: {
        payload: Prisma.$teachersPayload<ExtArgs>
        fields: Prisma.teachersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.teachersFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$teachersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.teachersFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$teachersPayload>
          }
          findFirst: {
            args: Prisma.teachersFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$teachersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.teachersFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$teachersPayload>
          }
          findMany: {
            args: Prisma.teachersFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$teachersPayload>[]
          }
          create: {
            args: Prisma.teachersCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$teachersPayload>
          }
          createMany: {
            args: Prisma.teachersCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.teachersCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$teachersPayload>[]
          }
          delete: {
            args: Prisma.teachersDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$teachersPayload>
          }
          update: {
            args: Prisma.teachersUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$teachersPayload>
          }
          deleteMany: {
            args: Prisma.teachersDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.teachersUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.teachersUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$teachersPayload>[]
          }
          upsert: {
            args: Prisma.teachersUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$teachersPayload>
          }
          aggregate: {
            args: Prisma.TeachersAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTeachers>
          }
          groupBy: {
            args: Prisma.teachersGroupByArgs<ExtArgs>
            result: $Utils.Optional<TeachersGroupByOutputType>[]
          }
          count: {
            args: Prisma.teachersCountArgs<ExtArgs>
            result: $Utils.Optional<TeachersCountAggregateOutputType> | number
          }
        }
      }
      upcoming_events: {
        payload: Prisma.$upcoming_eventsPayload<ExtArgs>
        fields: Prisma.upcoming_eventsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.upcoming_eventsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$upcoming_eventsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.upcoming_eventsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$upcoming_eventsPayload>
          }
          findFirst: {
            args: Prisma.upcoming_eventsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$upcoming_eventsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.upcoming_eventsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$upcoming_eventsPayload>
          }
          findMany: {
            args: Prisma.upcoming_eventsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$upcoming_eventsPayload>[]
          }
          create: {
            args: Prisma.upcoming_eventsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$upcoming_eventsPayload>
          }
          createMany: {
            args: Prisma.upcoming_eventsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.upcoming_eventsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$upcoming_eventsPayload>[]
          }
          delete: {
            args: Prisma.upcoming_eventsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$upcoming_eventsPayload>
          }
          update: {
            args: Prisma.upcoming_eventsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$upcoming_eventsPayload>
          }
          deleteMany: {
            args: Prisma.upcoming_eventsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.upcoming_eventsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.upcoming_eventsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$upcoming_eventsPayload>[]
          }
          upsert: {
            args: Prisma.upcoming_eventsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$upcoming_eventsPayload>
          }
          aggregate: {
            args: Prisma.Upcoming_eventsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUpcoming_events>
          }
          groupBy: {
            args: Prisma.upcoming_eventsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Upcoming_eventsGroupByOutputType>[]
          }
          count: {
            args: Prisma.upcoming_eventsCountArgs<ExtArgs>
            result: $Utils.Optional<Upcoming_eventsCountAggregateOutputType> | number
          }
        }
      }
      users: {
        payload: Prisma.$usersPayload<ExtArgs>
        fields: Prisma.usersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.usersFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.usersFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          findFirst: {
            args: Prisma.usersFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.usersFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          findMany: {
            args: Prisma.usersFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>[]
          }
          create: {
            args: Prisma.usersCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          createMany: {
            args: Prisma.usersCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.usersCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>[]
          }
          delete: {
            args: Prisma.usersDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          update: {
            args: Prisma.usersUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          deleteMany: {
            args: Prisma.usersDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.usersUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.usersUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>[]
          }
          upsert: {
            args: Prisma.usersUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          aggregate: {
            args: Prisma.UsersAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUsers>
          }
          groupBy: {
            args: Prisma.usersGroupByArgs<ExtArgs>
            result: $Utils.Optional<UsersGroupByOutputType>[]
          }
          count: {
            args: Prisma.usersCountArgs<ExtArgs>
            result: $Utils.Optional<UsersCountAggregateOutputType> | number
          }
        }
      }
      workroom_messages: {
        payload: Prisma.$workroom_messagesPayload<ExtArgs>
        fields: Prisma.workroom_messagesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.workroom_messagesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$workroom_messagesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.workroom_messagesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$workroom_messagesPayload>
          }
          findFirst: {
            args: Prisma.workroom_messagesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$workroom_messagesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.workroom_messagesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$workroom_messagesPayload>
          }
          findMany: {
            args: Prisma.workroom_messagesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$workroom_messagesPayload>[]
          }
          create: {
            args: Prisma.workroom_messagesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$workroom_messagesPayload>
          }
          createMany: {
            args: Prisma.workroom_messagesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.workroom_messagesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$workroom_messagesPayload>[]
          }
          delete: {
            args: Prisma.workroom_messagesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$workroom_messagesPayload>
          }
          update: {
            args: Prisma.workroom_messagesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$workroom_messagesPayload>
          }
          deleteMany: {
            args: Prisma.workroom_messagesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.workroom_messagesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.workroom_messagesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$workroom_messagesPayload>[]
          }
          upsert: {
            args: Prisma.workroom_messagesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$workroom_messagesPayload>
          }
          aggregate: {
            args: Prisma.Workroom_messagesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWorkroom_messages>
          }
          groupBy: {
            args: Prisma.workroom_messagesGroupByArgs<ExtArgs>
            result: $Utils.Optional<Workroom_messagesGroupByOutputType>[]
          }
          count: {
            args: Prisma.workroom_messagesCountArgs<ExtArgs>
            result: $Utils.Optional<Workroom_messagesCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    assignments?: assignmentsOmit
    attendance?: attendanceOmit
    calendar?: calendarOmit
    class_representatives?: class_representativesOmit
    class_routine?: class_routineOmit
    class_teachers?: class_teachersOmit
    exams?: examsOmit
    financecheckbook?: financecheckbookOmit
    finances?: financesOmit
    notes?: notesOmit
    notices?: noticesOmit
    performance?: performanceOmit
    student_performance?: student_performanceOmit
    student_routine?: student_routineOmit
    students?: studentsOmit
    teacher_routine?: teacher_routineOmit
    teachers?: teachersOmit
    upcoming_events?: upcoming_eventsOmit
    users?: usersOmit
    workroom_messages?: workroom_messagesOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type CalendarCountOutputType
   */

  export type CalendarCountOutputType = {
    upcoming_events: number
  }

  export type CalendarCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    upcoming_events?: boolean | CalendarCountOutputTypeCountUpcoming_eventsArgs
  }

  // Custom InputTypes
  /**
   * CalendarCountOutputType without action
   */
  export type CalendarCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CalendarCountOutputType
     */
    select?: CalendarCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CalendarCountOutputType without action
   */
  export type CalendarCountOutputTypeCountUpcoming_eventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: upcoming_eventsWhereInput
  }


  /**
   * Count Type ExamsCountOutputType
   */

  export type ExamsCountOutputType = {
    performance: number
    student_performance: number
  }

  export type ExamsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    performance?: boolean | ExamsCountOutputTypeCountPerformanceArgs
    student_performance?: boolean | ExamsCountOutputTypeCountStudent_performanceArgs
  }

  // Custom InputTypes
  /**
   * ExamsCountOutputType without action
   */
  export type ExamsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamsCountOutputType
     */
    select?: ExamsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ExamsCountOutputType without action
   */
  export type ExamsCountOutputTypeCountPerformanceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: performanceWhereInput
  }

  /**
   * ExamsCountOutputType without action
   */
  export type ExamsCountOutputTypeCountStudent_performanceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: student_performanceWhereInput
  }


  /**
   * Count Type Student_performanceCountOutputType
   */

  export type Student_performanceCountOutputType = {
    performance: number
  }

  export type Student_performanceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    performance?: boolean | Student_performanceCountOutputTypeCountPerformanceArgs
  }

  // Custom InputTypes
  /**
   * Student_performanceCountOutputType without action
   */
  export type Student_performanceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student_performanceCountOutputType
     */
    select?: Student_performanceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Student_performanceCountOutputType without action
   */
  export type Student_performanceCountOutputTypeCountPerformanceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: performanceWhereInput
  }


  /**
   * Count Type StudentsCountOutputType
   */

  export type StudentsCountOutputType = {
    attendance: number
    class_representatives: number
    class_teachers: number
    finances: number
    student_performance: number
  }

  export type StudentsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    attendance?: boolean | StudentsCountOutputTypeCountAttendanceArgs
    class_representatives?: boolean | StudentsCountOutputTypeCountClass_representativesArgs
    class_teachers?: boolean | StudentsCountOutputTypeCountClass_teachersArgs
    finances?: boolean | StudentsCountOutputTypeCountFinancesArgs
    student_performance?: boolean | StudentsCountOutputTypeCountStudent_performanceArgs
  }

  // Custom InputTypes
  /**
   * StudentsCountOutputType without action
   */
  export type StudentsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentsCountOutputType
     */
    select?: StudentsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * StudentsCountOutputType without action
   */
  export type StudentsCountOutputTypeCountAttendanceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: attendanceWhereInput
  }

  /**
   * StudentsCountOutputType without action
   */
  export type StudentsCountOutputTypeCountClass_representativesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: class_representativesWhereInput
  }

  /**
   * StudentsCountOutputType without action
   */
  export type StudentsCountOutputTypeCountClass_teachersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: class_teachersWhereInput
  }

  /**
   * StudentsCountOutputType without action
   */
  export type StudentsCountOutputTypeCountFinancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: financesWhereInput
  }

  /**
   * StudentsCountOutputType without action
   */
  export type StudentsCountOutputTypeCountStudent_performanceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: student_performanceWhereInput
  }


  /**
   * Count Type TeachersCountOutputType
   */

  export type TeachersCountOutputType = {
    assignments: number
    attendance: number
    class_routine: number
    class_teachers: number
    exams: number
    performance: number
    student_routine: number
  }

  export type TeachersCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assignments?: boolean | TeachersCountOutputTypeCountAssignmentsArgs
    attendance?: boolean | TeachersCountOutputTypeCountAttendanceArgs
    class_routine?: boolean | TeachersCountOutputTypeCountClass_routineArgs
    class_teachers?: boolean | TeachersCountOutputTypeCountClass_teachersArgs
    exams?: boolean | TeachersCountOutputTypeCountExamsArgs
    performance?: boolean | TeachersCountOutputTypeCountPerformanceArgs
    student_routine?: boolean | TeachersCountOutputTypeCountStudent_routineArgs
  }

  // Custom InputTypes
  /**
   * TeachersCountOutputType without action
   */
  export type TeachersCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeachersCountOutputType
     */
    select?: TeachersCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TeachersCountOutputType without action
   */
  export type TeachersCountOutputTypeCountAssignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: assignmentsWhereInput
  }

  /**
   * TeachersCountOutputType without action
   */
  export type TeachersCountOutputTypeCountAttendanceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: attendanceWhereInput
  }

  /**
   * TeachersCountOutputType without action
   */
  export type TeachersCountOutputTypeCountClass_routineArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: class_routineWhereInput
  }

  /**
   * TeachersCountOutputType without action
   */
  export type TeachersCountOutputTypeCountClass_teachersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: class_teachersWhereInput
  }

  /**
   * TeachersCountOutputType without action
   */
  export type TeachersCountOutputTypeCountExamsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: examsWhereInput
  }

  /**
   * TeachersCountOutputType without action
   */
  export type TeachersCountOutputTypeCountPerformanceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: performanceWhereInput
  }

  /**
   * TeachersCountOutputType without action
   */
  export type TeachersCountOutputTypeCountStudent_routineArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: student_routineWhereInput
  }


  /**
   * Count Type UsersCountOutputType
   */

  export type UsersCountOutputType = {
    notes: number
    notices: number
    students: number
    teacher_routine: number
    teachers: number
    workroom_messages_workroom_messages_receiver_idTousers: number
    workroom_messages_workroom_messages_sender_idTousers: number
  }

  export type UsersCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    notes?: boolean | UsersCountOutputTypeCountNotesArgs
    notices?: boolean | UsersCountOutputTypeCountNoticesArgs
    students?: boolean | UsersCountOutputTypeCountStudentsArgs
    teacher_routine?: boolean | UsersCountOutputTypeCountTeacher_routineArgs
    teachers?: boolean | UsersCountOutputTypeCountTeachersArgs
    workroom_messages_workroom_messages_receiver_idTousers?: boolean | UsersCountOutputTypeCountWorkroom_messages_workroom_messages_receiver_idTousersArgs
    workroom_messages_workroom_messages_sender_idTousers?: boolean | UsersCountOutputTypeCountWorkroom_messages_workroom_messages_sender_idTousersArgs
  }

  // Custom InputTypes
  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsersCountOutputType
     */
    select?: UsersCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountNotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: notesWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountNoticesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: noticesWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountStudentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: studentsWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountTeacher_routineArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: teacher_routineWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountTeachersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: teachersWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountWorkroom_messages_workroom_messages_receiver_idTousersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: workroom_messagesWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountWorkroom_messages_workroom_messages_sender_idTousersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: workroom_messagesWhereInput
  }


  /**
   * Models
   */

  /**
   * Model assignments
   */

  export type AggregateAssignments = {
    _count: AssignmentsCountAggregateOutputType | null
    _avg: AssignmentsAvgAggregateOutputType | null
    _sum: AssignmentsSumAggregateOutputType | null
    _min: AssignmentsMinAggregateOutputType | null
    _max: AssignmentsMaxAggregateOutputType | null
  }

  export type AssignmentsAvgAggregateOutputType = {
    id: number | null
    assigned_by: number | null
  }

  export type AssignmentsSumAggregateOutputType = {
    id: number | null
    assigned_by: number | null
  }

  export type AssignmentsMinAggregateOutputType = {
    id: number | null
    title: string | null
    description: string | null
    subject: string | null
    class: string | null
    section: string | null
    assigned_by: number | null
    due_date: Date | null
    file: string | null
  }

  export type AssignmentsMaxAggregateOutputType = {
    id: number | null
    title: string | null
    description: string | null
    subject: string | null
    class: string | null
    section: string | null
    assigned_by: number | null
    due_date: Date | null
    file: string | null
  }

  export type AssignmentsCountAggregateOutputType = {
    id: number
    title: number
    description: number
    subject: number
    class: number
    section: number
    assigned_by: number
    due_date: number
    file: number
    _all: number
  }


  export type AssignmentsAvgAggregateInputType = {
    id?: true
    assigned_by?: true
  }

  export type AssignmentsSumAggregateInputType = {
    id?: true
    assigned_by?: true
  }

  export type AssignmentsMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    subject?: true
    class?: true
    section?: true
    assigned_by?: true
    due_date?: true
    file?: true
  }

  export type AssignmentsMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    subject?: true
    class?: true
    section?: true
    assigned_by?: true
    due_date?: true
    file?: true
  }

  export type AssignmentsCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    subject?: true
    class?: true
    section?: true
    assigned_by?: true
    due_date?: true
    file?: true
    _all?: true
  }

  export type AssignmentsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which assignments to aggregate.
     */
    where?: assignmentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of assignments to fetch.
     */
    orderBy?: assignmentsOrderByWithRelationInput | assignmentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: assignmentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` assignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` assignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned assignments
    **/
    _count?: true | AssignmentsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AssignmentsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AssignmentsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AssignmentsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AssignmentsMaxAggregateInputType
  }

  export type GetAssignmentsAggregateType<T extends AssignmentsAggregateArgs> = {
        [P in keyof T & keyof AggregateAssignments]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAssignments[P]>
      : GetScalarType<T[P], AggregateAssignments[P]>
  }




  export type assignmentsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: assignmentsWhereInput
    orderBy?: assignmentsOrderByWithAggregationInput | assignmentsOrderByWithAggregationInput[]
    by: AssignmentsScalarFieldEnum[] | AssignmentsScalarFieldEnum
    having?: assignmentsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AssignmentsCountAggregateInputType | true
    _avg?: AssignmentsAvgAggregateInputType
    _sum?: AssignmentsSumAggregateInputType
    _min?: AssignmentsMinAggregateInputType
    _max?: AssignmentsMaxAggregateInputType
  }

  export type AssignmentsGroupByOutputType = {
    id: number
    title: string
    description: string
    subject: string
    class: string
    section: string
    assigned_by: number | null
    due_date: Date
    file: string | null
    _count: AssignmentsCountAggregateOutputType | null
    _avg: AssignmentsAvgAggregateOutputType | null
    _sum: AssignmentsSumAggregateOutputType | null
    _min: AssignmentsMinAggregateOutputType | null
    _max: AssignmentsMaxAggregateOutputType | null
  }

  type GetAssignmentsGroupByPayload<T extends assignmentsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AssignmentsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AssignmentsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AssignmentsGroupByOutputType[P]>
            : GetScalarType<T[P], AssignmentsGroupByOutputType[P]>
        }
      >
    >


  export type assignmentsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    subject?: boolean
    class?: boolean
    section?: boolean
    assigned_by?: boolean
    due_date?: boolean
    file?: boolean
    teachers?: boolean | assignments$teachersArgs<ExtArgs>
  }, ExtArgs["result"]["assignments"]>

  export type assignmentsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    subject?: boolean
    class?: boolean
    section?: boolean
    assigned_by?: boolean
    due_date?: boolean
    file?: boolean
    teachers?: boolean | assignments$teachersArgs<ExtArgs>
  }, ExtArgs["result"]["assignments"]>

  export type assignmentsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    subject?: boolean
    class?: boolean
    section?: boolean
    assigned_by?: boolean
    due_date?: boolean
    file?: boolean
    teachers?: boolean | assignments$teachersArgs<ExtArgs>
  }, ExtArgs["result"]["assignments"]>

  export type assignmentsSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    subject?: boolean
    class?: boolean
    section?: boolean
    assigned_by?: boolean
    due_date?: boolean
    file?: boolean
  }

  export type assignmentsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "description" | "subject" | "class" | "section" | "assigned_by" | "due_date" | "file", ExtArgs["result"]["assignments"]>
  export type assignmentsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    teachers?: boolean | assignments$teachersArgs<ExtArgs>
  }
  export type assignmentsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    teachers?: boolean | assignments$teachersArgs<ExtArgs>
  }
  export type assignmentsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    teachers?: boolean | assignments$teachersArgs<ExtArgs>
  }

  export type $assignmentsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "assignments"
    objects: {
      teachers: Prisma.$teachersPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      title: string
      description: string
      subject: string
      class: string
      section: string
      assigned_by: number | null
      due_date: Date
      file: string | null
    }, ExtArgs["result"]["assignments"]>
    composites: {}
  }

  type assignmentsGetPayload<S extends boolean | null | undefined | assignmentsDefaultArgs> = $Result.GetResult<Prisma.$assignmentsPayload, S>

  type assignmentsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<assignmentsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AssignmentsCountAggregateInputType | true
    }

  export interface assignmentsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['assignments'], meta: { name: 'assignments' } }
    /**
     * Find zero or one Assignments that matches the filter.
     * @param {assignmentsFindUniqueArgs} args - Arguments to find a Assignments
     * @example
     * // Get one Assignments
     * const assignments = await prisma.assignments.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends assignmentsFindUniqueArgs>(args: SelectSubset<T, assignmentsFindUniqueArgs<ExtArgs>>): Prisma__assignmentsClient<$Result.GetResult<Prisma.$assignmentsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Assignments that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {assignmentsFindUniqueOrThrowArgs} args - Arguments to find a Assignments
     * @example
     * // Get one Assignments
     * const assignments = await prisma.assignments.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends assignmentsFindUniqueOrThrowArgs>(args: SelectSubset<T, assignmentsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__assignmentsClient<$Result.GetResult<Prisma.$assignmentsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Assignments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {assignmentsFindFirstArgs} args - Arguments to find a Assignments
     * @example
     * // Get one Assignments
     * const assignments = await prisma.assignments.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends assignmentsFindFirstArgs>(args?: SelectSubset<T, assignmentsFindFirstArgs<ExtArgs>>): Prisma__assignmentsClient<$Result.GetResult<Prisma.$assignmentsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Assignments that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {assignmentsFindFirstOrThrowArgs} args - Arguments to find a Assignments
     * @example
     * // Get one Assignments
     * const assignments = await prisma.assignments.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends assignmentsFindFirstOrThrowArgs>(args?: SelectSubset<T, assignmentsFindFirstOrThrowArgs<ExtArgs>>): Prisma__assignmentsClient<$Result.GetResult<Prisma.$assignmentsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Assignments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {assignmentsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Assignments
     * const assignments = await prisma.assignments.findMany()
     * 
     * // Get first 10 Assignments
     * const assignments = await prisma.assignments.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const assignmentsWithIdOnly = await prisma.assignments.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends assignmentsFindManyArgs>(args?: SelectSubset<T, assignmentsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$assignmentsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Assignments.
     * @param {assignmentsCreateArgs} args - Arguments to create a Assignments.
     * @example
     * // Create one Assignments
     * const Assignments = await prisma.assignments.create({
     *   data: {
     *     // ... data to create a Assignments
     *   }
     * })
     * 
     */
    create<T extends assignmentsCreateArgs>(args: SelectSubset<T, assignmentsCreateArgs<ExtArgs>>): Prisma__assignmentsClient<$Result.GetResult<Prisma.$assignmentsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Assignments.
     * @param {assignmentsCreateManyArgs} args - Arguments to create many Assignments.
     * @example
     * // Create many Assignments
     * const assignments = await prisma.assignments.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends assignmentsCreateManyArgs>(args?: SelectSubset<T, assignmentsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Assignments and returns the data saved in the database.
     * @param {assignmentsCreateManyAndReturnArgs} args - Arguments to create many Assignments.
     * @example
     * // Create many Assignments
     * const assignments = await prisma.assignments.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Assignments and only return the `id`
     * const assignmentsWithIdOnly = await prisma.assignments.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends assignmentsCreateManyAndReturnArgs>(args?: SelectSubset<T, assignmentsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$assignmentsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Assignments.
     * @param {assignmentsDeleteArgs} args - Arguments to delete one Assignments.
     * @example
     * // Delete one Assignments
     * const Assignments = await prisma.assignments.delete({
     *   where: {
     *     // ... filter to delete one Assignments
     *   }
     * })
     * 
     */
    delete<T extends assignmentsDeleteArgs>(args: SelectSubset<T, assignmentsDeleteArgs<ExtArgs>>): Prisma__assignmentsClient<$Result.GetResult<Prisma.$assignmentsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Assignments.
     * @param {assignmentsUpdateArgs} args - Arguments to update one Assignments.
     * @example
     * // Update one Assignments
     * const assignments = await prisma.assignments.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends assignmentsUpdateArgs>(args: SelectSubset<T, assignmentsUpdateArgs<ExtArgs>>): Prisma__assignmentsClient<$Result.GetResult<Prisma.$assignmentsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Assignments.
     * @param {assignmentsDeleteManyArgs} args - Arguments to filter Assignments to delete.
     * @example
     * // Delete a few Assignments
     * const { count } = await prisma.assignments.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends assignmentsDeleteManyArgs>(args?: SelectSubset<T, assignmentsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Assignments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {assignmentsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Assignments
     * const assignments = await prisma.assignments.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends assignmentsUpdateManyArgs>(args: SelectSubset<T, assignmentsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Assignments and returns the data updated in the database.
     * @param {assignmentsUpdateManyAndReturnArgs} args - Arguments to update many Assignments.
     * @example
     * // Update many Assignments
     * const assignments = await prisma.assignments.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Assignments and only return the `id`
     * const assignmentsWithIdOnly = await prisma.assignments.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends assignmentsUpdateManyAndReturnArgs>(args: SelectSubset<T, assignmentsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$assignmentsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Assignments.
     * @param {assignmentsUpsertArgs} args - Arguments to update or create a Assignments.
     * @example
     * // Update or create a Assignments
     * const assignments = await prisma.assignments.upsert({
     *   create: {
     *     // ... data to create a Assignments
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Assignments we want to update
     *   }
     * })
     */
    upsert<T extends assignmentsUpsertArgs>(args: SelectSubset<T, assignmentsUpsertArgs<ExtArgs>>): Prisma__assignmentsClient<$Result.GetResult<Prisma.$assignmentsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Assignments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {assignmentsCountArgs} args - Arguments to filter Assignments to count.
     * @example
     * // Count the number of Assignments
     * const count = await prisma.assignments.count({
     *   where: {
     *     // ... the filter for the Assignments we want to count
     *   }
     * })
    **/
    count<T extends assignmentsCountArgs>(
      args?: Subset<T, assignmentsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AssignmentsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Assignments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssignmentsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AssignmentsAggregateArgs>(args: Subset<T, AssignmentsAggregateArgs>): Prisma.PrismaPromise<GetAssignmentsAggregateType<T>>

    /**
     * Group by Assignments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {assignmentsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends assignmentsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: assignmentsGroupByArgs['orderBy'] }
        : { orderBy?: assignmentsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, assignmentsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAssignmentsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the assignments model
   */
  readonly fields: assignmentsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for assignments.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__assignmentsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    teachers<T extends assignments$teachersArgs<ExtArgs> = {}>(args?: Subset<T, assignments$teachersArgs<ExtArgs>>): Prisma__teachersClient<$Result.GetResult<Prisma.$teachersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the assignments model
   */
  interface assignmentsFieldRefs {
    readonly id: FieldRef<"assignments", 'Int'>
    readonly title: FieldRef<"assignments", 'String'>
    readonly description: FieldRef<"assignments", 'String'>
    readonly subject: FieldRef<"assignments", 'String'>
    readonly class: FieldRef<"assignments", 'String'>
    readonly section: FieldRef<"assignments", 'String'>
    readonly assigned_by: FieldRef<"assignments", 'Int'>
    readonly due_date: FieldRef<"assignments", 'DateTime'>
    readonly file: FieldRef<"assignments", 'String'>
  }
    

  // Custom InputTypes
  /**
   * assignments findUnique
   */
  export type assignmentsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the assignments
     */
    select?: assignmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the assignments
     */
    omit?: assignmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: assignmentsInclude<ExtArgs> | null
    /**
     * Filter, which assignments to fetch.
     */
    where: assignmentsWhereUniqueInput
  }

  /**
   * assignments findUniqueOrThrow
   */
  export type assignmentsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the assignments
     */
    select?: assignmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the assignments
     */
    omit?: assignmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: assignmentsInclude<ExtArgs> | null
    /**
     * Filter, which assignments to fetch.
     */
    where: assignmentsWhereUniqueInput
  }

  /**
   * assignments findFirst
   */
  export type assignmentsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the assignments
     */
    select?: assignmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the assignments
     */
    omit?: assignmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: assignmentsInclude<ExtArgs> | null
    /**
     * Filter, which assignments to fetch.
     */
    where?: assignmentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of assignments to fetch.
     */
    orderBy?: assignmentsOrderByWithRelationInput | assignmentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for assignments.
     */
    cursor?: assignmentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` assignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` assignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of assignments.
     */
    distinct?: AssignmentsScalarFieldEnum | AssignmentsScalarFieldEnum[]
  }

  /**
   * assignments findFirstOrThrow
   */
  export type assignmentsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the assignments
     */
    select?: assignmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the assignments
     */
    omit?: assignmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: assignmentsInclude<ExtArgs> | null
    /**
     * Filter, which assignments to fetch.
     */
    where?: assignmentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of assignments to fetch.
     */
    orderBy?: assignmentsOrderByWithRelationInput | assignmentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for assignments.
     */
    cursor?: assignmentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` assignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` assignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of assignments.
     */
    distinct?: AssignmentsScalarFieldEnum | AssignmentsScalarFieldEnum[]
  }

  /**
   * assignments findMany
   */
  export type assignmentsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the assignments
     */
    select?: assignmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the assignments
     */
    omit?: assignmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: assignmentsInclude<ExtArgs> | null
    /**
     * Filter, which assignments to fetch.
     */
    where?: assignmentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of assignments to fetch.
     */
    orderBy?: assignmentsOrderByWithRelationInput | assignmentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing assignments.
     */
    cursor?: assignmentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` assignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` assignments.
     */
    skip?: number
    distinct?: AssignmentsScalarFieldEnum | AssignmentsScalarFieldEnum[]
  }

  /**
   * assignments create
   */
  export type assignmentsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the assignments
     */
    select?: assignmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the assignments
     */
    omit?: assignmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: assignmentsInclude<ExtArgs> | null
    /**
     * The data needed to create a assignments.
     */
    data: XOR<assignmentsCreateInput, assignmentsUncheckedCreateInput>
  }

  /**
   * assignments createMany
   */
  export type assignmentsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many assignments.
     */
    data: assignmentsCreateManyInput | assignmentsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * assignments createManyAndReturn
   */
  export type assignmentsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the assignments
     */
    select?: assignmentsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the assignments
     */
    omit?: assignmentsOmit<ExtArgs> | null
    /**
     * The data used to create many assignments.
     */
    data: assignmentsCreateManyInput | assignmentsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: assignmentsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * assignments update
   */
  export type assignmentsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the assignments
     */
    select?: assignmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the assignments
     */
    omit?: assignmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: assignmentsInclude<ExtArgs> | null
    /**
     * The data needed to update a assignments.
     */
    data: XOR<assignmentsUpdateInput, assignmentsUncheckedUpdateInput>
    /**
     * Choose, which assignments to update.
     */
    where: assignmentsWhereUniqueInput
  }

  /**
   * assignments updateMany
   */
  export type assignmentsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update assignments.
     */
    data: XOR<assignmentsUpdateManyMutationInput, assignmentsUncheckedUpdateManyInput>
    /**
     * Filter which assignments to update
     */
    where?: assignmentsWhereInput
    /**
     * Limit how many assignments to update.
     */
    limit?: number
  }

  /**
   * assignments updateManyAndReturn
   */
  export type assignmentsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the assignments
     */
    select?: assignmentsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the assignments
     */
    omit?: assignmentsOmit<ExtArgs> | null
    /**
     * The data used to update assignments.
     */
    data: XOR<assignmentsUpdateManyMutationInput, assignmentsUncheckedUpdateManyInput>
    /**
     * Filter which assignments to update
     */
    where?: assignmentsWhereInput
    /**
     * Limit how many assignments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: assignmentsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * assignments upsert
   */
  export type assignmentsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the assignments
     */
    select?: assignmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the assignments
     */
    omit?: assignmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: assignmentsInclude<ExtArgs> | null
    /**
     * The filter to search for the assignments to update in case it exists.
     */
    where: assignmentsWhereUniqueInput
    /**
     * In case the assignments found by the `where` argument doesn't exist, create a new assignments with this data.
     */
    create: XOR<assignmentsCreateInput, assignmentsUncheckedCreateInput>
    /**
     * In case the assignments was found with the provided `where` argument, update it with this data.
     */
    update: XOR<assignmentsUpdateInput, assignmentsUncheckedUpdateInput>
  }

  /**
   * assignments delete
   */
  export type assignmentsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the assignments
     */
    select?: assignmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the assignments
     */
    omit?: assignmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: assignmentsInclude<ExtArgs> | null
    /**
     * Filter which assignments to delete.
     */
    where: assignmentsWhereUniqueInput
  }

  /**
   * assignments deleteMany
   */
  export type assignmentsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which assignments to delete
     */
    where?: assignmentsWhereInput
    /**
     * Limit how many assignments to delete.
     */
    limit?: number
  }

  /**
   * assignments.teachers
   */
  export type assignments$teachersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the teachers
     */
    select?: teachersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the teachers
     */
    omit?: teachersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teachersInclude<ExtArgs> | null
    where?: teachersWhereInput
  }

  /**
   * assignments without action
   */
  export type assignmentsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the assignments
     */
    select?: assignmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the assignments
     */
    omit?: assignmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: assignmentsInclude<ExtArgs> | null
  }


  /**
   * Model attendance
   */

  export type AggregateAttendance = {
    _count: AttendanceCountAggregateOutputType | null
    _avg: AttendanceAvgAggregateOutputType | null
    _sum: AttendanceSumAggregateOutputType | null
    _min: AttendanceMinAggregateOutputType | null
    _max: AttendanceMaxAggregateOutputType | null
  }

  export type AttendanceAvgAggregateOutputType = {
    id: number | null
    student_id: number | null
    teacher_id: number | null
    class: number | null
  }

  export type AttendanceSumAggregateOutputType = {
    id: number | null
    student_id: number | null
    teacher_id: number | null
    class: number | null
  }

  export type AttendanceMinAggregateOutputType = {
    id: number | null
    student_id: number | null
    teacher_id: number | null
    class: number | null
    section: string | null
    date: Date | null
    status: string | null
    created_at: Date | null
  }

  export type AttendanceMaxAggregateOutputType = {
    id: number | null
    student_id: number | null
    teacher_id: number | null
    class: number | null
    section: string | null
    date: Date | null
    status: string | null
    created_at: Date | null
  }

  export type AttendanceCountAggregateOutputType = {
    id: number
    student_id: number
    teacher_id: number
    class: number
    section: number
    date: number
    status: number
    created_at: number
    _all: number
  }


  export type AttendanceAvgAggregateInputType = {
    id?: true
    student_id?: true
    teacher_id?: true
    class?: true
  }

  export type AttendanceSumAggregateInputType = {
    id?: true
    student_id?: true
    teacher_id?: true
    class?: true
  }

  export type AttendanceMinAggregateInputType = {
    id?: true
    student_id?: true
    teacher_id?: true
    class?: true
    section?: true
    date?: true
    status?: true
    created_at?: true
  }

  export type AttendanceMaxAggregateInputType = {
    id?: true
    student_id?: true
    teacher_id?: true
    class?: true
    section?: true
    date?: true
    status?: true
    created_at?: true
  }

  export type AttendanceCountAggregateInputType = {
    id?: true
    student_id?: true
    teacher_id?: true
    class?: true
    section?: true
    date?: true
    status?: true
    created_at?: true
    _all?: true
  }

  export type AttendanceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which attendance to aggregate.
     */
    where?: attendanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of attendances to fetch.
     */
    orderBy?: attendanceOrderByWithRelationInput | attendanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: attendanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` attendances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` attendances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned attendances
    **/
    _count?: true | AttendanceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AttendanceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AttendanceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AttendanceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AttendanceMaxAggregateInputType
  }

  export type GetAttendanceAggregateType<T extends AttendanceAggregateArgs> = {
        [P in keyof T & keyof AggregateAttendance]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAttendance[P]>
      : GetScalarType<T[P], AggregateAttendance[P]>
  }




  export type attendanceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: attendanceWhereInput
    orderBy?: attendanceOrderByWithAggregationInput | attendanceOrderByWithAggregationInput[]
    by: AttendanceScalarFieldEnum[] | AttendanceScalarFieldEnum
    having?: attendanceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AttendanceCountAggregateInputType | true
    _avg?: AttendanceAvgAggregateInputType
    _sum?: AttendanceSumAggregateInputType
    _min?: AttendanceMinAggregateInputType
    _max?: AttendanceMaxAggregateInputType
  }

  export type AttendanceGroupByOutputType = {
    id: number
    student_id: number
    teacher_id: number
    class: number
    section: string
    date: Date
    status: string
    created_at: Date | null
    _count: AttendanceCountAggregateOutputType | null
    _avg: AttendanceAvgAggregateOutputType | null
    _sum: AttendanceSumAggregateOutputType | null
    _min: AttendanceMinAggregateOutputType | null
    _max: AttendanceMaxAggregateOutputType | null
  }

  type GetAttendanceGroupByPayload<T extends attendanceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AttendanceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AttendanceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AttendanceGroupByOutputType[P]>
            : GetScalarType<T[P], AttendanceGroupByOutputType[P]>
        }
      >
    >


  export type attendanceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    student_id?: boolean
    teacher_id?: boolean
    class?: boolean
    section?: boolean
    date?: boolean
    status?: boolean
    created_at?: boolean
    students?: boolean | studentsDefaultArgs<ExtArgs>
    teachers?: boolean | teachersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["attendance"]>

  export type attendanceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    student_id?: boolean
    teacher_id?: boolean
    class?: boolean
    section?: boolean
    date?: boolean
    status?: boolean
    created_at?: boolean
    students?: boolean | studentsDefaultArgs<ExtArgs>
    teachers?: boolean | teachersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["attendance"]>

  export type attendanceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    student_id?: boolean
    teacher_id?: boolean
    class?: boolean
    section?: boolean
    date?: boolean
    status?: boolean
    created_at?: boolean
    students?: boolean | studentsDefaultArgs<ExtArgs>
    teachers?: boolean | teachersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["attendance"]>

  export type attendanceSelectScalar = {
    id?: boolean
    student_id?: boolean
    teacher_id?: boolean
    class?: boolean
    section?: boolean
    date?: boolean
    status?: boolean
    created_at?: boolean
  }

  export type attendanceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "student_id" | "teacher_id" | "class" | "section" | "date" | "status" | "created_at", ExtArgs["result"]["attendance"]>
  export type attendanceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    students?: boolean | studentsDefaultArgs<ExtArgs>
    teachers?: boolean | teachersDefaultArgs<ExtArgs>
  }
  export type attendanceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    students?: boolean | studentsDefaultArgs<ExtArgs>
    teachers?: boolean | teachersDefaultArgs<ExtArgs>
  }
  export type attendanceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    students?: boolean | studentsDefaultArgs<ExtArgs>
    teachers?: boolean | teachersDefaultArgs<ExtArgs>
  }

  export type $attendancePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "attendance"
    objects: {
      students: Prisma.$studentsPayload<ExtArgs>
      teachers: Prisma.$teachersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      student_id: number
      teacher_id: number
      class: number
      section: string
      date: Date
      status: string
      created_at: Date | null
    }, ExtArgs["result"]["attendance"]>
    composites: {}
  }

  type attendanceGetPayload<S extends boolean | null | undefined | attendanceDefaultArgs> = $Result.GetResult<Prisma.$attendancePayload, S>

  type attendanceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<attendanceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AttendanceCountAggregateInputType | true
    }

  export interface attendanceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['attendance'], meta: { name: 'attendance' } }
    /**
     * Find zero or one Attendance that matches the filter.
     * @param {attendanceFindUniqueArgs} args - Arguments to find a Attendance
     * @example
     * // Get one Attendance
     * const attendance = await prisma.attendance.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends attendanceFindUniqueArgs>(args: SelectSubset<T, attendanceFindUniqueArgs<ExtArgs>>): Prisma__attendanceClient<$Result.GetResult<Prisma.$attendancePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Attendance that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {attendanceFindUniqueOrThrowArgs} args - Arguments to find a Attendance
     * @example
     * // Get one Attendance
     * const attendance = await prisma.attendance.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends attendanceFindUniqueOrThrowArgs>(args: SelectSubset<T, attendanceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__attendanceClient<$Result.GetResult<Prisma.$attendancePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Attendance that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {attendanceFindFirstArgs} args - Arguments to find a Attendance
     * @example
     * // Get one Attendance
     * const attendance = await prisma.attendance.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends attendanceFindFirstArgs>(args?: SelectSubset<T, attendanceFindFirstArgs<ExtArgs>>): Prisma__attendanceClient<$Result.GetResult<Prisma.$attendancePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Attendance that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {attendanceFindFirstOrThrowArgs} args - Arguments to find a Attendance
     * @example
     * // Get one Attendance
     * const attendance = await prisma.attendance.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends attendanceFindFirstOrThrowArgs>(args?: SelectSubset<T, attendanceFindFirstOrThrowArgs<ExtArgs>>): Prisma__attendanceClient<$Result.GetResult<Prisma.$attendancePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Attendances that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {attendanceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Attendances
     * const attendances = await prisma.attendance.findMany()
     * 
     * // Get first 10 Attendances
     * const attendances = await prisma.attendance.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const attendanceWithIdOnly = await prisma.attendance.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends attendanceFindManyArgs>(args?: SelectSubset<T, attendanceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$attendancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Attendance.
     * @param {attendanceCreateArgs} args - Arguments to create a Attendance.
     * @example
     * // Create one Attendance
     * const Attendance = await prisma.attendance.create({
     *   data: {
     *     // ... data to create a Attendance
     *   }
     * })
     * 
     */
    create<T extends attendanceCreateArgs>(args: SelectSubset<T, attendanceCreateArgs<ExtArgs>>): Prisma__attendanceClient<$Result.GetResult<Prisma.$attendancePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Attendances.
     * @param {attendanceCreateManyArgs} args - Arguments to create many Attendances.
     * @example
     * // Create many Attendances
     * const attendance = await prisma.attendance.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends attendanceCreateManyArgs>(args?: SelectSubset<T, attendanceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Attendances and returns the data saved in the database.
     * @param {attendanceCreateManyAndReturnArgs} args - Arguments to create many Attendances.
     * @example
     * // Create many Attendances
     * const attendance = await prisma.attendance.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Attendances and only return the `id`
     * const attendanceWithIdOnly = await prisma.attendance.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends attendanceCreateManyAndReturnArgs>(args?: SelectSubset<T, attendanceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$attendancePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Attendance.
     * @param {attendanceDeleteArgs} args - Arguments to delete one Attendance.
     * @example
     * // Delete one Attendance
     * const Attendance = await prisma.attendance.delete({
     *   where: {
     *     // ... filter to delete one Attendance
     *   }
     * })
     * 
     */
    delete<T extends attendanceDeleteArgs>(args: SelectSubset<T, attendanceDeleteArgs<ExtArgs>>): Prisma__attendanceClient<$Result.GetResult<Prisma.$attendancePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Attendance.
     * @param {attendanceUpdateArgs} args - Arguments to update one Attendance.
     * @example
     * // Update one Attendance
     * const attendance = await prisma.attendance.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends attendanceUpdateArgs>(args: SelectSubset<T, attendanceUpdateArgs<ExtArgs>>): Prisma__attendanceClient<$Result.GetResult<Prisma.$attendancePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Attendances.
     * @param {attendanceDeleteManyArgs} args - Arguments to filter Attendances to delete.
     * @example
     * // Delete a few Attendances
     * const { count } = await prisma.attendance.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends attendanceDeleteManyArgs>(args?: SelectSubset<T, attendanceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Attendances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {attendanceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Attendances
     * const attendance = await prisma.attendance.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends attendanceUpdateManyArgs>(args: SelectSubset<T, attendanceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Attendances and returns the data updated in the database.
     * @param {attendanceUpdateManyAndReturnArgs} args - Arguments to update many Attendances.
     * @example
     * // Update many Attendances
     * const attendance = await prisma.attendance.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Attendances and only return the `id`
     * const attendanceWithIdOnly = await prisma.attendance.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends attendanceUpdateManyAndReturnArgs>(args: SelectSubset<T, attendanceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$attendancePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Attendance.
     * @param {attendanceUpsertArgs} args - Arguments to update or create a Attendance.
     * @example
     * // Update or create a Attendance
     * const attendance = await prisma.attendance.upsert({
     *   create: {
     *     // ... data to create a Attendance
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Attendance we want to update
     *   }
     * })
     */
    upsert<T extends attendanceUpsertArgs>(args: SelectSubset<T, attendanceUpsertArgs<ExtArgs>>): Prisma__attendanceClient<$Result.GetResult<Prisma.$attendancePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Attendances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {attendanceCountArgs} args - Arguments to filter Attendances to count.
     * @example
     * // Count the number of Attendances
     * const count = await prisma.attendance.count({
     *   where: {
     *     // ... the filter for the Attendances we want to count
     *   }
     * })
    **/
    count<T extends attendanceCountArgs>(
      args?: Subset<T, attendanceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AttendanceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Attendance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AttendanceAggregateArgs>(args: Subset<T, AttendanceAggregateArgs>): Prisma.PrismaPromise<GetAttendanceAggregateType<T>>

    /**
     * Group by Attendance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {attendanceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends attendanceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: attendanceGroupByArgs['orderBy'] }
        : { orderBy?: attendanceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, attendanceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAttendanceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the attendance model
   */
  readonly fields: attendanceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for attendance.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__attendanceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    students<T extends studentsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, studentsDefaultArgs<ExtArgs>>): Prisma__studentsClient<$Result.GetResult<Prisma.$studentsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    teachers<T extends teachersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, teachersDefaultArgs<ExtArgs>>): Prisma__teachersClient<$Result.GetResult<Prisma.$teachersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the attendance model
   */
  interface attendanceFieldRefs {
    readonly id: FieldRef<"attendance", 'Int'>
    readonly student_id: FieldRef<"attendance", 'Int'>
    readonly teacher_id: FieldRef<"attendance", 'Int'>
    readonly class: FieldRef<"attendance", 'Int'>
    readonly section: FieldRef<"attendance", 'String'>
    readonly date: FieldRef<"attendance", 'DateTime'>
    readonly status: FieldRef<"attendance", 'String'>
    readonly created_at: FieldRef<"attendance", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * attendance findUnique
   */
  export type attendanceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the attendance
     */
    select?: attendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the attendance
     */
    omit?: attendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: attendanceInclude<ExtArgs> | null
    /**
     * Filter, which attendance to fetch.
     */
    where: attendanceWhereUniqueInput
  }

  /**
   * attendance findUniqueOrThrow
   */
  export type attendanceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the attendance
     */
    select?: attendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the attendance
     */
    omit?: attendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: attendanceInclude<ExtArgs> | null
    /**
     * Filter, which attendance to fetch.
     */
    where: attendanceWhereUniqueInput
  }

  /**
   * attendance findFirst
   */
  export type attendanceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the attendance
     */
    select?: attendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the attendance
     */
    omit?: attendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: attendanceInclude<ExtArgs> | null
    /**
     * Filter, which attendance to fetch.
     */
    where?: attendanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of attendances to fetch.
     */
    orderBy?: attendanceOrderByWithRelationInput | attendanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for attendances.
     */
    cursor?: attendanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` attendances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` attendances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of attendances.
     */
    distinct?: AttendanceScalarFieldEnum | AttendanceScalarFieldEnum[]
  }

  /**
   * attendance findFirstOrThrow
   */
  export type attendanceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the attendance
     */
    select?: attendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the attendance
     */
    omit?: attendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: attendanceInclude<ExtArgs> | null
    /**
     * Filter, which attendance to fetch.
     */
    where?: attendanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of attendances to fetch.
     */
    orderBy?: attendanceOrderByWithRelationInput | attendanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for attendances.
     */
    cursor?: attendanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` attendances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` attendances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of attendances.
     */
    distinct?: AttendanceScalarFieldEnum | AttendanceScalarFieldEnum[]
  }

  /**
   * attendance findMany
   */
  export type attendanceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the attendance
     */
    select?: attendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the attendance
     */
    omit?: attendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: attendanceInclude<ExtArgs> | null
    /**
     * Filter, which attendances to fetch.
     */
    where?: attendanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of attendances to fetch.
     */
    orderBy?: attendanceOrderByWithRelationInput | attendanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing attendances.
     */
    cursor?: attendanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` attendances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` attendances.
     */
    skip?: number
    distinct?: AttendanceScalarFieldEnum | AttendanceScalarFieldEnum[]
  }

  /**
   * attendance create
   */
  export type attendanceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the attendance
     */
    select?: attendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the attendance
     */
    omit?: attendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: attendanceInclude<ExtArgs> | null
    /**
     * The data needed to create a attendance.
     */
    data: XOR<attendanceCreateInput, attendanceUncheckedCreateInput>
  }

  /**
   * attendance createMany
   */
  export type attendanceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many attendances.
     */
    data: attendanceCreateManyInput | attendanceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * attendance createManyAndReturn
   */
  export type attendanceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the attendance
     */
    select?: attendanceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the attendance
     */
    omit?: attendanceOmit<ExtArgs> | null
    /**
     * The data used to create many attendances.
     */
    data: attendanceCreateManyInput | attendanceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: attendanceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * attendance update
   */
  export type attendanceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the attendance
     */
    select?: attendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the attendance
     */
    omit?: attendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: attendanceInclude<ExtArgs> | null
    /**
     * The data needed to update a attendance.
     */
    data: XOR<attendanceUpdateInput, attendanceUncheckedUpdateInput>
    /**
     * Choose, which attendance to update.
     */
    where: attendanceWhereUniqueInput
  }

  /**
   * attendance updateMany
   */
  export type attendanceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update attendances.
     */
    data: XOR<attendanceUpdateManyMutationInput, attendanceUncheckedUpdateManyInput>
    /**
     * Filter which attendances to update
     */
    where?: attendanceWhereInput
    /**
     * Limit how many attendances to update.
     */
    limit?: number
  }

  /**
   * attendance updateManyAndReturn
   */
  export type attendanceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the attendance
     */
    select?: attendanceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the attendance
     */
    omit?: attendanceOmit<ExtArgs> | null
    /**
     * The data used to update attendances.
     */
    data: XOR<attendanceUpdateManyMutationInput, attendanceUncheckedUpdateManyInput>
    /**
     * Filter which attendances to update
     */
    where?: attendanceWhereInput
    /**
     * Limit how many attendances to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: attendanceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * attendance upsert
   */
  export type attendanceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the attendance
     */
    select?: attendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the attendance
     */
    omit?: attendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: attendanceInclude<ExtArgs> | null
    /**
     * The filter to search for the attendance to update in case it exists.
     */
    where: attendanceWhereUniqueInput
    /**
     * In case the attendance found by the `where` argument doesn't exist, create a new attendance with this data.
     */
    create: XOR<attendanceCreateInput, attendanceUncheckedCreateInput>
    /**
     * In case the attendance was found with the provided `where` argument, update it with this data.
     */
    update: XOR<attendanceUpdateInput, attendanceUncheckedUpdateInput>
  }

  /**
   * attendance delete
   */
  export type attendanceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the attendance
     */
    select?: attendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the attendance
     */
    omit?: attendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: attendanceInclude<ExtArgs> | null
    /**
     * Filter which attendance to delete.
     */
    where: attendanceWhereUniqueInput
  }

  /**
   * attendance deleteMany
   */
  export type attendanceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which attendances to delete
     */
    where?: attendanceWhereInput
    /**
     * Limit how many attendances to delete.
     */
    limit?: number
  }

  /**
   * attendance without action
   */
  export type attendanceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the attendance
     */
    select?: attendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the attendance
     */
    omit?: attendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: attendanceInclude<ExtArgs> | null
  }


  /**
   * Model calendar
   */

  export type AggregateCalendar = {
    _count: CalendarCountAggregateOutputType | null
    _avg: CalendarAvgAggregateOutputType | null
    _sum: CalendarSumAggregateOutputType | null
    _min: CalendarMinAggregateOutputType | null
    _max: CalendarMaxAggregateOutputType | null
  }

  export type CalendarAvgAggregateOutputType = {
    id: number | null
    year: number | null
  }

  export type CalendarSumAggregateOutputType = {
    id: number | null
    year: number | null
  }

  export type CalendarMinAggregateOutputType = {
    id: number | null
    month: string | null
    calendar: string | null
    year: number | null
  }

  export type CalendarMaxAggregateOutputType = {
    id: number | null
    month: string | null
    calendar: string | null
    year: number | null
  }

  export type CalendarCountAggregateOutputType = {
    id: number
    month: number
    calendar: number
    year: number
    _all: number
  }


  export type CalendarAvgAggregateInputType = {
    id?: true
    year?: true
  }

  export type CalendarSumAggregateInputType = {
    id?: true
    year?: true
  }

  export type CalendarMinAggregateInputType = {
    id?: true
    month?: true
    calendar?: true
    year?: true
  }

  export type CalendarMaxAggregateInputType = {
    id?: true
    month?: true
    calendar?: true
    year?: true
  }

  export type CalendarCountAggregateInputType = {
    id?: true
    month?: true
    calendar?: true
    year?: true
    _all?: true
  }

  export type CalendarAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which calendar to aggregate.
     */
    where?: calendarWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of calendars to fetch.
     */
    orderBy?: calendarOrderByWithRelationInput | calendarOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: calendarWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` calendars from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` calendars.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned calendars
    **/
    _count?: true | CalendarCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CalendarAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CalendarSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CalendarMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CalendarMaxAggregateInputType
  }

  export type GetCalendarAggregateType<T extends CalendarAggregateArgs> = {
        [P in keyof T & keyof AggregateCalendar]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCalendar[P]>
      : GetScalarType<T[P], AggregateCalendar[P]>
  }




  export type calendarGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: calendarWhereInput
    orderBy?: calendarOrderByWithAggregationInput | calendarOrderByWithAggregationInput[]
    by: CalendarScalarFieldEnum[] | CalendarScalarFieldEnum
    having?: calendarScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CalendarCountAggregateInputType | true
    _avg?: CalendarAvgAggregateInputType
    _sum?: CalendarSumAggregateInputType
    _min?: CalendarMinAggregateInputType
    _max?: CalendarMaxAggregateInputType
  }

  export type CalendarGroupByOutputType = {
    id: number
    month: string
    calendar: string
    year: number | null
    _count: CalendarCountAggregateOutputType | null
    _avg: CalendarAvgAggregateOutputType | null
    _sum: CalendarSumAggregateOutputType | null
    _min: CalendarMinAggregateOutputType | null
    _max: CalendarMaxAggregateOutputType | null
  }

  type GetCalendarGroupByPayload<T extends calendarGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CalendarGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CalendarGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CalendarGroupByOutputType[P]>
            : GetScalarType<T[P], CalendarGroupByOutputType[P]>
        }
      >
    >


  export type calendarSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    month?: boolean
    calendar?: boolean
    year?: boolean
    upcoming_events?: boolean | calendar$upcoming_eventsArgs<ExtArgs>
    _count?: boolean | CalendarCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["calendar"]>

  export type calendarSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    month?: boolean
    calendar?: boolean
    year?: boolean
  }, ExtArgs["result"]["calendar"]>

  export type calendarSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    month?: boolean
    calendar?: boolean
    year?: boolean
  }, ExtArgs["result"]["calendar"]>

  export type calendarSelectScalar = {
    id?: boolean
    month?: boolean
    calendar?: boolean
    year?: boolean
  }

  export type calendarOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "month" | "calendar" | "year", ExtArgs["result"]["calendar"]>
  export type calendarInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    upcoming_events?: boolean | calendar$upcoming_eventsArgs<ExtArgs>
    _count?: boolean | CalendarCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type calendarIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type calendarIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $calendarPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "calendar"
    objects: {
      upcoming_events: Prisma.$upcoming_eventsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      month: string
      calendar: string
      year: number | null
    }, ExtArgs["result"]["calendar"]>
    composites: {}
  }

  type calendarGetPayload<S extends boolean | null | undefined | calendarDefaultArgs> = $Result.GetResult<Prisma.$calendarPayload, S>

  type calendarCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<calendarFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CalendarCountAggregateInputType | true
    }

  export interface calendarDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['calendar'], meta: { name: 'calendar' } }
    /**
     * Find zero or one Calendar that matches the filter.
     * @param {calendarFindUniqueArgs} args - Arguments to find a Calendar
     * @example
     * // Get one Calendar
     * const calendar = await prisma.calendar.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends calendarFindUniqueArgs>(args: SelectSubset<T, calendarFindUniqueArgs<ExtArgs>>): Prisma__calendarClient<$Result.GetResult<Prisma.$calendarPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Calendar that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {calendarFindUniqueOrThrowArgs} args - Arguments to find a Calendar
     * @example
     * // Get one Calendar
     * const calendar = await prisma.calendar.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends calendarFindUniqueOrThrowArgs>(args: SelectSubset<T, calendarFindUniqueOrThrowArgs<ExtArgs>>): Prisma__calendarClient<$Result.GetResult<Prisma.$calendarPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Calendar that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {calendarFindFirstArgs} args - Arguments to find a Calendar
     * @example
     * // Get one Calendar
     * const calendar = await prisma.calendar.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends calendarFindFirstArgs>(args?: SelectSubset<T, calendarFindFirstArgs<ExtArgs>>): Prisma__calendarClient<$Result.GetResult<Prisma.$calendarPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Calendar that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {calendarFindFirstOrThrowArgs} args - Arguments to find a Calendar
     * @example
     * // Get one Calendar
     * const calendar = await prisma.calendar.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends calendarFindFirstOrThrowArgs>(args?: SelectSubset<T, calendarFindFirstOrThrowArgs<ExtArgs>>): Prisma__calendarClient<$Result.GetResult<Prisma.$calendarPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Calendars that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {calendarFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Calendars
     * const calendars = await prisma.calendar.findMany()
     * 
     * // Get first 10 Calendars
     * const calendars = await prisma.calendar.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const calendarWithIdOnly = await prisma.calendar.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends calendarFindManyArgs>(args?: SelectSubset<T, calendarFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$calendarPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Calendar.
     * @param {calendarCreateArgs} args - Arguments to create a Calendar.
     * @example
     * // Create one Calendar
     * const Calendar = await prisma.calendar.create({
     *   data: {
     *     // ... data to create a Calendar
     *   }
     * })
     * 
     */
    create<T extends calendarCreateArgs>(args: SelectSubset<T, calendarCreateArgs<ExtArgs>>): Prisma__calendarClient<$Result.GetResult<Prisma.$calendarPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Calendars.
     * @param {calendarCreateManyArgs} args - Arguments to create many Calendars.
     * @example
     * // Create many Calendars
     * const calendar = await prisma.calendar.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends calendarCreateManyArgs>(args?: SelectSubset<T, calendarCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Calendars and returns the data saved in the database.
     * @param {calendarCreateManyAndReturnArgs} args - Arguments to create many Calendars.
     * @example
     * // Create many Calendars
     * const calendar = await prisma.calendar.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Calendars and only return the `id`
     * const calendarWithIdOnly = await prisma.calendar.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends calendarCreateManyAndReturnArgs>(args?: SelectSubset<T, calendarCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$calendarPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Calendar.
     * @param {calendarDeleteArgs} args - Arguments to delete one Calendar.
     * @example
     * // Delete one Calendar
     * const Calendar = await prisma.calendar.delete({
     *   where: {
     *     // ... filter to delete one Calendar
     *   }
     * })
     * 
     */
    delete<T extends calendarDeleteArgs>(args: SelectSubset<T, calendarDeleteArgs<ExtArgs>>): Prisma__calendarClient<$Result.GetResult<Prisma.$calendarPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Calendar.
     * @param {calendarUpdateArgs} args - Arguments to update one Calendar.
     * @example
     * // Update one Calendar
     * const calendar = await prisma.calendar.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends calendarUpdateArgs>(args: SelectSubset<T, calendarUpdateArgs<ExtArgs>>): Prisma__calendarClient<$Result.GetResult<Prisma.$calendarPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Calendars.
     * @param {calendarDeleteManyArgs} args - Arguments to filter Calendars to delete.
     * @example
     * // Delete a few Calendars
     * const { count } = await prisma.calendar.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends calendarDeleteManyArgs>(args?: SelectSubset<T, calendarDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Calendars.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {calendarUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Calendars
     * const calendar = await prisma.calendar.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends calendarUpdateManyArgs>(args: SelectSubset<T, calendarUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Calendars and returns the data updated in the database.
     * @param {calendarUpdateManyAndReturnArgs} args - Arguments to update many Calendars.
     * @example
     * // Update many Calendars
     * const calendar = await prisma.calendar.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Calendars and only return the `id`
     * const calendarWithIdOnly = await prisma.calendar.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends calendarUpdateManyAndReturnArgs>(args: SelectSubset<T, calendarUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$calendarPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Calendar.
     * @param {calendarUpsertArgs} args - Arguments to update or create a Calendar.
     * @example
     * // Update or create a Calendar
     * const calendar = await prisma.calendar.upsert({
     *   create: {
     *     // ... data to create a Calendar
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Calendar we want to update
     *   }
     * })
     */
    upsert<T extends calendarUpsertArgs>(args: SelectSubset<T, calendarUpsertArgs<ExtArgs>>): Prisma__calendarClient<$Result.GetResult<Prisma.$calendarPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Calendars.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {calendarCountArgs} args - Arguments to filter Calendars to count.
     * @example
     * // Count the number of Calendars
     * const count = await prisma.calendar.count({
     *   where: {
     *     // ... the filter for the Calendars we want to count
     *   }
     * })
    **/
    count<T extends calendarCountArgs>(
      args?: Subset<T, calendarCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CalendarCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Calendar.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalendarAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CalendarAggregateArgs>(args: Subset<T, CalendarAggregateArgs>): Prisma.PrismaPromise<GetCalendarAggregateType<T>>

    /**
     * Group by Calendar.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {calendarGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends calendarGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: calendarGroupByArgs['orderBy'] }
        : { orderBy?: calendarGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, calendarGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCalendarGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the calendar model
   */
  readonly fields: calendarFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for calendar.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__calendarClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    upcoming_events<T extends calendar$upcoming_eventsArgs<ExtArgs> = {}>(args?: Subset<T, calendar$upcoming_eventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$upcoming_eventsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the calendar model
   */
  interface calendarFieldRefs {
    readonly id: FieldRef<"calendar", 'Int'>
    readonly month: FieldRef<"calendar", 'String'>
    readonly calendar: FieldRef<"calendar", 'String'>
    readonly year: FieldRef<"calendar", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * calendar findUnique
   */
  export type calendarFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the calendar
     */
    select?: calendarSelect<ExtArgs> | null
    /**
     * Omit specific fields from the calendar
     */
    omit?: calendarOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: calendarInclude<ExtArgs> | null
    /**
     * Filter, which calendar to fetch.
     */
    where: calendarWhereUniqueInput
  }

  /**
   * calendar findUniqueOrThrow
   */
  export type calendarFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the calendar
     */
    select?: calendarSelect<ExtArgs> | null
    /**
     * Omit specific fields from the calendar
     */
    omit?: calendarOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: calendarInclude<ExtArgs> | null
    /**
     * Filter, which calendar to fetch.
     */
    where: calendarWhereUniqueInput
  }

  /**
   * calendar findFirst
   */
  export type calendarFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the calendar
     */
    select?: calendarSelect<ExtArgs> | null
    /**
     * Omit specific fields from the calendar
     */
    omit?: calendarOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: calendarInclude<ExtArgs> | null
    /**
     * Filter, which calendar to fetch.
     */
    where?: calendarWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of calendars to fetch.
     */
    orderBy?: calendarOrderByWithRelationInput | calendarOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for calendars.
     */
    cursor?: calendarWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` calendars from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` calendars.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of calendars.
     */
    distinct?: CalendarScalarFieldEnum | CalendarScalarFieldEnum[]
  }

  /**
   * calendar findFirstOrThrow
   */
  export type calendarFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the calendar
     */
    select?: calendarSelect<ExtArgs> | null
    /**
     * Omit specific fields from the calendar
     */
    omit?: calendarOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: calendarInclude<ExtArgs> | null
    /**
     * Filter, which calendar to fetch.
     */
    where?: calendarWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of calendars to fetch.
     */
    orderBy?: calendarOrderByWithRelationInput | calendarOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for calendars.
     */
    cursor?: calendarWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` calendars from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` calendars.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of calendars.
     */
    distinct?: CalendarScalarFieldEnum | CalendarScalarFieldEnum[]
  }

  /**
   * calendar findMany
   */
  export type calendarFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the calendar
     */
    select?: calendarSelect<ExtArgs> | null
    /**
     * Omit specific fields from the calendar
     */
    omit?: calendarOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: calendarInclude<ExtArgs> | null
    /**
     * Filter, which calendars to fetch.
     */
    where?: calendarWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of calendars to fetch.
     */
    orderBy?: calendarOrderByWithRelationInput | calendarOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing calendars.
     */
    cursor?: calendarWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` calendars from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` calendars.
     */
    skip?: number
    distinct?: CalendarScalarFieldEnum | CalendarScalarFieldEnum[]
  }

  /**
   * calendar create
   */
  export type calendarCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the calendar
     */
    select?: calendarSelect<ExtArgs> | null
    /**
     * Omit specific fields from the calendar
     */
    omit?: calendarOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: calendarInclude<ExtArgs> | null
    /**
     * The data needed to create a calendar.
     */
    data: XOR<calendarCreateInput, calendarUncheckedCreateInput>
  }

  /**
   * calendar createMany
   */
  export type calendarCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many calendars.
     */
    data: calendarCreateManyInput | calendarCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * calendar createManyAndReturn
   */
  export type calendarCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the calendar
     */
    select?: calendarSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the calendar
     */
    omit?: calendarOmit<ExtArgs> | null
    /**
     * The data used to create many calendars.
     */
    data: calendarCreateManyInput | calendarCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * calendar update
   */
  export type calendarUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the calendar
     */
    select?: calendarSelect<ExtArgs> | null
    /**
     * Omit specific fields from the calendar
     */
    omit?: calendarOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: calendarInclude<ExtArgs> | null
    /**
     * The data needed to update a calendar.
     */
    data: XOR<calendarUpdateInput, calendarUncheckedUpdateInput>
    /**
     * Choose, which calendar to update.
     */
    where: calendarWhereUniqueInput
  }

  /**
   * calendar updateMany
   */
  export type calendarUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update calendars.
     */
    data: XOR<calendarUpdateManyMutationInput, calendarUncheckedUpdateManyInput>
    /**
     * Filter which calendars to update
     */
    where?: calendarWhereInput
    /**
     * Limit how many calendars to update.
     */
    limit?: number
  }

  /**
   * calendar updateManyAndReturn
   */
  export type calendarUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the calendar
     */
    select?: calendarSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the calendar
     */
    omit?: calendarOmit<ExtArgs> | null
    /**
     * The data used to update calendars.
     */
    data: XOR<calendarUpdateManyMutationInput, calendarUncheckedUpdateManyInput>
    /**
     * Filter which calendars to update
     */
    where?: calendarWhereInput
    /**
     * Limit how many calendars to update.
     */
    limit?: number
  }

  /**
   * calendar upsert
   */
  export type calendarUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the calendar
     */
    select?: calendarSelect<ExtArgs> | null
    /**
     * Omit specific fields from the calendar
     */
    omit?: calendarOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: calendarInclude<ExtArgs> | null
    /**
     * The filter to search for the calendar to update in case it exists.
     */
    where: calendarWhereUniqueInput
    /**
     * In case the calendar found by the `where` argument doesn't exist, create a new calendar with this data.
     */
    create: XOR<calendarCreateInput, calendarUncheckedCreateInput>
    /**
     * In case the calendar was found with the provided `where` argument, update it with this data.
     */
    update: XOR<calendarUpdateInput, calendarUncheckedUpdateInput>
  }

  /**
   * calendar delete
   */
  export type calendarDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the calendar
     */
    select?: calendarSelect<ExtArgs> | null
    /**
     * Omit specific fields from the calendar
     */
    omit?: calendarOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: calendarInclude<ExtArgs> | null
    /**
     * Filter which calendar to delete.
     */
    where: calendarWhereUniqueInput
  }

  /**
   * calendar deleteMany
   */
  export type calendarDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which calendars to delete
     */
    where?: calendarWhereInput
    /**
     * Limit how many calendars to delete.
     */
    limit?: number
  }

  /**
   * calendar.upcoming_events
   */
  export type calendar$upcoming_eventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the upcoming_events
     */
    select?: upcoming_eventsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the upcoming_events
     */
    omit?: upcoming_eventsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: upcoming_eventsInclude<ExtArgs> | null
    where?: upcoming_eventsWhereInput
    orderBy?: upcoming_eventsOrderByWithRelationInput | upcoming_eventsOrderByWithRelationInput[]
    cursor?: upcoming_eventsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Upcoming_eventsScalarFieldEnum | Upcoming_eventsScalarFieldEnum[]
  }

  /**
   * calendar without action
   */
  export type calendarDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the calendar
     */
    select?: calendarSelect<ExtArgs> | null
    /**
     * Omit specific fields from the calendar
     */
    omit?: calendarOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: calendarInclude<ExtArgs> | null
  }


  /**
   * Model class_representatives
   */

  export type AggregateClass_representatives = {
    _count: Class_representativesCountAggregateOutputType | null
    _avg: Class_representativesAvgAggregateOutputType | null
    _sum: Class_representativesSumAggregateOutputType | null
    _min: Class_representativesMinAggregateOutputType | null
    _max: Class_representativesMaxAggregateOutputType | null
  }

  export type Class_representativesAvgAggregateOutputType = {
    id: number | null
    student_id: number | null
  }

  export type Class_representativesSumAggregateOutputType = {
    id: number | null
    student_id: number | null
  }

  export type Class_representativesMinAggregateOutputType = {
    id: number | null
    student_id: number | null
    class: string | null
    section: string | null
  }

  export type Class_representativesMaxAggregateOutputType = {
    id: number | null
    student_id: number | null
    class: string | null
    section: string | null
  }

  export type Class_representativesCountAggregateOutputType = {
    id: number
    student_id: number
    class: number
    section: number
    _all: number
  }


  export type Class_representativesAvgAggregateInputType = {
    id?: true
    student_id?: true
  }

  export type Class_representativesSumAggregateInputType = {
    id?: true
    student_id?: true
  }

  export type Class_representativesMinAggregateInputType = {
    id?: true
    student_id?: true
    class?: true
    section?: true
  }

  export type Class_representativesMaxAggregateInputType = {
    id?: true
    student_id?: true
    class?: true
    section?: true
  }

  export type Class_representativesCountAggregateInputType = {
    id?: true
    student_id?: true
    class?: true
    section?: true
    _all?: true
  }

  export type Class_representativesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which class_representatives to aggregate.
     */
    where?: class_representativesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of class_representatives to fetch.
     */
    orderBy?: class_representativesOrderByWithRelationInput | class_representativesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: class_representativesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` class_representatives from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` class_representatives.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned class_representatives
    **/
    _count?: true | Class_representativesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Class_representativesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Class_representativesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Class_representativesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Class_representativesMaxAggregateInputType
  }

  export type GetClass_representativesAggregateType<T extends Class_representativesAggregateArgs> = {
        [P in keyof T & keyof AggregateClass_representatives]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClass_representatives[P]>
      : GetScalarType<T[P], AggregateClass_representatives[P]>
  }




  export type class_representativesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: class_representativesWhereInput
    orderBy?: class_representativesOrderByWithAggregationInput | class_representativesOrderByWithAggregationInput[]
    by: Class_representativesScalarFieldEnum[] | Class_representativesScalarFieldEnum
    having?: class_representativesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Class_representativesCountAggregateInputType | true
    _avg?: Class_representativesAvgAggregateInputType
    _sum?: Class_representativesSumAggregateInputType
    _min?: Class_representativesMinAggregateInputType
    _max?: Class_representativesMaxAggregateInputType
  }

  export type Class_representativesGroupByOutputType = {
    id: number
    student_id: number | null
    class: string
    section: string
    _count: Class_representativesCountAggregateOutputType | null
    _avg: Class_representativesAvgAggregateOutputType | null
    _sum: Class_representativesSumAggregateOutputType | null
    _min: Class_representativesMinAggregateOutputType | null
    _max: Class_representativesMaxAggregateOutputType | null
  }

  type GetClass_representativesGroupByPayload<T extends class_representativesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Class_representativesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Class_representativesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Class_representativesGroupByOutputType[P]>
            : GetScalarType<T[P], Class_representativesGroupByOutputType[P]>
        }
      >
    >


  export type class_representativesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    student_id?: boolean
    class?: boolean
    section?: boolean
    students?: boolean | class_representatives$studentsArgs<ExtArgs>
  }, ExtArgs["result"]["class_representatives"]>

  export type class_representativesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    student_id?: boolean
    class?: boolean
    section?: boolean
    students?: boolean | class_representatives$studentsArgs<ExtArgs>
  }, ExtArgs["result"]["class_representatives"]>

  export type class_representativesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    student_id?: boolean
    class?: boolean
    section?: boolean
    students?: boolean | class_representatives$studentsArgs<ExtArgs>
  }, ExtArgs["result"]["class_representatives"]>

  export type class_representativesSelectScalar = {
    id?: boolean
    student_id?: boolean
    class?: boolean
    section?: boolean
  }

  export type class_representativesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "student_id" | "class" | "section", ExtArgs["result"]["class_representatives"]>
  export type class_representativesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    students?: boolean | class_representatives$studentsArgs<ExtArgs>
  }
  export type class_representativesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    students?: boolean | class_representatives$studentsArgs<ExtArgs>
  }
  export type class_representativesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    students?: boolean | class_representatives$studentsArgs<ExtArgs>
  }

  export type $class_representativesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "class_representatives"
    objects: {
      students: Prisma.$studentsPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      student_id: number | null
      class: string
      section: string
    }, ExtArgs["result"]["class_representatives"]>
    composites: {}
  }

  type class_representativesGetPayload<S extends boolean | null | undefined | class_representativesDefaultArgs> = $Result.GetResult<Prisma.$class_representativesPayload, S>

  type class_representativesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<class_representativesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Class_representativesCountAggregateInputType | true
    }

  export interface class_representativesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['class_representatives'], meta: { name: 'class_representatives' } }
    /**
     * Find zero or one Class_representatives that matches the filter.
     * @param {class_representativesFindUniqueArgs} args - Arguments to find a Class_representatives
     * @example
     * // Get one Class_representatives
     * const class_representatives = await prisma.class_representatives.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends class_representativesFindUniqueArgs>(args: SelectSubset<T, class_representativesFindUniqueArgs<ExtArgs>>): Prisma__class_representativesClient<$Result.GetResult<Prisma.$class_representativesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Class_representatives that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {class_representativesFindUniqueOrThrowArgs} args - Arguments to find a Class_representatives
     * @example
     * // Get one Class_representatives
     * const class_representatives = await prisma.class_representatives.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends class_representativesFindUniqueOrThrowArgs>(args: SelectSubset<T, class_representativesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__class_representativesClient<$Result.GetResult<Prisma.$class_representativesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Class_representatives that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {class_representativesFindFirstArgs} args - Arguments to find a Class_representatives
     * @example
     * // Get one Class_representatives
     * const class_representatives = await prisma.class_representatives.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends class_representativesFindFirstArgs>(args?: SelectSubset<T, class_representativesFindFirstArgs<ExtArgs>>): Prisma__class_representativesClient<$Result.GetResult<Prisma.$class_representativesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Class_representatives that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {class_representativesFindFirstOrThrowArgs} args - Arguments to find a Class_representatives
     * @example
     * // Get one Class_representatives
     * const class_representatives = await prisma.class_representatives.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends class_representativesFindFirstOrThrowArgs>(args?: SelectSubset<T, class_representativesFindFirstOrThrowArgs<ExtArgs>>): Prisma__class_representativesClient<$Result.GetResult<Prisma.$class_representativesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Class_representatives that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {class_representativesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Class_representatives
     * const class_representatives = await prisma.class_representatives.findMany()
     * 
     * // Get first 10 Class_representatives
     * const class_representatives = await prisma.class_representatives.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const class_representativesWithIdOnly = await prisma.class_representatives.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends class_representativesFindManyArgs>(args?: SelectSubset<T, class_representativesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$class_representativesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Class_representatives.
     * @param {class_representativesCreateArgs} args - Arguments to create a Class_representatives.
     * @example
     * // Create one Class_representatives
     * const Class_representatives = await prisma.class_representatives.create({
     *   data: {
     *     // ... data to create a Class_representatives
     *   }
     * })
     * 
     */
    create<T extends class_representativesCreateArgs>(args: SelectSubset<T, class_representativesCreateArgs<ExtArgs>>): Prisma__class_representativesClient<$Result.GetResult<Prisma.$class_representativesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Class_representatives.
     * @param {class_representativesCreateManyArgs} args - Arguments to create many Class_representatives.
     * @example
     * // Create many Class_representatives
     * const class_representatives = await prisma.class_representatives.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends class_representativesCreateManyArgs>(args?: SelectSubset<T, class_representativesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Class_representatives and returns the data saved in the database.
     * @param {class_representativesCreateManyAndReturnArgs} args - Arguments to create many Class_representatives.
     * @example
     * // Create many Class_representatives
     * const class_representatives = await prisma.class_representatives.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Class_representatives and only return the `id`
     * const class_representativesWithIdOnly = await prisma.class_representatives.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends class_representativesCreateManyAndReturnArgs>(args?: SelectSubset<T, class_representativesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$class_representativesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Class_representatives.
     * @param {class_representativesDeleteArgs} args - Arguments to delete one Class_representatives.
     * @example
     * // Delete one Class_representatives
     * const Class_representatives = await prisma.class_representatives.delete({
     *   where: {
     *     // ... filter to delete one Class_representatives
     *   }
     * })
     * 
     */
    delete<T extends class_representativesDeleteArgs>(args: SelectSubset<T, class_representativesDeleteArgs<ExtArgs>>): Prisma__class_representativesClient<$Result.GetResult<Prisma.$class_representativesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Class_representatives.
     * @param {class_representativesUpdateArgs} args - Arguments to update one Class_representatives.
     * @example
     * // Update one Class_representatives
     * const class_representatives = await prisma.class_representatives.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends class_representativesUpdateArgs>(args: SelectSubset<T, class_representativesUpdateArgs<ExtArgs>>): Prisma__class_representativesClient<$Result.GetResult<Prisma.$class_representativesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Class_representatives.
     * @param {class_representativesDeleteManyArgs} args - Arguments to filter Class_representatives to delete.
     * @example
     * // Delete a few Class_representatives
     * const { count } = await prisma.class_representatives.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends class_representativesDeleteManyArgs>(args?: SelectSubset<T, class_representativesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Class_representatives.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {class_representativesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Class_representatives
     * const class_representatives = await prisma.class_representatives.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends class_representativesUpdateManyArgs>(args: SelectSubset<T, class_representativesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Class_representatives and returns the data updated in the database.
     * @param {class_representativesUpdateManyAndReturnArgs} args - Arguments to update many Class_representatives.
     * @example
     * // Update many Class_representatives
     * const class_representatives = await prisma.class_representatives.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Class_representatives and only return the `id`
     * const class_representativesWithIdOnly = await prisma.class_representatives.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends class_representativesUpdateManyAndReturnArgs>(args: SelectSubset<T, class_representativesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$class_representativesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Class_representatives.
     * @param {class_representativesUpsertArgs} args - Arguments to update or create a Class_representatives.
     * @example
     * // Update or create a Class_representatives
     * const class_representatives = await prisma.class_representatives.upsert({
     *   create: {
     *     // ... data to create a Class_representatives
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Class_representatives we want to update
     *   }
     * })
     */
    upsert<T extends class_representativesUpsertArgs>(args: SelectSubset<T, class_representativesUpsertArgs<ExtArgs>>): Prisma__class_representativesClient<$Result.GetResult<Prisma.$class_representativesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Class_representatives.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {class_representativesCountArgs} args - Arguments to filter Class_representatives to count.
     * @example
     * // Count the number of Class_representatives
     * const count = await prisma.class_representatives.count({
     *   where: {
     *     // ... the filter for the Class_representatives we want to count
     *   }
     * })
    **/
    count<T extends class_representativesCountArgs>(
      args?: Subset<T, class_representativesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Class_representativesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Class_representatives.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Class_representativesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Class_representativesAggregateArgs>(args: Subset<T, Class_representativesAggregateArgs>): Prisma.PrismaPromise<GetClass_representativesAggregateType<T>>

    /**
     * Group by Class_representatives.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {class_representativesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends class_representativesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: class_representativesGroupByArgs['orderBy'] }
        : { orderBy?: class_representativesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, class_representativesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClass_representativesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the class_representatives model
   */
  readonly fields: class_representativesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for class_representatives.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__class_representativesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    students<T extends class_representatives$studentsArgs<ExtArgs> = {}>(args?: Subset<T, class_representatives$studentsArgs<ExtArgs>>): Prisma__studentsClient<$Result.GetResult<Prisma.$studentsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the class_representatives model
   */
  interface class_representativesFieldRefs {
    readonly id: FieldRef<"class_representatives", 'Int'>
    readonly student_id: FieldRef<"class_representatives", 'Int'>
    readonly class: FieldRef<"class_representatives", 'String'>
    readonly section: FieldRef<"class_representatives", 'String'>
  }
    

  // Custom InputTypes
  /**
   * class_representatives findUnique
   */
  export type class_representativesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the class_representatives
     */
    select?: class_representativesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the class_representatives
     */
    omit?: class_representativesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: class_representativesInclude<ExtArgs> | null
    /**
     * Filter, which class_representatives to fetch.
     */
    where: class_representativesWhereUniqueInput
  }

  /**
   * class_representatives findUniqueOrThrow
   */
  export type class_representativesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the class_representatives
     */
    select?: class_representativesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the class_representatives
     */
    omit?: class_representativesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: class_representativesInclude<ExtArgs> | null
    /**
     * Filter, which class_representatives to fetch.
     */
    where: class_representativesWhereUniqueInput
  }

  /**
   * class_representatives findFirst
   */
  export type class_representativesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the class_representatives
     */
    select?: class_representativesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the class_representatives
     */
    omit?: class_representativesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: class_representativesInclude<ExtArgs> | null
    /**
     * Filter, which class_representatives to fetch.
     */
    where?: class_representativesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of class_representatives to fetch.
     */
    orderBy?: class_representativesOrderByWithRelationInput | class_representativesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for class_representatives.
     */
    cursor?: class_representativesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` class_representatives from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` class_representatives.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of class_representatives.
     */
    distinct?: Class_representativesScalarFieldEnum | Class_representativesScalarFieldEnum[]
  }

  /**
   * class_representatives findFirstOrThrow
   */
  export type class_representativesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the class_representatives
     */
    select?: class_representativesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the class_representatives
     */
    omit?: class_representativesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: class_representativesInclude<ExtArgs> | null
    /**
     * Filter, which class_representatives to fetch.
     */
    where?: class_representativesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of class_representatives to fetch.
     */
    orderBy?: class_representativesOrderByWithRelationInput | class_representativesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for class_representatives.
     */
    cursor?: class_representativesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` class_representatives from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` class_representatives.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of class_representatives.
     */
    distinct?: Class_representativesScalarFieldEnum | Class_representativesScalarFieldEnum[]
  }

  /**
   * class_representatives findMany
   */
  export type class_representativesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the class_representatives
     */
    select?: class_representativesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the class_representatives
     */
    omit?: class_representativesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: class_representativesInclude<ExtArgs> | null
    /**
     * Filter, which class_representatives to fetch.
     */
    where?: class_representativesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of class_representatives to fetch.
     */
    orderBy?: class_representativesOrderByWithRelationInput | class_representativesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing class_representatives.
     */
    cursor?: class_representativesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` class_representatives from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` class_representatives.
     */
    skip?: number
    distinct?: Class_representativesScalarFieldEnum | Class_representativesScalarFieldEnum[]
  }

  /**
   * class_representatives create
   */
  export type class_representativesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the class_representatives
     */
    select?: class_representativesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the class_representatives
     */
    omit?: class_representativesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: class_representativesInclude<ExtArgs> | null
    /**
     * The data needed to create a class_representatives.
     */
    data: XOR<class_representativesCreateInput, class_representativesUncheckedCreateInput>
  }

  /**
   * class_representatives createMany
   */
  export type class_representativesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many class_representatives.
     */
    data: class_representativesCreateManyInput | class_representativesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * class_representatives createManyAndReturn
   */
  export type class_representativesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the class_representatives
     */
    select?: class_representativesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the class_representatives
     */
    omit?: class_representativesOmit<ExtArgs> | null
    /**
     * The data used to create many class_representatives.
     */
    data: class_representativesCreateManyInput | class_representativesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: class_representativesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * class_representatives update
   */
  export type class_representativesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the class_representatives
     */
    select?: class_representativesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the class_representatives
     */
    omit?: class_representativesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: class_representativesInclude<ExtArgs> | null
    /**
     * The data needed to update a class_representatives.
     */
    data: XOR<class_representativesUpdateInput, class_representativesUncheckedUpdateInput>
    /**
     * Choose, which class_representatives to update.
     */
    where: class_representativesWhereUniqueInput
  }

  /**
   * class_representatives updateMany
   */
  export type class_representativesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update class_representatives.
     */
    data: XOR<class_representativesUpdateManyMutationInput, class_representativesUncheckedUpdateManyInput>
    /**
     * Filter which class_representatives to update
     */
    where?: class_representativesWhereInput
    /**
     * Limit how many class_representatives to update.
     */
    limit?: number
  }

  /**
   * class_representatives updateManyAndReturn
   */
  export type class_representativesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the class_representatives
     */
    select?: class_representativesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the class_representatives
     */
    omit?: class_representativesOmit<ExtArgs> | null
    /**
     * The data used to update class_representatives.
     */
    data: XOR<class_representativesUpdateManyMutationInput, class_representativesUncheckedUpdateManyInput>
    /**
     * Filter which class_representatives to update
     */
    where?: class_representativesWhereInput
    /**
     * Limit how many class_representatives to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: class_representativesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * class_representatives upsert
   */
  export type class_representativesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the class_representatives
     */
    select?: class_representativesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the class_representatives
     */
    omit?: class_representativesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: class_representativesInclude<ExtArgs> | null
    /**
     * The filter to search for the class_representatives to update in case it exists.
     */
    where: class_representativesWhereUniqueInput
    /**
     * In case the class_representatives found by the `where` argument doesn't exist, create a new class_representatives with this data.
     */
    create: XOR<class_representativesCreateInput, class_representativesUncheckedCreateInput>
    /**
     * In case the class_representatives was found with the provided `where` argument, update it with this data.
     */
    update: XOR<class_representativesUpdateInput, class_representativesUncheckedUpdateInput>
  }

  /**
   * class_representatives delete
   */
  export type class_representativesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the class_representatives
     */
    select?: class_representativesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the class_representatives
     */
    omit?: class_representativesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: class_representativesInclude<ExtArgs> | null
    /**
     * Filter which class_representatives to delete.
     */
    where: class_representativesWhereUniqueInput
  }

  /**
   * class_representatives deleteMany
   */
  export type class_representativesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which class_representatives to delete
     */
    where?: class_representativesWhereInput
    /**
     * Limit how many class_representatives to delete.
     */
    limit?: number
  }

  /**
   * class_representatives.students
   */
  export type class_representatives$studentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the students
     */
    select?: studentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the students
     */
    omit?: studentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: studentsInclude<ExtArgs> | null
    where?: studentsWhereInput
  }

  /**
   * class_representatives without action
   */
  export type class_representativesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the class_representatives
     */
    select?: class_representativesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the class_representatives
     */
    omit?: class_representativesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: class_representativesInclude<ExtArgs> | null
  }


  /**
   * Model class_routine
   */

  export type AggregateClass_routine = {
    _count: Class_routineCountAggregateOutputType | null
    _avg: Class_routineAvgAggregateOutputType | null
    _sum: Class_routineSumAggregateOutputType | null
    _min: Class_routineMinAggregateOutputType | null
    _max: Class_routineMaxAggregateOutputType | null
  }

  export type Class_routineAvgAggregateOutputType = {
    id: number | null
    period: number | null
    teacher_id: number | null
  }

  export type Class_routineSumAggregateOutputType = {
    id: number | null
    period: number | null
    teacher_id: number | null
  }

  export type Class_routineMinAggregateOutputType = {
    id: number | null
    class: string | null
    section: string | null
    day: string | null
    period: number | null
    subject: string | null
    teacher_id: number | null
  }

  export type Class_routineMaxAggregateOutputType = {
    id: number | null
    class: string | null
    section: string | null
    day: string | null
    period: number | null
    subject: string | null
    teacher_id: number | null
  }

  export type Class_routineCountAggregateOutputType = {
    id: number
    class: number
    section: number
    day: number
    period: number
    subject: number
    teacher_id: number
    _all: number
  }


  export type Class_routineAvgAggregateInputType = {
    id?: true
    period?: true
    teacher_id?: true
  }

  export type Class_routineSumAggregateInputType = {
    id?: true
    period?: true
    teacher_id?: true
  }

  export type Class_routineMinAggregateInputType = {
    id?: true
    class?: true
    section?: true
    day?: true
    period?: true
    subject?: true
    teacher_id?: true
  }

  export type Class_routineMaxAggregateInputType = {
    id?: true
    class?: true
    section?: true
    day?: true
    period?: true
    subject?: true
    teacher_id?: true
  }

  export type Class_routineCountAggregateInputType = {
    id?: true
    class?: true
    section?: true
    day?: true
    period?: true
    subject?: true
    teacher_id?: true
    _all?: true
  }

  export type Class_routineAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which class_routine to aggregate.
     */
    where?: class_routineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of class_routines to fetch.
     */
    orderBy?: class_routineOrderByWithRelationInput | class_routineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: class_routineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` class_routines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` class_routines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned class_routines
    **/
    _count?: true | Class_routineCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Class_routineAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Class_routineSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Class_routineMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Class_routineMaxAggregateInputType
  }

  export type GetClass_routineAggregateType<T extends Class_routineAggregateArgs> = {
        [P in keyof T & keyof AggregateClass_routine]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClass_routine[P]>
      : GetScalarType<T[P], AggregateClass_routine[P]>
  }




  export type class_routineGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: class_routineWhereInput
    orderBy?: class_routineOrderByWithAggregationInput | class_routineOrderByWithAggregationInput[]
    by: Class_routineScalarFieldEnum[] | Class_routineScalarFieldEnum
    having?: class_routineScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Class_routineCountAggregateInputType | true
    _avg?: Class_routineAvgAggregateInputType
    _sum?: Class_routineSumAggregateInputType
    _min?: Class_routineMinAggregateInputType
    _max?: Class_routineMaxAggregateInputType
  }

  export type Class_routineGroupByOutputType = {
    id: number
    class: string
    section: string
    day: string
    period: number
    subject: string
    teacher_id: number | null
    _count: Class_routineCountAggregateOutputType | null
    _avg: Class_routineAvgAggregateOutputType | null
    _sum: Class_routineSumAggregateOutputType | null
    _min: Class_routineMinAggregateOutputType | null
    _max: Class_routineMaxAggregateOutputType | null
  }

  type GetClass_routineGroupByPayload<T extends class_routineGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Class_routineGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Class_routineGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Class_routineGroupByOutputType[P]>
            : GetScalarType<T[P], Class_routineGroupByOutputType[P]>
        }
      >
    >


  export type class_routineSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    class?: boolean
    section?: boolean
    day?: boolean
    period?: boolean
    subject?: boolean
    teacher_id?: boolean
    teachers?: boolean | class_routine$teachersArgs<ExtArgs>
  }, ExtArgs["result"]["class_routine"]>

  export type class_routineSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    class?: boolean
    section?: boolean
    day?: boolean
    period?: boolean
    subject?: boolean
    teacher_id?: boolean
    teachers?: boolean | class_routine$teachersArgs<ExtArgs>
  }, ExtArgs["result"]["class_routine"]>

  export type class_routineSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    class?: boolean
    section?: boolean
    day?: boolean
    period?: boolean
    subject?: boolean
    teacher_id?: boolean
    teachers?: boolean | class_routine$teachersArgs<ExtArgs>
  }, ExtArgs["result"]["class_routine"]>

  export type class_routineSelectScalar = {
    id?: boolean
    class?: boolean
    section?: boolean
    day?: boolean
    period?: boolean
    subject?: boolean
    teacher_id?: boolean
  }

  export type class_routineOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "class" | "section" | "day" | "period" | "subject" | "teacher_id", ExtArgs["result"]["class_routine"]>
  export type class_routineInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    teachers?: boolean | class_routine$teachersArgs<ExtArgs>
  }
  export type class_routineIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    teachers?: boolean | class_routine$teachersArgs<ExtArgs>
  }
  export type class_routineIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    teachers?: boolean | class_routine$teachersArgs<ExtArgs>
  }

  export type $class_routinePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "class_routine"
    objects: {
      teachers: Prisma.$teachersPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      class: string
      section: string
      day: string
      period: number
      subject: string
      teacher_id: number | null
    }, ExtArgs["result"]["class_routine"]>
    composites: {}
  }

  type class_routineGetPayload<S extends boolean | null | undefined | class_routineDefaultArgs> = $Result.GetResult<Prisma.$class_routinePayload, S>

  type class_routineCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<class_routineFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Class_routineCountAggregateInputType | true
    }

  export interface class_routineDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['class_routine'], meta: { name: 'class_routine' } }
    /**
     * Find zero or one Class_routine that matches the filter.
     * @param {class_routineFindUniqueArgs} args - Arguments to find a Class_routine
     * @example
     * // Get one Class_routine
     * const class_routine = await prisma.class_routine.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends class_routineFindUniqueArgs>(args: SelectSubset<T, class_routineFindUniqueArgs<ExtArgs>>): Prisma__class_routineClient<$Result.GetResult<Prisma.$class_routinePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Class_routine that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {class_routineFindUniqueOrThrowArgs} args - Arguments to find a Class_routine
     * @example
     * // Get one Class_routine
     * const class_routine = await prisma.class_routine.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends class_routineFindUniqueOrThrowArgs>(args: SelectSubset<T, class_routineFindUniqueOrThrowArgs<ExtArgs>>): Prisma__class_routineClient<$Result.GetResult<Prisma.$class_routinePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Class_routine that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {class_routineFindFirstArgs} args - Arguments to find a Class_routine
     * @example
     * // Get one Class_routine
     * const class_routine = await prisma.class_routine.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends class_routineFindFirstArgs>(args?: SelectSubset<T, class_routineFindFirstArgs<ExtArgs>>): Prisma__class_routineClient<$Result.GetResult<Prisma.$class_routinePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Class_routine that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {class_routineFindFirstOrThrowArgs} args - Arguments to find a Class_routine
     * @example
     * // Get one Class_routine
     * const class_routine = await prisma.class_routine.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends class_routineFindFirstOrThrowArgs>(args?: SelectSubset<T, class_routineFindFirstOrThrowArgs<ExtArgs>>): Prisma__class_routineClient<$Result.GetResult<Prisma.$class_routinePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Class_routines that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {class_routineFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Class_routines
     * const class_routines = await prisma.class_routine.findMany()
     * 
     * // Get first 10 Class_routines
     * const class_routines = await prisma.class_routine.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const class_routineWithIdOnly = await prisma.class_routine.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends class_routineFindManyArgs>(args?: SelectSubset<T, class_routineFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$class_routinePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Class_routine.
     * @param {class_routineCreateArgs} args - Arguments to create a Class_routine.
     * @example
     * // Create one Class_routine
     * const Class_routine = await prisma.class_routine.create({
     *   data: {
     *     // ... data to create a Class_routine
     *   }
     * })
     * 
     */
    create<T extends class_routineCreateArgs>(args: SelectSubset<T, class_routineCreateArgs<ExtArgs>>): Prisma__class_routineClient<$Result.GetResult<Prisma.$class_routinePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Class_routines.
     * @param {class_routineCreateManyArgs} args - Arguments to create many Class_routines.
     * @example
     * // Create many Class_routines
     * const class_routine = await prisma.class_routine.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends class_routineCreateManyArgs>(args?: SelectSubset<T, class_routineCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Class_routines and returns the data saved in the database.
     * @param {class_routineCreateManyAndReturnArgs} args - Arguments to create many Class_routines.
     * @example
     * // Create many Class_routines
     * const class_routine = await prisma.class_routine.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Class_routines and only return the `id`
     * const class_routineWithIdOnly = await prisma.class_routine.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends class_routineCreateManyAndReturnArgs>(args?: SelectSubset<T, class_routineCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$class_routinePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Class_routine.
     * @param {class_routineDeleteArgs} args - Arguments to delete one Class_routine.
     * @example
     * // Delete one Class_routine
     * const Class_routine = await prisma.class_routine.delete({
     *   where: {
     *     // ... filter to delete one Class_routine
     *   }
     * })
     * 
     */
    delete<T extends class_routineDeleteArgs>(args: SelectSubset<T, class_routineDeleteArgs<ExtArgs>>): Prisma__class_routineClient<$Result.GetResult<Prisma.$class_routinePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Class_routine.
     * @param {class_routineUpdateArgs} args - Arguments to update one Class_routine.
     * @example
     * // Update one Class_routine
     * const class_routine = await prisma.class_routine.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends class_routineUpdateArgs>(args: SelectSubset<T, class_routineUpdateArgs<ExtArgs>>): Prisma__class_routineClient<$Result.GetResult<Prisma.$class_routinePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Class_routines.
     * @param {class_routineDeleteManyArgs} args - Arguments to filter Class_routines to delete.
     * @example
     * // Delete a few Class_routines
     * const { count } = await prisma.class_routine.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends class_routineDeleteManyArgs>(args?: SelectSubset<T, class_routineDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Class_routines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {class_routineUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Class_routines
     * const class_routine = await prisma.class_routine.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends class_routineUpdateManyArgs>(args: SelectSubset<T, class_routineUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Class_routines and returns the data updated in the database.
     * @param {class_routineUpdateManyAndReturnArgs} args - Arguments to update many Class_routines.
     * @example
     * // Update many Class_routines
     * const class_routine = await prisma.class_routine.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Class_routines and only return the `id`
     * const class_routineWithIdOnly = await prisma.class_routine.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends class_routineUpdateManyAndReturnArgs>(args: SelectSubset<T, class_routineUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$class_routinePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Class_routine.
     * @param {class_routineUpsertArgs} args - Arguments to update or create a Class_routine.
     * @example
     * // Update or create a Class_routine
     * const class_routine = await prisma.class_routine.upsert({
     *   create: {
     *     // ... data to create a Class_routine
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Class_routine we want to update
     *   }
     * })
     */
    upsert<T extends class_routineUpsertArgs>(args: SelectSubset<T, class_routineUpsertArgs<ExtArgs>>): Prisma__class_routineClient<$Result.GetResult<Prisma.$class_routinePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Class_routines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {class_routineCountArgs} args - Arguments to filter Class_routines to count.
     * @example
     * // Count the number of Class_routines
     * const count = await prisma.class_routine.count({
     *   where: {
     *     // ... the filter for the Class_routines we want to count
     *   }
     * })
    **/
    count<T extends class_routineCountArgs>(
      args?: Subset<T, class_routineCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Class_routineCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Class_routine.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Class_routineAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Class_routineAggregateArgs>(args: Subset<T, Class_routineAggregateArgs>): Prisma.PrismaPromise<GetClass_routineAggregateType<T>>

    /**
     * Group by Class_routine.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {class_routineGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends class_routineGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: class_routineGroupByArgs['orderBy'] }
        : { orderBy?: class_routineGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, class_routineGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClass_routineGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the class_routine model
   */
  readonly fields: class_routineFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for class_routine.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__class_routineClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    teachers<T extends class_routine$teachersArgs<ExtArgs> = {}>(args?: Subset<T, class_routine$teachersArgs<ExtArgs>>): Prisma__teachersClient<$Result.GetResult<Prisma.$teachersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the class_routine model
   */
  interface class_routineFieldRefs {
    readonly id: FieldRef<"class_routine", 'Int'>
    readonly class: FieldRef<"class_routine", 'String'>
    readonly section: FieldRef<"class_routine", 'String'>
    readonly day: FieldRef<"class_routine", 'String'>
    readonly period: FieldRef<"class_routine", 'Int'>
    readonly subject: FieldRef<"class_routine", 'String'>
    readonly teacher_id: FieldRef<"class_routine", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * class_routine findUnique
   */
  export type class_routineFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the class_routine
     */
    select?: class_routineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the class_routine
     */
    omit?: class_routineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: class_routineInclude<ExtArgs> | null
    /**
     * Filter, which class_routine to fetch.
     */
    where: class_routineWhereUniqueInput
  }

  /**
   * class_routine findUniqueOrThrow
   */
  export type class_routineFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the class_routine
     */
    select?: class_routineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the class_routine
     */
    omit?: class_routineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: class_routineInclude<ExtArgs> | null
    /**
     * Filter, which class_routine to fetch.
     */
    where: class_routineWhereUniqueInput
  }

  /**
   * class_routine findFirst
   */
  export type class_routineFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the class_routine
     */
    select?: class_routineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the class_routine
     */
    omit?: class_routineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: class_routineInclude<ExtArgs> | null
    /**
     * Filter, which class_routine to fetch.
     */
    where?: class_routineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of class_routines to fetch.
     */
    orderBy?: class_routineOrderByWithRelationInput | class_routineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for class_routines.
     */
    cursor?: class_routineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` class_routines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` class_routines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of class_routines.
     */
    distinct?: Class_routineScalarFieldEnum | Class_routineScalarFieldEnum[]
  }

  /**
   * class_routine findFirstOrThrow
   */
  export type class_routineFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the class_routine
     */
    select?: class_routineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the class_routine
     */
    omit?: class_routineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: class_routineInclude<ExtArgs> | null
    /**
     * Filter, which class_routine to fetch.
     */
    where?: class_routineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of class_routines to fetch.
     */
    orderBy?: class_routineOrderByWithRelationInput | class_routineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for class_routines.
     */
    cursor?: class_routineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` class_routines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` class_routines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of class_routines.
     */
    distinct?: Class_routineScalarFieldEnum | Class_routineScalarFieldEnum[]
  }

  /**
   * class_routine findMany
   */
  export type class_routineFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the class_routine
     */
    select?: class_routineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the class_routine
     */
    omit?: class_routineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: class_routineInclude<ExtArgs> | null
    /**
     * Filter, which class_routines to fetch.
     */
    where?: class_routineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of class_routines to fetch.
     */
    orderBy?: class_routineOrderByWithRelationInput | class_routineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing class_routines.
     */
    cursor?: class_routineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` class_routines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` class_routines.
     */
    skip?: number
    distinct?: Class_routineScalarFieldEnum | Class_routineScalarFieldEnum[]
  }

  /**
   * class_routine create
   */
  export type class_routineCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the class_routine
     */
    select?: class_routineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the class_routine
     */
    omit?: class_routineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: class_routineInclude<ExtArgs> | null
    /**
     * The data needed to create a class_routine.
     */
    data: XOR<class_routineCreateInput, class_routineUncheckedCreateInput>
  }

  /**
   * class_routine createMany
   */
  export type class_routineCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many class_routines.
     */
    data: class_routineCreateManyInput | class_routineCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * class_routine createManyAndReturn
   */
  export type class_routineCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the class_routine
     */
    select?: class_routineSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the class_routine
     */
    omit?: class_routineOmit<ExtArgs> | null
    /**
     * The data used to create many class_routines.
     */
    data: class_routineCreateManyInput | class_routineCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: class_routineIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * class_routine update
   */
  export type class_routineUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the class_routine
     */
    select?: class_routineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the class_routine
     */
    omit?: class_routineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: class_routineInclude<ExtArgs> | null
    /**
     * The data needed to update a class_routine.
     */
    data: XOR<class_routineUpdateInput, class_routineUncheckedUpdateInput>
    /**
     * Choose, which class_routine to update.
     */
    where: class_routineWhereUniqueInput
  }

  /**
   * class_routine updateMany
   */
  export type class_routineUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update class_routines.
     */
    data: XOR<class_routineUpdateManyMutationInput, class_routineUncheckedUpdateManyInput>
    /**
     * Filter which class_routines to update
     */
    where?: class_routineWhereInput
    /**
     * Limit how many class_routines to update.
     */
    limit?: number
  }

  /**
   * class_routine updateManyAndReturn
   */
  export type class_routineUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the class_routine
     */
    select?: class_routineSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the class_routine
     */
    omit?: class_routineOmit<ExtArgs> | null
    /**
     * The data used to update class_routines.
     */
    data: XOR<class_routineUpdateManyMutationInput, class_routineUncheckedUpdateManyInput>
    /**
     * Filter which class_routines to update
     */
    where?: class_routineWhereInput
    /**
     * Limit how many class_routines to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: class_routineIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * class_routine upsert
   */
  export type class_routineUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the class_routine
     */
    select?: class_routineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the class_routine
     */
    omit?: class_routineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: class_routineInclude<ExtArgs> | null
    /**
     * The filter to search for the class_routine to update in case it exists.
     */
    where: class_routineWhereUniqueInput
    /**
     * In case the class_routine found by the `where` argument doesn't exist, create a new class_routine with this data.
     */
    create: XOR<class_routineCreateInput, class_routineUncheckedCreateInput>
    /**
     * In case the class_routine was found with the provided `where` argument, update it with this data.
     */
    update: XOR<class_routineUpdateInput, class_routineUncheckedUpdateInput>
  }

  /**
   * class_routine delete
   */
  export type class_routineDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the class_routine
     */
    select?: class_routineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the class_routine
     */
    omit?: class_routineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: class_routineInclude<ExtArgs> | null
    /**
     * Filter which class_routine to delete.
     */
    where: class_routineWhereUniqueInput
  }

  /**
   * class_routine deleteMany
   */
  export type class_routineDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which class_routines to delete
     */
    where?: class_routineWhereInput
    /**
     * Limit how many class_routines to delete.
     */
    limit?: number
  }

  /**
   * class_routine.teachers
   */
  export type class_routine$teachersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the teachers
     */
    select?: teachersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the teachers
     */
    omit?: teachersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teachersInclude<ExtArgs> | null
    where?: teachersWhereInput
  }

  /**
   * class_routine without action
   */
  export type class_routineDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the class_routine
     */
    select?: class_routineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the class_routine
     */
    omit?: class_routineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: class_routineInclude<ExtArgs> | null
  }


  /**
   * Model class_teachers
   */

  export type AggregateClass_teachers = {
    _count: Class_teachersCountAggregateOutputType | null
    _avg: Class_teachersAvgAggregateOutputType | null
    _sum: Class_teachersSumAggregateOutputType | null
    _min: Class_teachersMinAggregateOutputType | null
    _max: Class_teachersMaxAggregateOutputType | null
  }

  export type Class_teachersAvgAggregateOutputType = {
    id: number | null
    teacher_id: number | null
    class_representative_student_id: number | null
    second_class_representative_student_id: number | null
  }

  export type Class_teachersSumAggregateOutputType = {
    id: number | null
    teacher_id: number | null
    class_representative_student_id: number | null
    second_class_representative_student_id: number | null
  }

  export type Class_teachersMinAggregateOutputType = {
    id: number | null
    class: string | null
    section: string | null
    teacher_id: number | null
    class_representative_student_id: number | null
    second_class_representative_student_id: number | null
  }

  export type Class_teachersMaxAggregateOutputType = {
    id: number | null
    class: string | null
    section: string | null
    teacher_id: number | null
    class_representative_student_id: number | null
    second_class_representative_student_id: number | null
  }

  export type Class_teachersCountAggregateOutputType = {
    id: number
    class: number
    section: number
    teacher_id: number
    class_representative_student_id: number
    second_class_representative_student_id: number
    _all: number
  }


  export type Class_teachersAvgAggregateInputType = {
    id?: true
    teacher_id?: true
    class_representative_student_id?: true
    second_class_representative_student_id?: true
  }

  export type Class_teachersSumAggregateInputType = {
    id?: true
    teacher_id?: true
    class_representative_student_id?: true
    second_class_representative_student_id?: true
  }

  export type Class_teachersMinAggregateInputType = {
    id?: true
    class?: true
    section?: true
    teacher_id?: true
    class_representative_student_id?: true
    second_class_representative_student_id?: true
  }

  export type Class_teachersMaxAggregateInputType = {
    id?: true
    class?: true
    section?: true
    teacher_id?: true
    class_representative_student_id?: true
    second_class_representative_student_id?: true
  }

  export type Class_teachersCountAggregateInputType = {
    id?: true
    class?: true
    section?: true
    teacher_id?: true
    class_representative_student_id?: true
    second_class_representative_student_id?: true
    _all?: true
  }

  export type Class_teachersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which class_teachers to aggregate.
     */
    where?: class_teachersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of class_teachers to fetch.
     */
    orderBy?: class_teachersOrderByWithRelationInput | class_teachersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: class_teachersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` class_teachers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` class_teachers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned class_teachers
    **/
    _count?: true | Class_teachersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Class_teachersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Class_teachersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Class_teachersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Class_teachersMaxAggregateInputType
  }

  export type GetClass_teachersAggregateType<T extends Class_teachersAggregateArgs> = {
        [P in keyof T & keyof AggregateClass_teachers]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClass_teachers[P]>
      : GetScalarType<T[P], AggregateClass_teachers[P]>
  }




  export type class_teachersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: class_teachersWhereInput
    orderBy?: class_teachersOrderByWithAggregationInput | class_teachersOrderByWithAggregationInput[]
    by: Class_teachersScalarFieldEnum[] | Class_teachersScalarFieldEnum
    having?: class_teachersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Class_teachersCountAggregateInputType | true
    _avg?: Class_teachersAvgAggregateInputType
    _sum?: Class_teachersSumAggregateInputType
    _min?: Class_teachersMinAggregateInputType
    _max?: Class_teachersMaxAggregateInputType
  }

  export type Class_teachersGroupByOutputType = {
    id: number
    class: string
    section: string
    teacher_id: number
    class_representative_student_id: number | null
    second_class_representative_student_id: number | null
    _count: Class_teachersCountAggregateOutputType | null
    _avg: Class_teachersAvgAggregateOutputType | null
    _sum: Class_teachersSumAggregateOutputType | null
    _min: Class_teachersMinAggregateOutputType | null
    _max: Class_teachersMaxAggregateOutputType | null
  }

  type GetClass_teachersGroupByPayload<T extends class_teachersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Class_teachersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Class_teachersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Class_teachersGroupByOutputType[P]>
            : GetScalarType<T[P], Class_teachersGroupByOutputType[P]>
        }
      >
    >


  export type class_teachersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    class?: boolean
    section?: boolean
    teacher_id?: boolean
    class_representative_student_id?: boolean
    second_class_representative_student_id?: boolean
    students?: boolean | class_teachers$studentsArgs<ExtArgs>
    teachers?: boolean | teachersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["class_teachers"]>

  export type class_teachersSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    class?: boolean
    section?: boolean
    teacher_id?: boolean
    class_representative_student_id?: boolean
    second_class_representative_student_id?: boolean
    students?: boolean | class_teachers$studentsArgs<ExtArgs>
    teachers?: boolean | teachersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["class_teachers"]>

  export type class_teachersSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    class?: boolean
    section?: boolean
    teacher_id?: boolean
    class_representative_student_id?: boolean
    second_class_representative_student_id?: boolean
    students?: boolean | class_teachers$studentsArgs<ExtArgs>
    teachers?: boolean | teachersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["class_teachers"]>

  export type class_teachersSelectScalar = {
    id?: boolean
    class?: boolean
    section?: boolean
    teacher_id?: boolean
    class_representative_student_id?: boolean
    second_class_representative_student_id?: boolean
  }

  export type class_teachersOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "class" | "section" | "teacher_id" | "class_representative_student_id" | "second_class_representative_student_id", ExtArgs["result"]["class_teachers"]>
  export type class_teachersInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    students?: boolean | class_teachers$studentsArgs<ExtArgs>
    teachers?: boolean | teachersDefaultArgs<ExtArgs>
  }
  export type class_teachersIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    students?: boolean | class_teachers$studentsArgs<ExtArgs>
    teachers?: boolean | teachersDefaultArgs<ExtArgs>
  }
  export type class_teachersIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    students?: boolean | class_teachers$studentsArgs<ExtArgs>
    teachers?: boolean | teachersDefaultArgs<ExtArgs>
  }

  export type $class_teachersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "class_teachers"
    objects: {
      students: Prisma.$studentsPayload<ExtArgs> | null
      teachers: Prisma.$teachersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      class: string
      section: string
      teacher_id: number
      class_representative_student_id: number | null
      second_class_representative_student_id: number | null
    }, ExtArgs["result"]["class_teachers"]>
    composites: {}
  }

  type class_teachersGetPayload<S extends boolean | null | undefined | class_teachersDefaultArgs> = $Result.GetResult<Prisma.$class_teachersPayload, S>

  type class_teachersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<class_teachersFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Class_teachersCountAggregateInputType | true
    }

  export interface class_teachersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['class_teachers'], meta: { name: 'class_teachers' } }
    /**
     * Find zero or one Class_teachers that matches the filter.
     * @param {class_teachersFindUniqueArgs} args - Arguments to find a Class_teachers
     * @example
     * // Get one Class_teachers
     * const class_teachers = await prisma.class_teachers.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends class_teachersFindUniqueArgs>(args: SelectSubset<T, class_teachersFindUniqueArgs<ExtArgs>>): Prisma__class_teachersClient<$Result.GetResult<Prisma.$class_teachersPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Class_teachers that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {class_teachersFindUniqueOrThrowArgs} args - Arguments to find a Class_teachers
     * @example
     * // Get one Class_teachers
     * const class_teachers = await prisma.class_teachers.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends class_teachersFindUniqueOrThrowArgs>(args: SelectSubset<T, class_teachersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__class_teachersClient<$Result.GetResult<Prisma.$class_teachersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Class_teachers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {class_teachersFindFirstArgs} args - Arguments to find a Class_teachers
     * @example
     * // Get one Class_teachers
     * const class_teachers = await prisma.class_teachers.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends class_teachersFindFirstArgs>(args?: SelectSubset<T, class_teachersFindFirstArgs<ExtArgs>>): Prisma__class_teachersClient<$Result.GetResult<Prisma.$class_teachersPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Class_teachers that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {class_teachersFindFirstOrThrowArgs} args - Arguments to find a Class_teachers
     * @example
     * // Get one Class_teachers
     * const class_teachers = await prisma.class_teachers.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends class_teachersFindFirstOrThrowArgs>(args?: SelectSubset<T, class_teachersFindFirstOrThrowArgs<ExtArgs>>): Prisma__class_teachersClient<$Result.GetResult<Prisma.$class_teachersPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Class_teachers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {class_teachersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Class_teachers
     * const class_teachers = await prisma.class_teachers.findMany()
     * 
     * // Get first 10 Class_teachers
     * const class_teachers = await prisma.class_teachers.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const class_teachersWithIdOnly = await prisma.class_teachers.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends class_teachersFindManyArgs>(args?: SelectSubset<T, class_teachersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$class_teachersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Class_teachers.
     * @param {class_teachersCreateArgs} args - Arguments to create a Class_teachers.
     * @example
     * // Create one Class_teachers
     * const Class_teachers = await prisma.class_teachers.create({
     *   data: {
     *     // ... data to create a Class_teachers
     *   }
     * })
     * 
     */
    create<T extends class_teachersCreateArgs>(args: SelectSubset<T, class_teachersCreateArgs<ExtArgs>>): Prisma__class_teachersClient<$Result.GetResult<Prisma.$class_teachersPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Class_teachers.
     * @param {class_teachersCreateManyArgs} args - Arguments to create many Class_teachers.
     * @example
     * // Create many Class_teachers
     * const class_teachers = await prisma.class_teachers.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends class_teachersCreateManyArgs>(args?: SelectSubset<T, class_teachersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Class_teachers and returns the data saved in the database.
     * @param {class_teachersCreateManyAndReturnArgs} args - Arguments to create many Class_teachers.
     * @example
     * // Create many Class_teachers
     * const class_teachers = await prisma.class_teachers.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Class_teachers and only return the `id`
     * const class_teachersWithIdOnly = await prisma.class_teachers.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends class_teachersCreateManyAndReturnArgs>(args?: SelectSubset<T, class_teachersCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$class_teachersPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Class_teachers.
     * @param {class_teachersDeleteArgs} args - Arguments to delete one Class_teachers.
     * @example
     * // Delete one Class_teachers
     * const Class_teachers = await prisma.class_teachers.delete({
     *   where: {
     *     // ... filter to delete one Class_teachers
     *   }
     * })
     * 
     */
    delete<T extends class_teachersDeleteArgs>(args: SelectSubset<T, class_teachersDeleteArgs<ExtArgs>>): Prisma__class_teachersClient<$Result.GetResult<Prisma.$class_teachersPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Class_teachers.
     * @param {class_teachersUpdateArgs} args - Arguments to update one Class_teachers.
     * @example
     * // Update one Class_teachers
     * const class_teachers = await prisma.class_teachers.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends class_teachersUpdateArgs>(args: SelectSubset<T, class_teachersUpdateArgs<ExtArgs>>): Prisma__class_teachersClient<$Result.GetResult<Prisma.$class_teachersPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Class_teachers.
     * @param {class_teachersDeleteManyArgs} args - Arguments to filter Class_teachers to delete.
     * @example
     * // Delete a few Class_teachers
     * const { count } = await prisma.class_teachers.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends class_teachersDeleteManyArgs>(args?: SelectSubset<T, class_teachersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Class_teachers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {class_teachersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Class_teachers
     * const class_teachers = await prisma.class_teachers.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends class_teachersUpdateManyArgs>(args: SelectSubset<T, class_teachersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Class_teachers and returns the data updated in the database.
     * @param {class_teachersUpdateManyAndReturnArgs} args - Arguments to update many Class_teachers.
     * @example
     * // Update many Class_teachers
     * const class_teachers = await prisma.class_teachers.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Class_teachers and only return the `id`
     * const class_teachersWithIdOnly = await prisma.class_teachers.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends class_teachersUpdateManyAndReturnArgs>(args: SelectSubset<T, class_teachersUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$class_teachersPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Class_teachers.
     * @param {class_teachersUpsertArgs} args - Arguments to update or create a Class_teachers.
     * @example
     * // Update or create a Class_teachers
     * const class_teachers = await prisma.class_teachers.upsert({
     *   create: {
     *     // ... data to create a Class_teachers
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Class_teachers we want to update
     *   }
     * })
     */
    upsert<T extends class_teachersUpsertArgs>(args: SelectSubset<T, class_teachersUpsertArgs<ExtArgs>>): Prisma__class_teachersClient<$Result.GetResult<Prisma.$class_teachersPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Class_teachers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {class_teachersCountArgs} args - Arguments to filter Class_teachers to count.
     * @example
     * // Count the number of Class_teachers
     * const count = await prisma.class_teachers.count({
     *   where: {
     *     // ... the filter for the Class_teachers we want to count
     *   }
     * })
    **/
    count<T extends class_teachersCountArgs>(
      args?: Subset<T, class_teachersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Class_teachersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Class_teachers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Class_teachersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Class_teachersAggregateArgs>(args: Subset<T, Class_teachersAggregateArgs>): Prisma.PrismaPromise<GetClass_teachersAggregateType<T>>

    /**
     * Group by Class_teachers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {class_teachersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends class_teachersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: class_teachersGroupByArgs['orderBy'] }
        : { orderBy?: class_teachersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, class_teachersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClass_teachersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the class_teachers model
   */
  readonly fields: class_teachersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for class_teachers.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__class_teachersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    students<T extends class_teachers$studentsArgs<ExtArgs> = {}>(args?: Subset<T, class_teachers$studentsArgs<ExtArgs>>): Prisma__studentsClient<$Result.GetResult<Prisma.$studentsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    teachers<T extends teachersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, teachersDefaultArgs<ExtArgs>>): Prisma__teachersClient<$Result.GetResult<Prisma.$teachersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the class_teachers model
   */
  interface class_teachersFieldRefs {
    readonly id: FieldRef<"class_teachers", 'Int'>
    readonly class: FieldRef<"class_teachers", 'String'>
    readonly section: FieldRef<"class_teachers", 'String'>
    readonly teacher_id: FieldRef<"class_teachers", 'Int'>
    readonly class_representative_student_id: FieldRef<"class_teachers", 'Int'>
    readonly second_class_representative_student_id: FieldRef<"class_teachers", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * class_teachers findUnique
   */
  export type class_teachersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the class_teachers
     */
    select?: class_teachersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the class_teachers
     */
    omit?: class_teachersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: class_teachersInclude<ExtArgs> | null
    /**
     * Filter, which class_teachers to fetch.
     */
    where: class_teachersWhereUniqueInput
  }

  /**
   * class_teachers findUniqueOrThrow
   */
  export type class_teachersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the class_teachers
     */
    select?: class_teachersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the class_teachers
     */
    omit?: class_teachersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: class_teachersInclude<ExtArgs> | null
    /**
     * Filter, which class_teachers to fetch.
     */
    where: class_teachersWhereUniqueInput
  }

  /**
   * class_teachers findFirst
   */
  export type class_teachersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the class_teachers
     */
    select?: class_teachersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the class_teachers
     */
    omit?: class_teachersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: class_teachersInclude<ExtArgs> | null
    /**
     * Filter, which class_teachers to fetch.
     */
    where?: class_teachersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of class_teachers to fetch.
     */
    orderBy?: class_teachersOrderByWithRelationInput | class_teachersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for class_teachers.
     */
    cursor?: class_teachersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` class_teachers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` class_teachers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of class_teachers.
     */
    distinct?: Class_teachersScalarFieldEnum | Class_teachersScalarFieldEnum[]
  }

  /**
   * class_teachers findFirstOrThrow
   */
  export type class_teachersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the class_teachers
     */
    select?: class_teachersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the class_teachers
     */
    omit?: class_teachersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: class_teachersInclude<ExtArgs> | null
    /**
     * Filter, which class_teachers to fetch.
     */
    where?: class_teachersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of class_teachers to fetch.
     */
    orderBy?: class_teachersOrderByWithRelationInput | class_teachersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for class_teachers.
     */
    cursor?: class_teachersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` class_teachers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` class_teachers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of class_teachers.
     */
    distinct?: Class_teachersScalarFieldEnum | Class_teachersScalarFieldEnum[]
  }

  /**
   * class_teachers findMany
   */
  export type class_teachersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the class_teachers
     */
    select?: class_teachersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the class_teachers
     */
    omit?: class_teachersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: class_teachersInclude<ExtArgs> | null
    /**
     * Filter, which class_teachers to fetch.
     */
    where?: class_teachersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of class_teachers to fetch.
     */
    orderBy?: class_teachersOrderByWithRelationInput | class_teachersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing class_teachers.
     */
    cursor?: class_teachersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` class_teachers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` class_teachers.
     */
    skip?: number
    distinct?: Class_teachersScalarFieldEnum | Class_teachersScalarFieldEnum[]
  }

  /**
   * class_teachers create
   */
  export type class_teachersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the class_teachers
     */
    select?: class_teachersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the class_teachers
     */
    omit?: class_teachersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: class_teachersInclude<ExtArgs> | null
    /**
     * The data needed to create a class_teachers.
     */
    data: XOR<class_teachersCreateInput, class_teachersUncheckedCreateInput>
  }

  /**
   * class_teachers createMany
   */
  export type class_teachersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many class_teachers.
     */
    data: class_teachersCreateManyInput | class_teachersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * class_teachers createManyAndReturn
   */
  export type class_teachersCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the class_teachers
     */
    select?: class_teachersSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the class_teachers
     */
    omit?: class_teachersOmit<ExtArgs> | null
    /**
     * The data used to create many class_teachers.
     */
    data: class_teachersCreateManyInput | class_teachersCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: class_teachersIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * class_teachers update
   */
  export type class_teachersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the class_teachers
     */
    select?: class_teachersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the class_teachers
     */
    omit?: class_teachersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: class_teachersInclude<ExtArgs> | null
    /**
     * The data needed to update a class_teachers.
     */
    data: XOR<class_teachersUpdateInput, class_teachersUncheckedUpdateInput>
    /**
     * Choose, which class_teachers to update.
     */
    where: class_teachersWhereUniqueInput
  }

  /**
   * class_teachers updateMany
   */
  export type class_teachersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update class_teachers.
     */
    data: XOR<class_teachersUpdateManyMutationInput, class_teachersUncheckedUpdateManyInput>
    /**
     * Filter which class_teachers to update
     */
    where?: class_teachersWhereInput
    /**
     * Limit how many class_teachers to update.
     */
    limit?: number
  }

  /**
   * class_teachers updateManyAndReturn
   */
  export type class_teachersUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the class_teachers
     */
    select?: class_teachersSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the class_teachers
     */
    omit?: class_teachersOmit<ExtArgs> | null
    /**
     * The data used to update class_teachers.
     */
    data: XOR<class_teachersUpdateManyMutationInput, class_teachersUncheckedUpdateManyInput>
    /**
     * Filter which class_teachers to update
     */
    where?: class_teachersWhereInput
    /**
     * Limit how many class_teachers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: class_teachersIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * class_teachers upsert
   */
  export type class_teachersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the class_teachers
     */
    select?: class_teachersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the class_teachers
     */
    omit?: class_teachersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: class_teachersInclude<ExtArgs> | null
    /**
     * The filter to search for the class_teachers to update in case it exists.
     */
    where: class_teachersWhereUniqueInput
    /**
     * In case the class_teachers found by the `where` argument doesn't exist, create a new class_teachers with this data.
     */
    create: XOR<class_teachersCreateInput, class_teachersUncheckedCreateInput>
    /**
     * In case the class_teachers was found with the provided `where` argument, update it with this data.
     */
    update: XOR<class_teachersUpdateInput, class_teachersUncheckedUpdateInput>
  }

  /**
   * class_teachers delete
   */
  export type class_teachersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the class_teachers
     */
    select?: class_teachersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the class_teachers
     */
    omit?: class_teachersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: class_teachersInclude<ExtArgs> | null
    /**
     * Filter which class_teachers to delete.
     */
    where: class_teachersWhereUniqueInput
  }

  /**
   * class_teachers deleteMany
   */
  export type class_teachersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which class_teachers to delete
     */
    where?: class_teachersWhereInput
    /**
     * Limit how many class_teachers to delete.
     */
    limit?: number
  }

  /**
   * class_teachers.students
   */
  export type class_teachers$studentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the students
     */
    select?: studentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the students
     */
    omit?: studentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: studentsInclude<ExtArgs> | null
    where?: studentsWhereInput
  }

  /**
   * class_teachers without action
   */
  export type class_teachersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the class_teachers
     */
    select?: class_teachersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the class_teachers
     */
    omit?: class_teachersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: class_teachersInclude<ExtArgs> | null
  }


  /**
   * Model exams
   */

  export type AggregateExams = {
    _count: ExamsCountAggregateOutputType | null
    _avg: ExamsAvgAggregateOutputType | null
    _sum: ExamsSumAggregateOutputType | null
    _min: ExamsMinAggregateOutputType | null
    _max: ExamsMaxAggregateOutputType | null
  }

  export type ExamsAvgAggregateOutputType = {
    id: number | null
    created_by: number | null
  }

  export type ExamsSumAggregateOutputType = {
    id: number | null
    created_by: number | null
  }

  export type ExamsMinAggregateOutputType = {
    id: number | null
    class: string | null
    section: string | null
    subject: string | null
    exam_date: Date | null
    exam_duration: string | null
    exam_type: string | null
    created_by: number | null
  }

  export type ExamsMaxAggregateOutputType = {
    id: number | null
    class: string | null
    section: string | null
    subject: string | null
    exam_date: Date | null
    exam_duration: string | null
    exam_type: string | null
    created_by: number | null
  }

  export type ExamsCountAggregateOutputType = {
    id: number
    class: number
    section: number
    subject: number
    exam_date: number
    exam_duration: number
    exam_type: number
    created_by: number
    _all: number
  }


  export type ExamsAvgAggregateInputType = {
    id?: true
    created_by?: true
  }

  export type ExamsSumAggregateInputType = {
    id?: true
    created_by?: true
  }

  export type ExamsMinAggregateInputType = {
    id?: true
    class?: true
    section?: true
    subject?: true
    exam_date?: true
    exam_duration?: true
    exam_type?: true
    created_by?: true
  }

  export type ExamsMaxAggregateInputType = {
    id?: true
    class?: true
    section?: true
    subject?: true
    exam_date?: true
    exam_duration?: true
    exam_type?: true
    created_by?: true
  }

  export type ExamsCountAggregateInputType = {
    id?: true
    class?: true
    section?: true
    subject?: true
    exam_date?: true
    exam_duration?: true
    exam_type?: true
    created_by?: true
    _all?: true
  }

  export type ExamsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which exams to aggregate.
     */
    where?: examsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of exams to fetch.
     */
    orderBy?: examsOrderByWithRelationInput | examsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: examsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` exams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` exams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned exams
    **/
    _count?: true | ExamsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ExamsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ExamsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ExamsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ExamsMaxAggregateInputType
  }

  export type GetExamsAggregateType<T extends ExamsAggregateArgs> = {
        [P in keyof T & keyof AggregateExams]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExams[P]>
      : GetScalarType<T[P], AggregateExams[P]>
  }




  export type examsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: examsWhereInput
    orderBy?: examsOrderByWithAggregationInput | examsOrderByWithAggregationInput[]
    by: ExamsScalarFieldEnum[] | ExamsScalarFieldEnum
    having?: examsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ExamsCountAggregateInputType | true
    _avg?: ExamsAvgAggregateInputType
    _sum?: ExamsSumAggregateInputType
    _min?: ExamsMinAggregateInputType
    _max?: ExamsMaxAggregateInputType
  }

  export type ExamsGroupByOutputType = {
    id: number
    class: string
    section: string
    subject: string
    exam_date: Date
    exam_duration: string | null
    exam_type: string | null
    created_by: number | null
    _count: ExamsCountAggregateOutputType | null
    _avg: ExamsAvgAggregateOutputType | null
    _sum: ExamsSumAggregateOutputType | null
    _min: ExamsMinAggregateOutputType | null
    _max: ExamsMaxAggregateOutputType | null
  }

  type GetExamsGroupByPayload<T extends examsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ExamsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ExamsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExamsGroupByOutputType[P]>
            : GetScalarType<T[P], ExamsGroupByOutputType[P]>
        }
      >
    >


  export type examsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    class?: boolean
    section?: boolean
    subject?: boolean
    exam_date?: boolean
    exam_duration?: boolean
    exam_type?: boolean
    created_by?: boolean
    teachers?: boolean | exams$teachersArgs<ExtArgs>
    performance?: boolean | exams$performanceArgs<ExtArgs>
    student_performance?: boolean | exams$student_performanceArgs<ExtArgs>
    _count?: boolean | ExamsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["exams"]>

  export type examsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    class?: boolean
    section?: boolean
    subject?: boolean
    exam_date?: boolean
    exam_duration?: boolean
    exam_type?: boolean
    created_by?: boolean
    teachers?: boolean | exams$teachersArgs<ExtArgs>
  }, ExtArgs["result"]["exams"]>

  export type examsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    class?: boolean
    section?: boolean
    subject?: boolean
    exam_date?: boolean
    exam_duration?: boolean
    exam_type?: boolean
    created_by?: boolean
    teachers?: boolean | exams$teachersArgs<ExtArgs>
  }, ExtArgs["result"]["exams"]>

  export type examsSelectScalar = {
    id?: boolean
    class?: boolean
    section?: boolean
    subject?: boolean
    exam_date?: boolean
    exam_duration?: boolean
    exam_type?: boolean
    created_by?: boolean
  }

  export type examsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "class" | "section" | "subject" | "exam_date" | "exam_duration" | "exam_type" | "created_by", ExtArgs["result"]["exams"]>
  export type examsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    teachers?: boolean | exams$teachersArgs<ExtArgs>
    performance?: boolean | exams$performanceArgs<ExtArgs>
    student_performance?: boolean | exams$student_performanceArgs<ExtArgs>
    _count?: boolean | ExamsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type examsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    teachers?: boolean | exams$teachersArgs<ExtArgs>
  }
  export type examsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    teachers?: boolean | exams$teachersArgs<ExtArgs>
  }

  export type $examsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "exams"
    objects: {
      teachers: Prisma.$teachersPayload<ExtArgs> | null
      performance: Prisma.$performancePayload<ExtArgs>[]
      student_performance: Prisma.$student_performancePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      class: string
      section: string
      subject: string
      exam_date: Date
      exam_duration: string | null
      exam_type: string | null
      created_by: number | null
    }, ExtArgs["result"]["exams"]>
    composites: {}
  }

  type examsGetPayload<S extends boolean | null | undefined | examsDefaultArgs> = $Result.GetResult<Prisma.$examsPayload, S>

  type examsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<examsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ExamsCountAggregateInputType | true
    }

  export interface examsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['exams'], meta: { name: 'exams' } }
    /**
     * Find zero or one Exams that matches the filter.
     * @param {examsFindUniqueArgs} args - Arguments to find a Exams
     * @example
     * // Get one Exams
     * const exams = await prisma.exams.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends examsFindUniqueArgs>(args: SelectSubset<T, examsFindUniqueArgs<ExtArgs>>): Prisma__examsClient<$Result.GetResult<Prisma.$examsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Exams that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {examsFindUniqueOrThrowArgs} args - Arguments to find a Exams
     * @example
     * // Get one Exams
     * const exams = await prisma.exams.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends examsFindUniqueOrThrowArgs>(args: SelectSubset<T, examsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__examsClient<$Result.GetResult<Prisma.$examsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Exams that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {examsFindFirstArgs} args - Arguments to find a Exams
     * @example
     * // Get one Exams
     * const exams = await prisma.exams.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends examsFindFirstArgs>(args?: SelectSubset<T, examsFindFirstArgs<ExtArgs>>): Prisma__examsClient<$Result.GetResult<Prisma.$examsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Exams that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {examsFindFirstOrThrowArgs} args - Arguments to find a Exams
     * @example
     * // Get one Exams
     * const exams = await prisma.exams.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends examsFindFirstOrThrowArgs>(args?: SelectSubset<T, examsFindFirstOrThrowArgs<ExtArgs>>): Prisma__examsClient<$Result.GetResult<Prisma.$examsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Exams that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {examsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Exams
     * const exams = await prisma.exams.findMany()
     * 
     * // Get first 10 Exams
     * const exams = await prisma.exams.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const examsWithIdOnly = await prisma.exams.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends examsFindManyArgs>(args?: SelectSubset<T, examsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$examsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Exams.
     * @param {examsCreateArgs} args - Arguments to create a Exams.
     * @example
     * // Create one Exams
     * const Exams = await prisma.exams.create({
     *   data: {
     *     // ... data to create a Exams
     *   }
     * })
     * 
     */
    create<T extends examsCreateArgs>(args: SelectSubset<T, examsCreateArgs<ExtArgs>>): Prisma__examsClient<$Result.GetResult<Prisma.$examsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Exams.
     * @param {examsCreateManyArgs} args - Arguments to create many Exams.
     * @example
     * // Create many Exams
     * const exams = await prisma.exams.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends examsCreateManyArgs>(args?: SelectSubset<T, examsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Exams and returns the data saved in the database.
     * @param {examsCreateManyAndReturnArgs} args - Arguments to create many Exams.
     * @example
     * // Create many Exams
     * const exams = await prisma.exams.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Exams and only return the `id`
     * const examsWithIdOnly = await prisma.exams.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends examsCreateManyAndReturnArgs>(args?: SelectSubset<T, examsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$examsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Exams.
     * @param {examsDeleteArgs} args - Arguments to delete one Exams.
     * @example
     * // Delete one Exams
     * const Exams = await prisma.exams.delete({
     *   where: {
     *     // ... filter to delete one Exams
     *   }
     * })
     * 
     */
    delete<T extends examsDeleteArgs>(args: SelectSubset<T, examsDeleteArgs<ExtArgs>>): Prisma__examsClient<$Result.GetResult<Prisma.$examsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Exams.
     * @param {examsUpdateArgs} args - Arguments to update one Exams.
     * @example
     * // Update one Exams
     * const exams = await prisma.exams.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends examsUpdateArgs>(args: SelectSubset<T, examsUpdateArgs<ExtArgs>>): Prisma__examsClient<$Result.GetResult<Prisma.$examsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Exams.
     * @param {examsDeleteManyArgs} args - Arguments to filter Exams to delete.
     * @example
     * // Delete a few Exams
     * const { count } = await prisma.exams.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends examsDeleteManyArgs>(args?: SelectSubset<T, examsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Exams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {examsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Exams
     * const exams = await prisma.exams.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends examsUpdateManyArgs>(args: SelectSubset<T, examsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Exams and returns the data updated in the database.
     * @param {examsUpdateManyAndReturnArgs} args - Arguments to update many Exams.
     * @example
     * // Update many Exams
     * const exams = await prisma.exams.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Exams and only return the `id`
     * const examsWithIdOnly = await prisma.exams.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends examsUpdateManyAndReturnArgs>(args: SelectSubset<T, examsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$examsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Exams.
     * @param {examsUpsertArgs} args - Arguments to update or create a Exams.
     * @example
     * // Update or create a Exams
     * const exams = await prisma.exams.upsert({
     *   create: {
     *     // ... data to create a Exams
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Exams we want to update
     *   }
     * })
     */
    upsert<T extends examsUpsertArgs>(args: SelectSubset<T, examsUpsertArgs<ExtArgs>>): Prisma__examsClient<$Result.GetResult<Prisma.$examsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Exams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {examsCountArgs} args - Arguments to filter Exams to count.
     * @example
     * // Count the number of Exams
     * const count = await prisma.exams.count({
     *   where: {
     *     // ... the filter for the Exams we want to count
     *   }
     * })
    **/
    count<T extends examsCountArgs>(
      args?: Subset<T, examsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExamsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Exams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ExamsAggregateArgs>(args: Subset<T, ExamsAggregateArgs>): Prisma.PrismaPromise<GetExamsAggregateType<T>>

    /**
     * Group by Exams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {examsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends examsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: examsGroupByArgs['orderBy'] }
        : { orderBy?: examsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, examsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExamsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the exams model
   */
  readonly fields: examsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for exams.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__examsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    teachers<T extends exams$teachersArgs<ExtArgs> = {}>(args?: Subset<T, exams$teachersArgs<ExtArgs>>): Prisma__teachersClient<$Result.GetResult<Prisma.$teachersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    performance<T extends exams$performanceArgs<ExtArgs> = {}>(args?: Subset<T, exams$performanceArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$performancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    student_performance<T extends exams$student_performanceArgs<ExtArgs> = {}>(args?: Subset<T, exams$student_performanceArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$student_performancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the exams model
   */
  interface examsFieldRefs {
    readonly id: FieldRef<"exams", 'Int'>
    readonly class: FieldRef<"exams", 'String'>
    readonly section: FieldRef<"exams", 'String'>
    readonly subject: FieldRef<"exams", 'String'>
    readonly exam_date: FieldRef<"exams", 'DateTime'>
    readonly exam_duration: FieldRef<"exams", 'String'>
    readonly exam_type: FieldRef<"exams", 'String'>
    readonly created_by: FieldRef<"exams", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * exams findUnique
   */
  export type examsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the exams
     */
    select?: examsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the exams
     */
    omit?: examsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: examsInclude<ExtArgs> | null
    /**
     * Filter, which exams to fetch.
     */
    where: examsWhereUniqueInput
  }

  /**
   * exams findUniqueOrThrow
   */
  export type examsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the exams
     */
    select?: examsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the exams
     */
    omit?: examsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: examsInclude<ExtArgs> | null
    /**
     * Filter, which exams to fetch.
     */
    where: examsWhereUniqueInput
  }

  /**
   * exams findFirst
   */
  export type examsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the exams
     */
    select?: examsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the exams
     */
    omit?: examsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: examsInclude<ExtArgs> | null
    /**
     * Filter, which exams to fetch.
     */
    where?: examsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of exams to fetch.
     */
    orderBy?: examsOrderByWithRelationInput | examsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for exams.
     */
    cursor?: examsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` exams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` exams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of exams.
     */
    distinct?: ExamsScalarFieldEnum | ExamsScalarFieldEnum[]
  }

  /**
   * exams findFirstOrThrow
   */
  export type examsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the exams
     */
    select?: examsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the exams
     */
    omit?: examsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: examsInclude<ExtArgs> | null
    /**
     * Filter, which exams to fetch.
     */
    where?: examsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of exams to fetch.
     */
    orderBy?: examsOrderByWithRelationInput | examsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for exams.
     */
    cursor?: examsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` exams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` exams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of exams.
     */
    distinct?: ExamsScalarFieldEnum | ExamsScalarFieldEnum[]
  }

  /**
   * exams findMany
   */
  export type examsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the exams
     */
    select?: examsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the exams
     */
    omit?: examsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: examsInclude<ExtArgs> | null
    /**
     * Filter, which exams to fetch.
     */
    where?: examsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of exams to fetch.
     */
    orderBy?: examsOrderByWithRelationInput | examsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing exams.
     */
    cursor?: examsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` exams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` exams.
     */
    skip?: number
    distinct?: ExamsScalarFieldEnum | ExamsScalarFieldEnum[]
  }

  /**
   * exams create
   */
  export type examsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the exams
     */
    select?: examsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the exams
     */
    omit?: examsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: examsInclude<ExtArgs> | null
    /**
     * The data needed to create a exams.
     */
    data: XOR<examsCreateInput, examsUncheckedCreateInput>
  }

  /**
   * exams createMany
   */
  export type examsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many exams.
     */
    data: examsCreateManyInput | examsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * exams createManyAndReturn
   */
  export type examsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the exams
     */
    select?: examsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the exams
     */
    omit?: examsOmit<ExtArgs> | null
    /**
     * The data used to create many exams.
     */
    data: examsCreateManyInput | examsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: examsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * exams update
   */
  export type examsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the exams
     */
    select?: examsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the exams
     */
    omit?: examsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: examsInclude<ExtArgs> | null
    /**
     * The data needed to update a exams.
     */
    data: XOR<examsUpdateInput, examsUncheckedUpdateInput>
    /**
     * Choose, which exams to update.
     */
    where: examsWhereUniqueInput
  }

  /**
   * exams updateMany
   */
  export type examsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update exams.
     */
    data: XOR<examsUpdateManyMutationInput, examsUncheckedUpdateManyInput>
    /**
     * Filter which exams to update
     */
    where?: examsWhereInput
    /**
     * Limit how many exams to update.
     */
    limit?: number
  }

  /**
   * exams updateManyAndReturn
   */
  export type examsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the exams
     */
    select?: examsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the exams
     */
    omit?: examsOmit<ExtArgs> | null
    /**
     * The data used to update exams.
     */
    data: XOR<examsUpdateManyMutationInput, examsUncheckedUpdateManyInput>
    /**
     * Filter which exams to update
     */
    where?: examsWhereInput
    /**
     * Limit how many exams to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: examsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * exams upsert
   */
  export type examsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the exams
     */
    select?: examsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the exams
     */
    omit?: examsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: examsInclude<ExtArgs> | null
    /**
     * The filter to search for the exams to update in case it exists.
     */
    where: examsWhereUniqueInput
    /**
     * In case the exams found by the `where` argument doesn't exist, create a new exams with this data.
     */
    create: XOR<examsCreateInput, examsUncheckedCreateInput>
    /**
     * In case the exams was found with the provided `where` argument, update it with this data.
     */
    update: XOR<examsUpdateInput, examsUncheckedUpdateInput>
  }

  /**
   * exams delete
   */
  export type examsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the exams
     */
    select?: examsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the exams
     */
    omit?: examsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: examsInclude<ExtArgs> | null
    /**
     * Filter which exams to delete.
     */
    where: examsWhereUniqueInput
  }

  /**
   * exams deleteMany
   */
  export type examsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which exams to delete
     */
    where?: examsWhereInput
    /**
     * Limit how many exams to delete.
     */
    limit?: number
  }

  /**
   * exams.teachers
   */
  export type exams$teachersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the teachers
     */
    select?: teachersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the teachers
     */
    omit?: teachersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teachersInclude<ExtArgs> | null
    where?: teachersWhereInput
  }

  /**
   * exams.performance
   */
  export type exams$performanceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the performance
     */
    select?: performanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the performance
     */
    omit?: performanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: performanceInclude<ExtArgs> | null
    where?: performanceWhereInput
    orderBy?: performanceOrderByWithRelationInput | performanceOrderByWithRelationInput[]
    cursor?: performanceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PerformanceScalarFieldEnum | PerformanceScalarFieldEnum[]
  }

  /**
   * exams.student_performance
   */
  export type exams$student_performanceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student_performance
     */
    select?: student_performanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the student_performance
     */
    omit?: student_performanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: student_performanceInclude<ExtArgs> | null
    where?: student_performanceWhereInput
    orderBy?: student_performanceOrderByWithRelationInput | student_performanceOrderByWithRelationInput[]
    cursor?: student_performanceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Student_performanceScalarFieldEnum | Student_performanceScalarFieldEnum[]
  }

  /**
   * exams without action
   */
  export type examsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the exams
     */
    select?: examsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the exams
     */
    omit?: examsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: examsInclude<ExtArgs> | null
  }


  /**
   * Model financecheckbook
   */

  export type AggregateFinancecheckbook = {
    _count: FinancecheckbookCountAggregateOutputType | null
    _avg: FinancecheckbookAvgAggregateOutputType | null
    _sum: FinancecheckbookSumAggregateOutputType | null
    _min: FinancecheckbookMinAggregateOutputType | null
    _max: FinancecheckbookMaxAggregateOutputType | null
  }

  export type FinancecheckbookAvgAggregateOutputType = {
    id: number | null
    income: Decimal | null
    expenses: Decimal | null
    total_due_amount: Decimal | null
  }

  export type FinancecheckbookSumAggregateOutputType = {
    id: number | null
    income: Decimal | null
    expenses: Decimal | null
    total_due_amount: Decimal | null
  }

  export type FinancecheckbookMinAggregateOutputType = {
    id: number | null
    month: string | null
    income: Decimal | null
    expenses: Decimal | null
    total_due_amount: Decimal | null
  }

  export type FinancecheckbookMaxAggregateOutputType = {
    id: number | null
    month: string | null
    income: Decimal | null
    expenses: Decimal | null
    total_due_amount: Decimal | null
  }

  export type FinancecheckbookCountAggregateOutputType = {
    id: number
    month: number
    income: number
    expenses: number
    total_due_amount: number
    _all: number
  }


  export type FinancecheckbookAvgAggregateInputType = {
    id?: true
    income?: true
    expenses?: true
    total_due_amount?: true
  }

  export type FinancecheckbookSumAggregateInputType = {
    id?: true
    income?: true
    expenses?: true
    total_due_amount?: true
  }

  export type FinancecheckbookMinAggregateInputType = {
    id?: true
    month?: true
    income?: true
    expenses?: true
    total_due_amount?: true
  }

  export type FinancecheckbookMaxAggregateInputType = {
    id?: true
    month?: true
    income?: true
    expenses?: true
    total_due_amount?: true
  }

  export type FinancecheckbookCountAggregateInputType = {
    id?: true
    month?: true
    income?: true
    expenses?: true
    total_due_amount?: true
    _all?: true
  }

  export type FinancecheckbookAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which financecheckbook to aggregate.
     */
    where?: financecheckbookWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of financecheckbooks to fetch.
     */
    orderBy?: financecheckbookOrderByWithRelationInput | financecheckbookOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: financecheckbookWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` financecheckbooks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` financecheckbooks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned financecheckbooks
    **/
    _count?: true | FinancecheckbookCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FinancecheckbookAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FinancecheckbookSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FinancecheckbookMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FinancecheckbookMaxAggregateInputType
  }

  export type GetFinancecheckbookAggregateType<T extends FinancecheckbookAggregateArgs> = {
        [P in keyof T & keyof AggregateFinancecheckbook]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFinancecheckbook[P]>
      : GetScalarType<T[P], AggregateFinancecheckbook[P]>
  }




  export type financecheckbookGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: financecheckbookWhereInput
    orderBy?: financecheckbookOrderByWithAggregationInput | financecheckbookOrderByWithAggregationInput[]
    by: FinancecheckbookScalarFieldEnum[] | FinancecheckbookScalarFieldEnum
    having?: financecheckbookScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FinancecheckbookCountAggregateInputType | true
    _avg?: FinancecheckbookAvgAggregateInputType
    _sum?: FinancecheckbookSumAggregateInputType
    _min?: FinancecheckbookMinAggregateInputType
    _max?: FinancecheckbookMaxAggregateInputType
  }

  export type FinancecheckbookGroupByOutputType = {
    id: number
    month: string
    income: Decimal
    expenses: Decimal
    total_due_amount: Decimal | null
    _count: FinancecheckbookCountAggregateOutputType | null
    _avg: FinancecheckbookAvgAggregateOutputType | null
    _sum: FinancecheckbookSumAggregateOutputType | null
    _min: FinancecheckbookMinAggregateOutputType | null
    _max: FinancecheckbookMaxAggregateOutputType | null
  }

  type GetFinancecheckbookGroupByPayload<T extends financecheckbookGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FinancecheckbookGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FinancecheckbookGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FinancecheckbookGroupByOutputType[P]>
            : GetScalarType<T[P], FinancecheckbookGroupByOutputType[P]>
        }
      >
    >


  export type financecheckbookSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    month?: boolean
    income?: boolean
    expenses?: boolean
    total_due_amount?: boolean
  }, ExtArgs["result"]["financecheckbook"]>

  export type financecheckbookSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    month?: boolean
    income?: boolean
    expenses?: boolean
    total_due_amount?: boolean
  }, ExtArgs["result"]["financecheckbook"]>

  export type financecheckbookSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    month?: boolean
    income?: boolean
    expenses?: boolean
    total_due_amount?: boolean
  }, ExtArgs["result"]["financecheckbook"]>

  export type financecheckbookSelectScalar = {
    id?: boolean
    month?: boolean
    income?: boolean
    expenses?: boolean
    total_due_amount?: boolean
  }

  export type financecheckbookOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "month" | "income" | "expenses" | "total_due_amount", ExtArgs["result"]["financecheckbook"]>

  export type $financecheckbookPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "financecheckbook"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      month: string
      income: Prisma.Decimal
      expenses: Prisma.Decimal
      total_due_amount: Prisma.Decimal | null
    }, ExtArgs["result"]["financecheckbook"]>
    composites: {}
  }

  type financecheckbookGetPayload<S extends boolean | null | undefined | financecheckbookDefaultArgs> = $Result.GetResult<Prisma.$financecheckbookPayload, S>

  type financecheckbookCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<financecheckbookFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FinancecheckbookCountAggregateInputType | true
    }

  export interface financecheckbookDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['financecheckbook'], meta: { name: 'financecheckbook' } }
    /**
     * Find zero or one Financecheckbook that matches the filter.
     * @param {financecheckbookFindUniqueArgs} args - Arguments to find a Financecheckbook
     * @example
     * // Get one Financecheckbook
     * const financecheckbook = await prisma.financecheckbook.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends financecheckbookFindUniqueArgs>(args: SelectSubset<T, financecheckbookFindUniqueArgs<ExtArgs>>): Prisma__financecheckbookClient<$Result.GetResult<Prisma.$financecheckbookPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Financecheckbook that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {financecheckbookFindUniqueOrThrowArgs} args - Arguments to find a Financecheckbook
     * @example
     * // Get one Financecheckbook
     * const financecheckbook = await prisma.financecheckbook.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends financecheckbookFindUniqueOrThrowArgs>(args: SelectSubset<T, financecheckbookFindUniqueOrThrowArgs<ExtArgs>>): Prisma__financecheckbookClient<$Result.GetResult<Prisma.$financecheckbookPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Financecheckbook that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {financecheckbookFindFirstArgs} args - Arguments to find a Financecheckbook
     * @example
     * // Get one Financecheckbook
     * const financecheckbook = await prisma.financecheckbook.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends financecheckbookFindFirstArgs>(args?: SelectSubset<T, financecheckbookFindFirstArgs<ExtArgs>>): Prisma__financecheckbookClient<$Result.GetResult<Prisma.$financecheckbookPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Financecheckbook that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {financecheckbookFindFirstOrThrowArgs} args - Arguments to find a Financecheckbook
     * @example
     * // Get one Financecheckbook
     * const financecheckbook = await prisma.financecheckbook.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends financecheckbookFindFirstOrThrowArgs>(args?: SelectSubset<T, financecheckbookFindFirstOrThrowArgs<ExtArgs>>): Prisma__financecheckbookClient<$Result.GetResult<Prisma.$financecheckbookPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Financecheckbooks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {financecheckbookFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Financecheckbooks
     * const financecheckbooks = await prisma.financecheckbook.findMany()
     * 
     * // Get first 10 Financecheckbooks
     * const financecheckbooks = await prisma.financecheckbook.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const financecheckbookWithIdOnly = await prisma.financecheckbook.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends financecheckbookFindManyArgs>(args?: SelectSubset<T, financecheckbookFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$financecheckbookPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Financecheckbook.
     * @param {financecheckbookCreateArgs} args - Arguments to create a Financecheckbook.
     * @example
     * // Create one Financecheckbook
     * const Financecheckbook = await prisma.financecheckbook.create({
     *   data: {
     *     // ... data to create a Financecheckbook
     *   }
     * })
     * 
     */
    create<T extends financecheckbookCreateArgs>(args: SelectSubset<T, financecheckbookCreateArgs<ExtArgs>>): Prisma__financecheckbookClient<$Result.GetResult<Prisma.$financecheckbookPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Financecheckbooks.
     * @param {financecheckbookCreateManyArgs} args - Arguments to create many Financecheckbooks.
     * @example
     * // Create many Financecheckbooks
     * const financecheckbook = await prisma.financecheckbook.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends financecheckbookCreateManyArgs>(args?: SelectSubset<T, financecheckbookCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Financecheckbooks and returns the data saved in the database.
     * @param {financecheckbookCreateManyAndReturnArgs} args - Arguments to create many Financecheckbooks.
     * @example
     * // Create many Financecheckbooks
     * const financecheckbook = await prisma.financecheckbook.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Financecheckbooks and only return the `id`
     * const financecheckbookWithIdOnly = await prisma.financecheckbook.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends financecheckbookCreateManyAndReturnArgs>(args?: SelectSubset<T, financecheckbookCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$financecheckbookPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Financecheckbook.
     * @param {financecheckbookDeleteArgs} args - Arguments to delete one Financecheckbook.
     * @example
     * // Delete one Financecheckbook
     * const Financecheckbook = await prisma.financecheckbook.delete({
     *   where: {
     *     // ... filter to delete one Financecheckbook
     *   }
     * })
     * 
     */
    delete<T extends financecheckbookDeleteArgs>(args: SelectSubset<T, financecheckbookDeleteArgs<ExtArgs>>): Prisma__financecheckbookClient<$Result.GetResult<Prisma.$financecheckbookPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Financecheckbook.
     * @param {financecheckbookUpdateArgs} args - Arguments to update one Financecheckbook.
     * @example
     * // Update one Financecheckbook
     * const financecheckbook = await prisma.financecheckbook.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends financecheckbookUpdateArgs>(args: SelectSubset<T, financecheckbookUpdateArgs<ExtArgs>>): Prisma__financecheckbookClient<$Result.GetResult<Prisma.$financecheckbookPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Financecheckbooks.
     * @param {financecheckbookDeleteManyArgs} args - Arguments to filter Financecheckbooks to delete.
     * @example
     * // Delete a few Financecheckbooks
     * const { count } = await prisma.financecheckbook.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends financecheckbookDeleteManyArgs>(args?: SelectSubset<T, financecheckbookDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Financecheckbooks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {financecheckbookUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Financecheckbooks
     * const financecheckbook = await prisma.financecheckbook.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends financecheckbookUpdateManyArgs>(args: SelectSubset<T, financecheckbookUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Financecheckbooks and returns the data updated in the database.
     * @param {financecheckbookUpdateManyAndReturnArgs} args - Arguments to update many Financecheckbooks.
     * @example
     * // Update many Financecheckbooks
     * const financecheckbook = await prisma.financecheckbook.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Financecheckbooks and only return the `id`
     * const financecheckbookWithIdOnly = await prisma.financecheckbook.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends financecheckbookUpdateManyAndReturnArgs>(args: SelectSubset<T, financecheckbookUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$financecheckbookPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Financecheckbook.
     * @param {financecheckbookUpsertArgs} args - Arguments to update or create a Financecheckbook.
     * @example
     * // Update or create a Financecheckbook
     * const financecheckbook = await prisma.financecheckbook.upsert({
     *   create: {
     *     // ... data to create a Financecheckbook
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Financecheckbook we want to update
     *   }
     * })
     */
    upsert<T extends financecheckbookUpsertArgs>(args: SelectSubset<T, financecheckbookUpsertArgs<ExtArgs>>): Prisma__financecheckbookClient<$Result.GetResult<Prisma.$financecheckbookPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Financecheckbooks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {financecheckbookCountArgs} args - Arguments to filter Financecheckbooks to count.
     * @example
     * // Count the number of Financecheckbooks
     * const count = await prisma.financecheckbook.count({
     *   where: {
     *     // ... the filter for the Financecheckbooks we want to count
     *   }
     * })
    **/
    count<T extends financecheckbookCountArgs>(
      args?: Subset<T, financecheckbookCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FinancecheckbookCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Financecheckbook.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FinancecheckbookAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FinancecheckbookAggregateArgs>(args: Subset<T, FinancecheckbookAggregateArgs>): Prisma.PrismaPromise<GetFinancecheckbookAggregateType<T>>

    /**
     * Group by Financecheckbook.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {financecheckbookGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends financecheckbookGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: financecheckbookGroupByArgs['orderBy'] }
        : { orderBy?: financecheckbookGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, financecheckbookGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFinancecheckbookGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the financecheckbook model
   */
  readonly fields: financecheckbookFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for financecheckbook.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__financecheckbookClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the financecheckbook model
   */
  interface financecheckbookFieldRefs {
    readonly id: FieldRef<"financecheckbook", 'Int'>
    readonly month: FieldRef<"financecheckbook", 'String'>
    readonly income: FieldRef<"financecheckbook", 'Decimal'>
    readonly expenses: FieldRef<"financecheckbook", 'Decimal'>
    readonly total_due_amount: FieldRef<"financecheckbook", 'Decimal'>
  }
    

  // Custom InputTypes
  /**
   * financecheckbook findUnique
   */
  export type financecheckbookFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the financecheckbook
     */
    select?: financecheckbookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the financecheckbook
     */
    omit?: financecheckbookOmit<ExtArgs> | null
    /**
     * Filter, which financecheckbook to fetch.
     */
    where: financecheckbookWhereUniqueInput
  }

  /**
   * financecheckbook findUniqueOrThrow
   */
  export type financecheckbookFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the financecheckbook
     */
    select?: financecheckbookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the financecheckbook
     */
    omit?: financecheckbookOmit<ExtArgs> | null
    /**
     * Filter, which financecheckbook to fetch.
     */
    where: financecheckbookWhereUniqueInput
  }

  /**
   * financecheckbook findFirst
   */
  export type financecheckbookFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the financecheckbook
     */
    select?: financecheckbookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the financecheckbook
     */
    omit?: financecheckbookOmit<ExtArgs> | null
    /**
     * Filter, which financecheckbook to fetch.
     */
    where?: financecheckbookWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of financecheckbooks to fetch.
     */
    orderBy?: financecheckbookOrderByWithRelationInput | financecheckbookOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for financecheckbooks.
     */
    cursor?: financecheckbookWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` financecheckbooks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` financecheckbooks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of financecheckbooks.
     */
    distinct?: FinancecheckbookScalarFieldEnum | FinancecheckbookScalarFieldEnum[]
  }

  /**
   * financecheckbook findFirstOrThrow
   */
  export type financecheckbookFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the financecheckbook
     */
    select?: financecheckbookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the financecheckbook
     */
    omit?: financecheckbookOmit<ExtArgs> | null
    /**
     * Filter, which financecheckbook to fetch.
     */
    where?: financecheckbookWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of financecheckbooks to fetch.
     */
    orderBy?: financecheckbookOrderByWithRelationInput | financecheckbookOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for financecheckbooks.
     */
    cursor?: financecheckbookWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` financecheckbooks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` financecheckbooks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of financecheckbooks.
     */
    distinct?: FinancecheckbookScalarFieldEnum | FinancecheckbookScalarFieldEnum[]
  }

  /**
   * financecheckbook findMany
   */
  export type financecheckbookFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the financecheckbook
     */
    select?: financecheckbookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the financecheckbook
     */
    omit?: financecheckbookOmit<ExtArgs> | null
    /**
     * Filter, which financecheckbooks to fetch.
     */
    where?: financecheckbookWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of financecheckbooks to fetch.
     */
    orderBy?: financecheckbookOrderByWithRelationInput | financecheckbookOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing financecheckbooks.
     */
    cursor?: financecheckbookWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` financecheckbooks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` financecheckbooks.
     */
    skip?: number
    distinct?: FinancecheckbookScalarFieldEnum | FinancecheckbookScalarFieldEnum[]
  }

  /**
   * financecheckbook create
   */
  export type financecheckbookCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the financecheckbook
     */
    select?: financecheckbookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the financecheckbook
     */
    omit?: financecheckbookOmit<ExtArgs> | null
    /**
     * The data needed to create a financecheckbook.
     */
    data: XOR<financecheckbookCreateInput, financecheckbookUncheckedCreateInput>
  }

  /**
   * financecheckbook createMany
   */
  export type financecheckbookCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many financecheckbooks.
     */
    data: financecheckbookCreateManyInput | financecheckbookCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * financecheckbook createManyAndReturn
   */
  export type financecheckbookCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the financecheckbook
     */
    select?: financecheckbookSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the financecheckbook
     */
    omit?: financecheckbookOmit<ExtArgs> | null
    /**
     * The data used to create many financecheckbooks.
     */
    data: financecheckbookCreateManyInput | financecheckbookCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * financecheckbook update
   */
  export type financecheckbookUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the financecheckbook
     */
    select?: financecheckbookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the financecheckbook
     */
    omit?: financecheckbookOmit<ExtArgs> | null
    /**
     * The data needed to update a financecheckbook.
     */
    data: XOR<financecheckbookUpdateInput, financecheckbookUncheckedUpdateInput>
    /**
     * Choose, which financecheckbook to update.
     */
    where: financecheckbookWhereUniqueInput
  }

  /**
   * financecheckbook updateMany
   */
  export type financecheckbookUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update financecheckbooks.
     */
    data: XOR<financecheckbookUpdateManyMutationInput, financecheckbookUncheckedUpdateManyInput>
    /**
     * Filter which financecheckbooks to update
     */
    where?: financecheckbookWhereInput
    /**
     * Limit how many financecheckbooks to update.
     */
    limit?: number
  }

  /**
   * financecheckbook updateManyAndReturn
   */
  export type financecheckbookUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the financecheckbook
     */
    select?: financecheckbookSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the financecheckbook
     */
    omit?: financecheckbookOmit<ExtArgs> | null
    /**
     * The data used to update financecheckbooks.
     */
    data: XOR<financecheckbookUpdateManyMutationInput, financecheckbookUncheckedUpdateManyInput>
    /**
     * Filter which financecheckbooks to update
     */
    where?: financecheckbookWhereInput
    /**
     * Limit how many financecheckbooks to update.
     */
    limit?: number
  }

  /**
   * financecheckbook upsert
   */
  export type financecheckbookUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the financecheckbook
     */
    select?: financecheckbookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the financecheckbook
     */
    omit?: financecheckbookOmit<ExtArgs> | null
    /**
     * The filter to search for the financecheckbook to update in case it exists.
     */
    where: financecheckbookWhereUniqueInput
    /**
     * In case the financecheckbook found by the `where` argument doesn't exist, create a new financecheckbook with this data.
     */
    create: XOR<financecheckbookCreateInput, financecheckbookUncheckedCreateInput>
    /**
     * In case the financecheckbook was found with the provided `where` argument, update it with this data.
     */
    update: XOR<financecheckbookUpdateInput, financecheckbookUncheckedUpdateInput>
  }

  /**
   * financecheckbook delete
   */
  export type financecheckbookDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the financecheckbook
     */
    select?: financecheckbookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the financecheckbook
     */
    omit?: financecheckbookOmit<ExtArgs> | null
    /**
     * Filter which financecheckbook to delete.
     */
    where: financecheckbookWhereUniqueInput
  }

  /**
   * financecheckbook deleteMany
   */
  export type financecheckbookDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which financecheckbooks to delete
     */
    where?: financecheckbookWhereInput
    /**
     * Limit how many financecheckbooks to delete.
     */
    limit?: number
  }

  /**
   * financecheckbook without action
   */
  export type financecheckbookDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the financecheckbook
     */
    select?: financecheckbookSelect<ExtArgs> | null
    /**
     * Omit specific fields from the financecheckbook
     */
    omit?: financecheckbookOmit<ExtArgs> | null
  }


  /**
   * Model finances
   */

  export type AggregateFinances = {
    _count: FinancesCountAggregateOutputType | null
    _avg: FinancesAvgAggregateOutputType | null
    _sum: FinancesSumAggregateOutputType | null
    _min: FinancesMinAggregateOutputType | null
    _max: FinancesMaxAggregateOutputType | null
  }

  export type FinancesAvgAggregateOutputType = {
    id: number | null
    student_id: number | null
    total_fee: Decimal | null
    paid_amount: Decimal | null
    due_amount: Decimal | null
    penalty: Decimal | null
    expenses: Decimal | null
  }

  export type FinancesSumAggregateOutputType = {
    id: number | null
    student_id: number | null
    total_fee: Decimal | null
    paid_amount: Decimal | null
    due_amount: Decimal | null
    penalty: Decimal | null
    expenses: Decimal | null
  }

  export type FinancesMinAggregateOutputType = {
    id: number | null
    student_id: number | null
    total_fee: Decimal | null
    paid_amount: Decimal | null
    due_amount: Decimal | null
    month: string | null
    payment_status: string | null
    penalty: Decimal | null
    expenses: Decimal | null
  }

  export type FinancesMaxAggregateOutputType = {
    id: number | null
    student_id: number | null
    total_fee: Decimal | null
    paid_amount: Decimal | null
    due_amount: Decimal | null
    month: string | null
    payment_status: string | null
    penalty: Decimal | null
    expenses: Decimal | null
  }

  export type FinancesCountAggregateOutputType = {
    id: number
    student_id: number
    total_fee: number
    paid_amount: number
    due_amount: number
    month: number
    payment_status: number
    penalty: number
    expenses: number
    _all: number
  }


  export type FinancesAvgAggregateInputType = {
    id?: true
    student_id?: true
    total_fee?: true
    paid_amount?: true
    due_amount?: true
    penalty?: true
    expenses?: true
  }

  export type FinancesSumAggregateInputType = {
    id?: true
    student_id?: true
    total_fee?: true
    paid_amount?: true
    due_amount?: true
    penalty?: true
    expenses?: true
  }

  export type FinancesMinAggregateInputType = {
    id?: true
    student_id?: true
    total_fee?: true
    paid_amount?: true
    due_amount?: true
    month?: true
    payment_status?: true
    penalty?: true
    expenses?: true
  }

  export type FinancesMaxAggregateInputType = {
    id?: true
    student_id?: true
    total_fee?: true
    paid_amount?: true
    due_amount?: true
    month?: true
    payment_status?: true
    penalty?: true
    expenses?: true
  }

  export type FinancesCountAggregateInputType = {
    id?: true
    student_id?: true
    total_fee?: true
    paid_amount?: true
    due_amount?: true
    month?: true
    payment_status?: true
    penalty?: true
    expenses?: true
    _all?: true
  }

  export type FinancesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which finances to aggregate.
     */
    where?: financesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of finances to fetch.
     */
    orderBy?: financesOrderByWithRelationInput | financesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: financesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` finances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` finances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned finances
    **/
    _count?: true | FinancesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FinancesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FinancesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FinancesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FinancesMaxAggregateInputType
  }

  export type GetFinancesAggregateType<T extends FinancesAggregateArgs> = {
        [P in keyof T & keyof AggregateFinances]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFinances[P]>
      : GetScalarType<T[P], AggregateFinances[P]>
  }




  export type financesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: financesWhereInput
    orderBy?: financesOrderByWithAggregationInput | financesOrderByWithAggregationInput[]
    by: FinancesScalarFieldEnum[] | FinancesScalarFieldEnum
    having?: financesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FinancesCountAggregateInputType | true
    _avg?: FinancesAvgAggregateInputType
    _sum?: FinancesSumAggregateInputType
    _min?: FinancesMinAggregateInputType
    _max?: FinancesMaxAggregateInputType
  }

  export type FinancesGroupByOutputType = {
    id: number
    student_id: number | null
    total_fee: Decimal
    paid_amount: Decimal | null
    due_amount: Decimal | null
    month: string
    payment_status: string | null
    penalty: Decimal | null
    expenses: Decimal | null
    _count: FinancesCountAggregateOutputType | null
    _avg: FinancesAvgAggregateOutputType | null
    _sum: FinancesSumAggregateOutputType | null
    _min: FinancesMinAggregateOutputType | null
    _max: FinancesMaxAggregateOutputType | null
  }

  type GetFinancesGroupByPayload<T extends financesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FinancesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FinancesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FinancesGroupByOutputType[P]>
            : GetScalarType<T[P], FinancesGroupByOutputType[P]>
        }
      >
    >


  export type financesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    student_id?: boolean
    total_fee?: boolean
    paid_amount?: boolean
    due_amount?: boolean
    month?: boolean
    payment_status?: boolean
    penalty?: boolean
    expenses?: boolean
    students?: boolean | finances$studentsArgs<ExtArgs>
  }, ExtArgs["result"]["finances"]>

  export type financesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    student_id?: boolean
    total_fee?: boolean
    paid_amount?: boolean
    due_amount?: boolean
    month?: boolean
    payment_status?: boolean
    penalty?: boolean
    expenses?: boolean
    students?: boolean | finances$studentsArgs<ExtArgs>
  }, ExtArgs["result"]["finances"]>

  export type financesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    student_id?: boolean
    total_fee?: boolean
    paid_amount?: boolean
    due_amount?: boolean
    month?: boolean
    payment_status?: boolean
    penalty?: boolean
    expenses?: boolean
    students?: boolean | finances$studentsArgs<ExtArgs>
  }, ExtArgs["result"]["finances"]>

  export type financesSelectScalar = {
    id?: boolean
    student_id?: boolean
    total_fee?: boolean
    paid_amount?: boolean
    due_amount?: boolean
    month?: boolean
    payment_status?: boolean
    penalty?: boolean
    expenses?: boolean
  }

  export type financesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "student_id" | "total_fee" | "paid_amount" | "due_amount" | "month" | "payment_status" | "penalty" | "expenses", ExtArgs["result"]["finances"]>
  export type financesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    students?: boolean | finances$studentsArgs<ExtArgs>
  }
  export type financesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    students?: boolean | finances$studentsArgs<ExtArgs>
  }
  export type financesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    students?: boolean | finances$studentsArgs<ExtArgs>
  }

  export type $financesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "finances"
    objects: {
      students: Prisma.$studentsPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      student_id: number | null
      total_fee: Prisma.Decimal
      paid_amount: Prisma.Decimal | null
      due_amount: Prisma.Decimal | null
      month: string
      payment_status: string | null
      penalty: Prisma.Decimal | null
      expenses: Prisma.Decimal | null
    }, ExtArgs["result"]["finances"]>
    composites: {}
  }

  type financesGetPayload<S extends boolean | null | undefined | financesDefaultArgs> = $Result.GetResult<Prisma.$financesPayload, S>

  type financesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<financesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FinancesCountAggregateInputType | true
    }

  export interface financesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['finances'], meta: { name: 'finances' } }
    /**
     * Find zero or one Finances that matches the filter.
     * @param {financesFindUniqueArgs} args - Arguments to find a Finances
     * @example
     * // Get one Finances
     * const finances = await prisma.finances.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends financesFindUniqueArgs>(args: SelectSubset<T, financesFindUniqueArgs<ExtArgs>>): Prisma__financesClient<$Result.GetResult<Prisma.$financesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Finances that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {financesFindUniqueOrThrowArgs} args - Arguments to find a Finances
     * @example
     * // Get one Finances
     * const finances = await prisma.finances.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends financesFindUniqueOrThrowArgs>(args: SelectSubset<T, financesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__financesClient<$Result.GetResult<Prisma.$financesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Finances that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {financesFindFirstArgs} args - Arguments to find a Finances
     * @example
     * // Get one Finances
     * const finances = await prisma.finances.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends financesFindFirstArgs>(args?: SelectSubset<T, financesFindFirstArgs<ExtArgs>>): Prisma__financesClient<$Result.GetResult<Prisma.$financesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Finances that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {financesFindFirstOrThrowArgs} args - Arguments to find a Finances
     * @example
     * // Get one Finances
     * const finances = await prisma.finances.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends financesFindFirstOrThrowArgs>(args?: SelectSubset<T, financesFindFirstOrThrowArgs<ExtArgs>>): Prisma__financesClient<$Result.GetResult<Prisma.$financesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Finances that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {financesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Finances
     * const finances = await prisma.finances.findMany()
     * 
     * // Get first 10 Finances
     * const finances = await prisma.finances.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const financesWithIdOnly = await prisma.finances.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends financesFindManyArgs>(args?: SelectSubset<T, financesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$financesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Finances.
     * @param {financesCreateArgs} args - Arguments to create a Finances.
     * @example
     * // Create one Finances
     * const Finances = await prisma.finances.create({
     *   data: {
     *     // ... data to create a Finances
     *   }
     * })
     * 
     */
    create<T extends financesCreateArgs>(args: SelectSubset<T, financesCreateArgs<ExtArgs>>): Prisma__financesClient<$Result.GetResult<Prisma.$financesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Finances.
     * @param {financesCreateManyArgs} args - Arguments to create many Finances.
     * @example
     * // Create many Finances
     * const finances = await prisma.finances.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends financesCreateManyArgs>(args?: SelectSubset<T, financesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Finances and returns the data saved in the database.
     * @param {financesCreateManyAndReturnArgs} args - Arguments to create many Finances.
     * @example
     * // Create many Finances
     * const finances = await prisma.finances.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Finances and only return the `id`
     * const financesWithIdOnly = await prisma.finances.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends financesCreateManyAndReturnArgs>(args?: SelectSubset<T, financesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$financesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Finances.
     * @param {financesDeleteArgs} args - Arguments to delete one Finances.
     * @example
     * // Delete one Finances
     * const Finances = await prisma.finances.delete({
     *   where: {
     *     // ... filter to delete one Finances
     *   }
     * })
     * 
     */
    delete<T extends financesDeleteArgs>(args: SelectSubset<T, financesDeleteArgs<ExtArgs>>): Prisma__financesClient<$Result.GetResult<Prisma.$financesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Finances.
     * @param {financesUpdateArgs} args - Arguments to update one Finances.
     * @example
     * // Update one Finances
     * const finances = await prisma.finances.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends financesUpdateArgs>(args: SelectSubset<T, financesUpdateArgs<ExtArgs>>): Prisma__financesClient<$Result.GetResult<Prisma.$financesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Finances.
     * @param {financesDeleteManyArgs} args - Arguments to filter Finances to delete.
     * @example
     * // Delete a few Finances
     * const { count } = await prisma.finances.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends financesDeleteManyArgs>(args?: SelectSubset<T, financesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Finances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {financesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Finances
     * const finances = await prisma.finances.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends financesUpdateManyArgs>(args: SelectSubset<T, financesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Finances and returns the data updated in the database.
     * @param {financesUpdateManyAndReturnArgs} args - Arguments to update many Finances.
     * @example
     * // Update many Finances
     * const finances = await prisma.finances.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Finances and only return the `id`
     * const financesWithIdOnly = await prisma.finances.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends financesUpdateManyAndReturnArgs>(args: SelectSubset<T, financesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$financesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Finances.
     * @param {financesUpsertArgs} args - Arguments to update or create a Finances.
     * @example
     * // Update or create a Finances
     * const finances = await prisma.finances.upsert({
     *   create: {
     *     // ... data to create a Finances
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Finances we want to update
     *   }
     * })
     */
    upsert<T extends financesUpsertArgs>(args: SelectSubset<T, financesUpsertArgs<ExtArgs>>): Prisma__financesClient<$Result.GetResult<Prisma.$financesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Finances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {financesCountArgs} args - Arguments to filter Finances to count.
     * @example
     * // Count the number of Finances
     * const count = await prisma.finances.count({
     *   where: {
     *     // ... the filter for the Finances we want to count
     *   }
     * })
    **/
    count<T extends financesCountArgs>(
      args?: Subset<T, financesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FinancesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Finances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FinancesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FinancesAggregateArgs>(args: Subset<T, FinancesAggregateArgs>): Prisma.PrismaPromise<GetFinancesAggregateType<T>>

    /**
     * Group by Finances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {financesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends financesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: financesGroupByArgs['orderBy'] }
        : { orderBy?: financesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, financesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFinancesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the finances model
   */
  readonly fields: financesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for finances.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__financesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    students<T extends finances$studentsArgs<ExtArgs> = {}>(args?: Subset<T, finances$studentsArgs<ExtArgs>>): Prisma__studentsClient<$Result.GetResult<Prisma.$studentsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the finances model
   */
  interface financesFieldRefs {
    readonly id: FieldRef<"finances", 'Int'>
    readonly student_id: FieldRef<"finances", 'Int'>
    readonly total_fee: FieldRef<"finances", 'Decimal'>
    readonly paid_amount: FieldRef<"finances", 'Decimal'>
    readonly due_amount: FieldRef<"finances", 'Decimal'>
    readonly month: FieldRef<"finances", 'String'>
    readonly payment_status: FieldRef<"finances", 'String'>
    readonly penalty: FieldRef<"finances", 'Decimal'>
    readonly expenses: FieldRef<"finances", 'Decimal'>
  }
    

  // Custom InputTypes
  /**
   * finances findUnique
   */
  export type financesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the finances
     */
    select?: financesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the finances
     */
    omit?: financesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: financesInclude<ExtArgs> | null
    /**
     * Filter, which finances to fetch.
     */
    where: financesWhereUniqueInput
  }

  /**
   * finances findUniqueOrThrow
   */
  export type financesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the finances
     */
    select?: financesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the finances
     */
    omit?: financesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: financesInclude<ExtArgs> | null
    /**
     * Filter, which finances to fetch.
     */
    where: financesWhereUniqueInput
  }

  /**
   * finances findFirst
   */
  export type financesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the finances
     */
    select?: financesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the finances
     */
    omit?: financesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: financesInclude<ExtArgs> | null
    /**
     * Filter, which finances to fetch.
     */
    where?: financesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of finances to fetch.
     */
    orderBy?: financesOrderByWithRelationInput | financesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for finances.
     */
    cursor?: financesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` finances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` finances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of finances.
     */
    distinct?: FinancesScalarFieldEnum | FinancesScalarFieldEnum[]
  }

  /**
   * finances findFirstOrThrow
   */
  export type financesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the finances
     */
    select?: financesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the finances
     */
    omit?: financesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: financesInclude<ExtArgs> | null
    /**
     * Filter, which finances to fetch.
     */
    where?: financesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of finances to fetch.
     */
    orderBy?: financesOrderByWithRelationInput | financesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for finances.
     */
    cursor?: financesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` finances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` finances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of finances.
     */
    distinct?: FinancesScalarFieldEnum | FinancesScalarFieldEnum[]
  }

  /**
   * finances findMany
   */
  export type financesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the finances
     */
    select?: financesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the finances
     */
    omit?: financesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: financesInclude<ExtArgs> | null
    /**
     * Filter, which finances to fetch.
     */
    where?: financesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of finances to fetch.
     */
    orderBy?: financesOrderByWithRelationInput | financesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing finances.
     */
    cursor?: financesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` finances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` finances.
     */
    skip?: number
    distinct?: FinancesScalarFieldEnum | FinancesScalarFieldEnum[]
  }

  /**
   * finances create
   */
  export type financesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the finances
     */
    select?: financesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the finances
     */
    omit?: financesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: financesInclude<ExtArgs> | null
    /**
     * The data needed to create a finances.
     */
    data: XOR<financesCreateInput, financesUncheckedCreateInput>
  }

  /**
   * finances createMany
   */
  export type financesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many finances.
     */
    data: financesCreateManyInput | financesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * finances createManyAndReturn
   */
  export type financesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the finances
     */
    select?: financesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the finances
     */
    omit?: financesOmit<ExtArgs> | null
    /**
     * The data used to create many finances.
     */
    data: financesCreateManyInput | financesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: financesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * finances update
   */
  export type financesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the finances
     */
    select?: financesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the finances
     */
    omit?: financesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: financesInclude<ExtArgs> | null
    /**
     * The data needed to update a finances.
     */
    data: XOR<financesUpdateInput, financesUncheckedUpdateInput>
    /**
     * Choose, which finances to update.
     */
    where: financesWhereUniqueInput
  }

  /**
   * finances updateMany
   */
  export type financesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update finances.
     */
    data: XOR<financesUpdateManyMutationInput, financesUncheckedUpdateManyInput>
    /**
     * Filter which finances to update
     */
    where?: financesWhereInput
    /**
     * Limit how many finances to update.
     */
    limit?: number
  }

  /**
   * finances updateManyAndReturn
   */
  export type financesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the finances
     */
    select?: financesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the finances
     */
    omit?: financesOmit<ExtArgs> | null
    /**
     * The data used to update finances.
     */
    data: XOR<financesUpdateManyMutationInput, financesUncheckedUpdateManyInput>
    /**
     * Filter which finances to update
     */
    where?: financesWhereInput
    /**
     * Limit how many finances to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: financesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * finances upsert
   */
  export type financesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the finances
     */
    select?: financesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the finances
     */
    omit?: financesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: financesInclude<ExtArgs> | null
    /**
     * The filter to search for the finances to update in case it exists.
     */
    where: financesWhereUniqueInput
    /**
     * In case the finances found by the `where` argument doesn't exist, create a new finances with this data.
     */
    create: XOR<financesCreateInput, financesUncheckedCreateInput>
    /**
     * In case the finances was found with the provided `where` argument, update it with this data.
     */
    update: XOR<financesUpdateInput, financesUncheckedUpdateInput>
  }

  /**
   * finances delete
   */
  export type financesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the finances
     */
    select?: financesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the finances
     */
    omit?: financesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: financesInclude<ExtArgs> | null
    /**
     * Filter which finances to delete.
     */
    where: financesWhereUniqueInput
  }

  /**
   * finances deleteMany
   */
  export type financesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which finances to delete
     */
    where?: financesWhereInput
    /**
     * Limit how many finances to delete.
     */
    limit?: number
  }

  /**
   * finances.students
   */
  export type finances$studentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the students
     */
    select?: studentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the students
     */
    omit?: studentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: studentsInclude<ExtArgs> | null
    where?: studentsWhereInput
  }

  /**
   * finances without action
   */
  export type financesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the finances
     */
    select?: financesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the finances
     */
    omit?: financesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: financesInclude<ExtArgs> | null
  }


  /**
   * Model notes
   */

  export type AggregateNotes = {
    _count: NotesCountAggregateOutputType | null
    _avg: NotesAvgAggregateOutputType | null
    _sum: NotesSumAggregateOutputType | null
    _min: NotesMinAggregateOutputType | null
    _max: NotesMaxAggregateOutputType | null
  }

  export type NotesAvgAggregateOutputType = {
    id: number | null
    created_by: number | null
  }

  export type NotesSumAggregateOutputType = {
    id: number | null
    created_by: number | null
  }

  export type NotesMinAggregateOutputType = {
    id: number | null
    title: string | null
    content: string | null
    subject: string | null
    class: string | null
    section: string | null
    created_by: number | null
    files: string | null
    created_at: Date | null
  }

  export type NotesMaxAggregateOutputType = {
    id: number | null
    title: string | null
    content: string | null
    subject: string | null
    class: string | null
    section: string | null
    created_by: number | null
    files: string | null
    created_at: Date | null
  }

  export type NotesCountAggregateOutputType = {
    id: number
    title: number
    content: number
    subject: number
    class: number
    section: number
    created_by: number
    files: number
    created_at: number
    _all: number
  }


  export type NotesAvgAggregateInputType = {
    id?: true
    created_by?: true
  }

  export type NotesSumAggregateInputType = {
    id?: true
    created_by?: true
  }

  export type NotesMinAggregateInputType = {
    id?: true
    title?: true
    content?: true
    subject?: true
    class?: true
    section?: true
    created_by?: true
    files?: true
    created_at?: true
  }

  export type NotesMaxAggregateInputType = {
    id?: true
    title?: true
    content?: true
    subject?: true
    class?: true
    section?: true
    created_by?: true
    files?: true
    created_at?: true
  }

  export type NotesCountAggregateInputType = {
    id?: true
    title?: true
    content?: true
    subject?: true
    class?: true
    section?: true
    created_by?: true
    files?: true
    created_at?: true
    _all?: true
  }

  export type NotesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which notes to aggregate.
     */
    where?: notesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of notes to fetch.
     */
    orderBy?: notesOrderByWithRelationInput | notesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: notesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` notes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` notes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned notes
    **/
    _count?: true | NotesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NotesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NotesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotesMaxAggregateInputType
  }

  export type GetNotesAggregateType<T extends NotesAggregateArgs> = {
        [P in keyof T & keyof AggregateNotes]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotes[P]>
      : GetScalarType<T[P], AggregateNotes[P]>
  }




  export type notesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: notesWhereInput
    orderBy?: notesOrderByWithAggregationInput | notesOrderByWithAggregationInput[]
    by: NotesScalarFieldEnum[] | NotesScalarFieldEnum
    having?: notesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotesCountAggregateInputType | true
    _avg?: NotesAvgAggregateInputType
    _sum?: NotesSumAggregateInputType
    _min?: NotesMinAggregateInputType
    _max?: NotesMaxAggregateInputType
  }

  export type NotesGroupByOutputType = {
    id: number
    title: string
    content: string
    subject: string
    class: string
    section: string
    created_by: number | null
    files: string | null
    created_at: Date | null
    _count: NotesCountAggregateOutputType | null
    _avg: NotesAvgAggregateOutputType | null
    _sum: NotesSumAggregateOutputType | null
    _min: NotesMinAggregateOutputType | null
    _max: NotesMaxAggregateOutputType | null
  }

  type GetNotesGroupByPayload<T extends notesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotesGroupByOutputType[P]>
            : GetScalarType<T[P], NotesGroupByOutputType[P]>
        }
      >
    >


  export type notesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    content?: boolean
    subject?: boolean
    class?: boolean
    section?: boolean
    created_by?: boolean
    files?: boolean
    created_at?: boolean
    users?: boolean | notes$usersArgs<ExtArgs>
  }, ExtArgs["result"]["notes"]>

  export type notesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    content?: boolean
    subject?: boolean
    class?: boolean
    section?: boolean
    created_by?: boolean
    files?: boolean
    created_at?: boolean
    users?: boolean | notes$usersArgs<ExtArgs>
  }, ExtArgs["result"]["notes"]>

  export type notesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    content?: boolean
    subject?: boolean
    class?: boolean
    section?: boolean
    created_by?: boolean
    files?: boolean
    created_at?: boolean
    users?: boolean | notes$usersArgs<ExtArgs>
  }, ExtArgs["result"]["notes"]>

  export type notesSelectScalar = {
    id?: boolean
    title?: boolean
    content?: boolean
    subject?: boolean
    class?: boolean
    section?: boolean
    created_by?: boolean
    files?: boolean
    created_at?: boolean
  }

  export type notesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "content" | "subject" | "class" | "section" | "created_by" | "files" | "created_at", ExtArgs["result"]["notes"]>
  export type notesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | notes$usersArgs<ExtArgs>
  }
  export type notesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | notes$usersArgs<ExtArgs>
  }
  export type notesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | notes$usersArgs<ExtArgs>
  }

  export type $notesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "notes"
    objects: {
      users: Prisma.$usersPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      title: string
      content: string
      subject: string
      class: string
      section: string
      created_by: number | null
      files: string | null
      created_at: Date | null
    }, ExtArgs["result"]["notes"]>
    composites: {}
  }

  type notesGetPayload<S extends boolean | null | undefined | notesDefaultArgs> = $Result.GetResult<Prisma.$notesPayload, S>

  type notesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<notesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NotesCountAggregateInputType | true
    }

  export interface notesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['notes'], meta: { name: 'notes' } }
    /**
     * Find zero or one Notes that matches the filter.
     * @param {notesFindUniqueArgs} args - Arguments to find a Notes
     * @example
     * // Get one Notes
     * const notes = await prisma.notes.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends notesFindUniqueArgs>(args: SelectSubset<T, notesFindUniqueArgs<ExtArgs>>): Prisma__notesClient<$Result.GetResult<Prisma.$notesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Notes that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {notesFindUniqueOrThrowArgs} args - Arguments to find a Notes
     * @example
     * // Get one Notes
     * const notes = await prisma.notes.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends notesFindUniqueOrThrowArgs>(args: SelectSubset<T, notesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__notesClient<$Result.GetResult<Prisma.$notesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notesFindFirstArgs} args - Arguments to find a Notes
     * @example
     * // Get one Notes
     * const notes = await prisma.notes.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends notesFindFirstArgs>(args?: SelectSubset<T, notesFindFirstArgs<ExtArgs>>): Prisma__notesClient<$Result.GetResult<Prisma.$notesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notes that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notesFindFirstOrThrowArgs} args - Arguments to find a Notes
     * @example
     * // Get one Notes
     * const notes = await prisma.notes.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends notesFindFirstOrThrowArgs>(args?: SelectSubset<T, notesFindFirstOrThrowArgs<ExtArgs>>): Prisma__notesClient<$Result.GetResult<Prisma.$notesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Notes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notes
     * const notes = await prisma.notes.findMany()
     * 
     * // Get first 10 Notes
     * const notes = await prisma.notes.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notesWithIdOnly = await prisma.notes.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends notesFindManyArgs>(args?: SelectSubset<T, notesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$notesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Notes.
     * @param {notesCreateArgs} args - Arguments to create a Notes.
     * @example
     * // Create one Notes
     * const Notes = await prisma.notes.create({
     *   data: {
     *     // ... data to create a Notes
     *   }
     * })
     * 
     */
    create<T extends notesCreateArgs>(args: SelectSubset<T, notesCreateArgs<ExtArgs>>): Prisma__notesClient<$Result.GetResult<Prisma.$notesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Notes.
     * @param {notesCreateManyArgs} args - Arguments to create many Notes.
     * @example
     * // Create many Notes
     * const notes = await prisma.notes.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends notesCreateManyArgs>(args?: SelectSubset<T, notesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Notes and returns the data saved in the database.
     * @param {notesCreateManyAndReturnArgs} args - Arguments to create many Notes.
     * @example
     * // Create many Notes
     * const notes = await prisma.notes.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Notes and only return the `id`
     * const notesWithIdOnly = await prisma.notes.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends notesCreateManyAndReturnArgs>(args?: SelectSubset<T, notesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$notesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Notes.
     * @param {notesDeleteArgs} args - Arguments to delete one Notes.
     * @example
     * // Delete one Notes
     * const Notes = await prisma.notes.delete({
     *   where: {
     *     // ... filter to delete one Notes
     *   }
     * })
     * 
     */
    delete<T extends notesDeleteArgs>(args: SelectSubset<T, notesDeleteArgs<ExtArgs>>): Prisma__notesClient<$Result.GetResult<Prisma.$notesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Notes.
     * @param {notesUpdateArgs} args - Arguments to update one Notes.
     * @example
     * // Update one Notes
     * const notes = await prisma.notes.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends notesUpdateArgs>(args: SelectSubset<T, notesUpdateArgs<ExtArgs>>): Prisma__notesClient<$Result.GetResult<Prisma.$notesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Notes.
     * @param {notesDeleteManyArgs} args - Arguments to filter Notes to delete.
     * @example
     * // Delete a few Notes
     * const { count } = await prisma.notes.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends notesDeleteManyArgs>(args?: SelectSubset<T, notesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notes
     * const notes = await prisma.notes.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends notesUpdateManyArgs>(args: SelectSubset<T, notesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notes and returns the data updated in the database.
     * @param {notesUpdateManyAndReturnArgs} args - Arguments to update many Notes.
     * @example
     * // Update many Notes
     * const notes = await prisma.notes.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Notes and only return the `id`
     * const notesWithIdOnly = await prisma.notes.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends notesUpdateManyAndReturnArgs>(args: SelectSubset<T, notesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$notesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Notes.
     * @param {notesUpsertArgs} args - Arguments to update or create a Notes.
     * @example
     * // Update or create a Notes
     * const notes = await prisma.notes.upsert({
     *   create: {
     *     // ... data to create a Notes
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notes we want to update
     *   }
     * })
     */
    upsert<T extends notesUpsertArgs>(args: SelectSubset<T, notesUpsertArgs<ExtArgs>>): Prisma__notesClient<$Result.GetResult<Prisma.$notesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Notes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notesCountArgs} args - Arguments to filter Notes to count.
     * @example
     * // Count the number of Notes
     * const count = await prisma.notes.count({
     *   where: {
     *     // ... the filter for the Notes we want to count
     *   }
     * })
    **/
    count<T extends notesCountArgs>(
      args?: Subset<T, notesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotesAggregateArgs>(args: Subset<T, NotesAggregateArgs>): Prisma.PrismaPromise<GetNotesAggregateType<T>>

    /**
     * Group by Notes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends notesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: notesGroupByArgs['orderBy'] }
        : { orderBy?: notesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, notesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the notes model
   */
  readonly fields: notesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for notes.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__notesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends notes$usersArgs<ExtArgs> = {}>(args?: Subset<T, notes$usersArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the notes model
   */
  interface notesFieldRefs {
    readonly id: FieldRef<"notes", 'Int'>
    readonly title: FieldRef<"notes", 'String'>
    readonly content: FieldRef<"notes", 'String'>
    readonly subject: FieldRef<"notes", 'String'>
    readonly class: FieldRef<"notes", 'String'>
    readonly section: FieldRef<"notes", 'String'>
    readonly created_by: FieldRef<"notes", 'Int'>
    readonly files: FieldRef<"notes", 'String'>
    readonly created_at: FieldRef<"notes", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * notes findUnique
   */
  export type notesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notes
     */
    select?: notesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notes
     */
    omit?: notesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notesInclude<ExtArgs> | null
    /**
     * Filter, which notes to fetch.
     */
    where: notesWhereUniqueInput
  }

  /**
   * notes findUniqueOrThrow
   */
  export type notesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notes
     */
    select?: notesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notes
     */
    omit?: notesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notesInclude<ExtArgs> | null
    /**
     * Filter, which notes to fetch.
     */
    where: notesWhereUniqueInput
  }

  /**
   * notes findFirst
   */
  export type notesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notes
     */
    select?: notesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notes
     */
    omit?: notesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notesInclude<ExtArgs> | null
    /**
     * Filter, which notes to fetch.
     */
    where?: notesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of notes to fetch.
     */
    orderBy?: notesOrderByWithRelationInput | notesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for notes.
     */
    cursor?: notesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` notes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` notes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of notes.
     */
    distinct?: NotesScalarFieldEnum | NotesScalarFieldEnum[]
  }

  /**
   * notes findFirstOrThrow
   */
  export type notesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notes
     */
    select?: notesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notes
     */
    omit?: notesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notesInclude<ExtArgs> | null
    /**
     * Filter, which notes to fetch.
     */
    where?: notesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of notes to fetch.
     */
    orderBy?: notesOrderByWithRelationInput | notesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for notes.
     */
    cursor?: notesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` notes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` notes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of notes.
     */
    distinct?: NotesScalarFieldEnum | NotesScalarFieldEnum[]
  }

  /**
   * notes findMany
   */
  export type notesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notes
     */
    select?: notesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notes
     */
    omit?: notesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notesInclude<ExtArgs> | null
    /**
     * Filter, which notes to fetch.
     */
    where?: notesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of notes to fetch.
     */
    orderBy?: notesOrderByWithRelationInput | notesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing notes.
     */
    cursor?: notesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` notes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` notes.
     */
    skip?: number
    distinct?: NotesScalarFieldEnum | NotesScalarFieldEnum[]
  }

  /**
   * notes create
   */
  export type notesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notes
     */
    select?: notesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notes
     */
    omit?: notesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notesInclude<ExtArgs> | null
    /**
     * The data needed to create a notes.
     */
    data: XOR<notesCreateInput, notesUncheckedCreateInput>
  }

  /**
   * notes createMany
   */
  export type notesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many notes.
     */
    data: notesCreateManyInput | notesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * notes createManyAndReturn
   */
  export type notesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notes
     */
    select?: notesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the notes
     */
    omit?: notesOmit<ExtArgs> | null
    /**
     * The data used to create many notes.
     */
    data: notesCreateManyInput | notesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * notes update
   */
  export type notesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notes
     */
    select?: notesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notes
     */
    omit?: notesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notesInclude<ExtArgs> | null
    /**
     * The data needed to update a notes.
     */
    data: XOR<notesUpdateInput, notesUncheckedUpdateInput>
    /**
     * Choose, which notes to update.
     */
    where: notesWhereUniqueInput
  }

  /**
   * notes updateMany
   */
  export type notesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update notes.
     */
    data: XOR<notesUpdateManyMutationInput, notesUncheckedUpdateManyInput>
    /**
     * Filter which notes to update
     */
    where?: notesWhereInput
    /**
     * Limit how many notes to update.
     */
    limit?: number
  }

  /**
   * notes updateManyAndReturn
   */
  export type notesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notes
     */
    select?: notesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the notes
     */
    omit?: notesOmit<ExtArgs> | null
    /**
     * The data used to update notes.
     */
    data: XOR<notesUpdateManyMutationInput, notesUncheckedUpdateManyInput>
    /**
     * Filter which notes to update
     */
    where?: notesWhereInput
    /**
     * Limit how many notes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * notes upsert
   */
  export type notesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notes
     */
    select?: notesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notes
     */
    omit?: notesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notesInclude<ExtArgs> | null
    /**
     * The filter to search for the notes to update in case it exists.
     */
    where: notesWhereUniqueInput
    /**
     * In case the notes found by the `where` argument doesn't exist, create a new notes with this data.
     */
    create: XOR<notesCreateInput, notesUncheckedCreateInput>
    /**
     * In case the notes was found with the provided `where` argument, update it with this data.
     */
    update: XOR<notesUpdateInput, notesUncheckedUpdateInput>
  }

  /**
   * notes delete
   */
  export type notesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notes
     */
    select?: notesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notes
     */
    omit?: notesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notesInclude<ExtArgs> | null
    /**
     * Filter which notes to delete.
     */
    where: notesWhereUniqueInput
  }

  /**
   * notes deleteMany
   */
  export type notesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which notes to delete
     */
    where?: notesWhereInput
    /**
     * Limit how many notes to delete.
     */
    limit?: number
  }

  /**
   * notes.users
   */
  export type notes$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    where?: usersWhereInput
  }

  /**
   * notes without action
   */
  export type notesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notes
     */
    select?: notesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notes
     */
    omit?: notesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notesInclude<ExtArgs> | null
  }


  /**
   * Model notices
   */

  export type AggregateNotices = {
    _count: NoticesCountAggregateOutputType | null
    _avg: NoticesAvgAggregateOutputType | null
    _sum: NoticesSumAggregateOutputType | null
    _min: NoticesMinAggregateOutputType | null
    _max: NoticesMaxAggregateOutputType | null
  }

  export type NoticesAvgAggregateOutputType = {
    id: number | null
    created_by: number | null
  }

  export type NoticesSumAggregateOutputType = {
    id: number | null
    created_by: number | null
  }

  export type NoticesMinAggregateOutputType = {
    id: number | null
    title: string | null
    content: string | null
    created_at: Date | null
    created_by: number | null
    target_role: string | null
  }

  export type NoticesMaxAggregateOutputType = {
    id: number | null
    title: string | null
    content: string | null
    created_at: Date | null
    created_by: number | null
    target_role: string | null
  }

  export type NoticesCountAggregateOutputType = {
    id: number
    title: number
    content: number
    created_at: number
    created_by: number
    target_role: number
    _all: number
  }


  export type NoticesAvgAggregateInputType = {
    id?: true
    created_by?: true
  }

  export type NoticesSumAggregateInputType = {
    id?: true
    created_by?: true
  }

  export type NoticesMinAggregateInputType = {
    id?: true
    title?: true
    content?: true
    created_at?: true
    created_by?: true
    target_role?: true
  }

  export type NoticesMaxAggregateInputType = {
    id?: true
    title?: true
    content?: true
    created_at?: true
    created_by?: true
    target_role?: true
  }

  export type NoticesCountAggregateInputType = {
    id?: true
    title?: true
    content?: true
    created_at?: true
    created_by?: true
    target_role?: true
    _all?: true
  }

  export type NoticesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which notices to aggregate.
     */
    where?: noticesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of notices to fetch.
     */
    orderBy?: noticesOrderByWithRelationInput | noticesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: noticesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` notices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` notices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned notices
    **/
    _count?: true | NoticesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NoticesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NoticesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NoticesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NoticesMaxAggregateInputType
  }

  export type GetNoticesAggregateType<T extends NoticesAggregateArgs> = {
        [P in keyof T & keyof AggregateNotices]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotices[P]>
      : GetScalarType<T[P], AggregateNotices[P]>
  }




  export type noticesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: noticesWhereInput
    orderBy?: noticesOrderByWithAggregationInput | noticesOrderByWithAggregationInput[]
    by: NoticesScalarFieldEnum[] | NoticesScalarFieldEnum
    having?: noticesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NoticesCountAggregateInputType | true
    _avg?: NoticesAvgAggregateInputType
    _sum?: NoticesSumAggregateInputType
    _min?: NoticesMinAggregateInputType
    _max?: NoticesMaxAggregateInputType
  }

  export type NoticesGroupByOutputType = {
    id: number
    title: string
    content: string
    created_at: Date | null
    created_by: number | null
    target_role: string
    _count: NoticesCountAggregateOutputType | null
    _avg: NoticesAvgAggregateOutputType | null
    _sum: NoticesSumAggregateOutputType | null
    _min: NoticesMinAggregateOutputType | null
    _max: NoticesMaxAggregateOutputType | null
  }

  type GetNoticesGroupByPayload<T extends noticesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NoticesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NoticesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NoticesGroupByOutputType[P]>
            : GetScalarType<T[P], NoticesGroupByOutputType[P]>
        }
      >
    >


  export type noticesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    content?: boolean
    created_at?: boolean
    created_by?: boolean
    target_role?: boolean
    users?: boolean | notices$usersArgs<ExtArgs>
  }, ExtArgs["result"]["notices"]>

  export type noticesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    content?: boolean
    created_at?: boolean
    created_by?: boolean
    target_role?: boolean
    users?: boolean | notices$usersArgs<ExtArgs>
  }, ExtArgs["result"]["notices"]>

  export type noticesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    content?: boolean
    created_at?: boolean
    created_by?: boolean
    target_role?: boolean
    users?: boolean | notices$usersArgs<ExtArgs>
  }, ExtArgs["result"]["notices"]>

  export type noticesSelectScalar = {
    id?: boolean
    title?: boolean
    content?: boolean
    created_at?: boolean
    created_by?: boolean
    target_role?: boolean
  }

  export type noticesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "content" | "created_at" | "created_by" | "target_role", ExtArgs["result"]["notices"]>
  export type noticesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | notices$usersArgs<ExtArgs>
  }
  export type noticesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | notices$usersArgs<ExtArgs>
  }
  export type noticesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | notices$usersArgs<ExtArgs>
  }

  export type $noticesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "notices"
    objects: {
      users: Prisma.$usersPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      title: string
      content: string
      created_at: Date | null
      created_by: number | null
      target_role: string
    }, ExtArgs["result"]["notices"]>
    composites: {}
  }

  type noticesGetPayload<S extends boolean | null | undefined | noticesDefaultArgs> = $Result.GetResult<Prisma.$noticesPayload, S>

  type noticesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<noticesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NoticesCountAggregateInputType | true
    }

  export interface noticesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['notices'], meta: { name: 'notices' } }
    /**
     * Find zero or one Notices that matches the filter.
     * @param {noticesFindUniqueArgs} args - Arguments to find a Notices
     * @example
     * // Get one Notices
     * const notices = await prisma.notices.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends noticesFindUniqueArgs>(args: SelectSubset<T, noticesFindUniqueArgs<ExtArgs>>): Prisma__noticesClient<$Result.GetResult<Prisma.$noticesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Notices that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {noticesFindUniqueOrThrowArgs} args - Arguments to find a Notices
     * @example
     * // Get one Notices
     * const notices = await prisma.notices.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends noticesFindUniqueOrThrowArgs>(args: SelectSubset<T, noticesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__noticesClient<$Result.GetResult<Prisma.$noticesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {noticesFindFirstArgs} args - Arguments to find a Notices
     * @example
     * // Get one Notices
     * const notices = await prisma.notices.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends noticesFindFirstArgs>(args?: SelectSubset<T, noticesFindFirstArgs<ExtArgs>>): Prisma__noticesClient<$Result.GetResult<Prisma.$noticesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notices that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {noticesFindFirstOrThrowArgs} args - Arguments to find a Notices
     * @example
     * // Get one Notices
     * const notices = await prisma.notices.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends noticesFindFirstOrThrowArgs>(args?: SelectSubset<T, noticesFindFirstOrThrowArgs<ExtArgs>>): Prisma__noticesClient<$Result.GetResult<Prisma.$noticesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Notices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {noticesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notices
     * const notices = await prisma.notices.findMany()
     * 
     * // Get first 10 Notices
     * const notices = await prisma.notices.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const noticesWithIdOnly = await prisma.notices.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends noticesFindManyArgs>(args?: SelectSubset<T, noticesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$noticesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Notices.
     * @param {noticesCreateArgs} args - Arguments to create a Notices.
     * @example
     * // Create one Notices
     * const Notices = await prisma.notices.create({
     *   data: {
     *     // ... data to create a Notices
     *   }
     * })
     * 
     */
    create<T extends noticesCreateArgs>(args: SelectSubset<T, noticesCreateArgs<ExtArgs>>): Prisma__noticesClient<$Result.GetResult<Prisma.$noticesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Notices.
     * @param {noticesCreateManyArgs} args - Arguments to create many Notices.
     * @example
     * // Create many Notices
     * const notices = await prisma.notices.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends noticesCreateManyArgs>(args?: SelectSubset<T, noticesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Notices and returns the data saved in the database.
     * @param {noticesCreateManyAndReturnArgs} args - Arguments to create many Notices.
     * @example
     * // Create many Notices
     * const notices = await prisma.notices.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Notices and only return the `id`
     * const noticesWithIdOnly = await prisma.notices.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends noticesCreateManyAndReturnArgs>(args?: SelectSubset<T, noticesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$noticesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Notices.
     * @param {noticesDeleteArgs} args - Arguments to delete one Notices.
     * @example
     * // Delete one Notices
     * const Notices = await prisma.notices.delete({
     *   where: {
     *     // ... filter to delete one Notices
     *   }
     * })
     * 
     */
    delete<T extends noticesDeleteArgs>(args: SelectSubset<T, noticesDeleteArgs<ExtArgs>>): Prisma__noticesClient<$Result.GetResult<Prisma.$noticesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Notices.
     * @param {noticesUpdateArgs} args - Arguments to update one Notices.
     * @example
     * // Update one Notices
     * const notices = await prisma.notices.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends noticesUpdateArgs>(args: SelectSubset<T, noticesUpdateArgs<ExtArgs>>): Prisma__noticesClient<$Result.GetResult<Prisma.$noticesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Notices.
     * @param {noticesDeleteManyArgs} args - Arguments to filter Notices to delete.
     * @example
     * // Delete a few Notices
     * const { count } = await prisma.notices.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends noticesDeleteManyArgs>(args?: SelectSubset<T, noticesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {noticesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notices
     * const notices = await prisma.notices.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends noticesUpdateManyArgs>(args: SelectSubset<T, noticesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notices and returns the data updated in the database.
     * @param {noticesUpdateManyAndReturnArgs} args - Arguments to update many Notices.
     * @example
     * // Update many Notices
     * const notices = await prisma.notices.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Notices and only return the `id`
     * const noticesWithIdOnly = await prisma.notices.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends noticesUpdateManyAndReturnArgs>(args: SelectSubset<T, noticesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$noticesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Notices.
     * @param {noticesUpsertArgs} args - Arguments to update or create a Notices.
     * @example
     * // Update or create a Notices
     * const notices = await prisma.notices.upsert({
     *   create: {
     *     // ... data to create a Notices
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notices we want to update
     *   }
     * })
     */
    upsert<T extends noticesUpsertArgs>(args: SelectSubset<T, noticesUpsertArgs<ExtArgs>>): Prisma__noticesClient<$Result.GetResult<Prisma.$noticesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Notices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {noticesCountArgs} args - Arguments to filter Notices to count.
     * @example
     * // Count the number of Notices
     * const count = await prisma.notices.count({
     *   where: {
     *     // ... the filter for the Notices we want to count
     *   }
     * })
    **/
    count<T extends noticesCountArgs>(
      args?: Subset<T, noticesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NoticesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoticesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NoticesAggregateArgs>(args: Subset<T, NoticesAggregateArgs>): Prisma.PrismaPromise<GetNoticesAggregateType<T>>

    /**
     * Group by Notices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {noticesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends noticesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: noticesGroupByArgs['orderBy'] }
        : { orderBy?: noticesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, noticesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNoticesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the notices model
   */
  readonly fields: noticesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for notices.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__noticesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends notices$usersArgs<ExtArgs> = {}>(args?: Subset<T, notices$usersArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the notices model
   */
  interface noticesFieldRefs {
    readonly id: FieldRef<"notices", 'Int'>
    readonly title: FieldRef<"notices", 'String'>
    readonly content: FieldRef<"notices", 'String'>
    readonly created_at: FieldRef<"notices", 'DateTime'>
    readonly created_by: FieldRef<"notices", 'Int'>
    readonly target_role: FieldRef<"notices", 'String'>
  }
    

  // Custom InputTypes
  /**
   * notices findUnique
   */
  export type noticesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notices
     */
    select?: noticesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notices
     */
    omit?: noticesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: noticesInclude<ExtArgs> | null
    /**
     * Filter, which notices to fetch.
     */
    where: noticesWhereUniqueInput
  }

  /**
   * notices findUniqueOrThrow
   */
  export type noticesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notices
     */
    select?: noticesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notices
     */
    omit?: noticesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: noticesInclude<ExtArgs> | null
    /**
     * Filter, which notices to fetch.
     */
    where: noticesWhereUniqueInput
  }

  /**
   * notices findFirst
   */
  export type noticesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notices
     */
    select?: noticesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notices
     */
    omit?: noticesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: noticesInclude<ExtArgs> | null
    /**
     * Filter, which notices to fetch.
     */
    where?: noticesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of notices to fetch.
     */
    orderBy?: noticesOrderByWithRelationInput | noticesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for notices.
     */
    cursor?: noticesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` notices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` notices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of notices.
     */
    distinct?: NoticesScalarFieldEnum | NoticesScalarFieldEnum[]
  }

  /**
   * notices findFirstOrThrow
   */
  export type noticesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notices
     */
    select?: noticesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notices
     */
    omit?: noticesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: noticesInclude<ExtArgs> | null
    /**
     * Filter, which notices to fetch.
     */
    where?: noticesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of notices to fetch.
     */
    orderBy?: noticesOrderByWithRelationInput | noticesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for notices.
     */
    cursor?: noticesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` notices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` notices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of notices.
     */
    distinct?: NoticesScalarFieldEnum | NoticesScalarFieldEnum[]
  }

  /**
   * notices findMany
   */
  export type noticesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notices
     */
    select?: noticesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notices
     */
    omit?: noticesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: noticesInclude<ExtArgs> | null
    /**
     * Filter, which notices to fetch.
     */
    where?: noticesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of notices to fetch.
     */
    orderBy?: noticesOrderByWithRelationInput | noticesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing notices.
     */
    cursor?: noticesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` notices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` notices.
     */
    skip?: number
    distinct?: NoticesScalarFieldEnum | NoticesScalarFieldEnum[]
  }

  /**
   * notices create
   */
  export type noticesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notices
     */
    select?: noticesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notices
     */
    omit?: noticesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: noticesInclude<ExtArgs> | null
    /**
     * The data needed to create a notices.
     */
    data: XOR<noticesCreateInput, noticesUncheckedCreateInput>
  }

  /**
   * notices createMany
   */
  export type noticesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many notices.
     */
    data: noticesCreateManyInput | noticesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * notices createManyAndReturn
   */
  export type noticesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notices
     */
    select?: noticesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the notices
     */
    omit?: noticesOmit<ExtArgs> | null
    /**
     * The data used to create many notices.
     */
    data: noticesCreateManyInput | noticesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: noticesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * notices update
   */
  export type noticesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notices
     */
    select?: noticesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notices
     */
    omit?: noticesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: noticesInclude<ExtArgs> | null
    /**
     * The data needed to update a notices.
     */
    data: XOR<noticesUpdateInput, noticesUncheckedUpdateInput>
    /**
     * Choose, which notices to update.
     */
    where: noticesWhereUniqueInput
  }

  /**
   * notices updateMany
   */
  export type noticesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update notices.
     */
    data: XOR<noticesUpdateManyMutationInput, noticesUncheckedUpdateManyInput>
    /**
     * Filter which notices to update
     */
    where?: noticesWhereInput
    /**
     * Limit how many notices to update.
     */
    limit?: number
  }

  /**
   * notices updateManyAndReturn
   */
  export type noticesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notices
     */
    select?: noticesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the notices
     */
    omit?: noticesOmit<ExtArgs> | null
    /**
     * The data used to update notices.
     */
    data: XOR<noticesUpdateManyMutationInput, noticesUncheckedUpdateManyInput>
    /**
     * Filter which notices to update
     */
    where?: noticesWhereInput
    /**
     * Limit how many notices to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: noticesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * notices upsert
   */
  export type noticesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notices
     */
    select?: noticesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notices
     */
    omit?: noticesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: noticesInclude<ExtArgs> | null
    /**
     * The filter to search for the notices to update in case it exists.
     */
    where: noticesWhereUniqueInput
    /**
     * In case the notices found by the `where` argument doesn't exist, create a new notices with this data.
     */
    create: XOR<noticesCreateInput, noticesUncheckedCreateInput>
    /**
     * In case the notices was found with the provided `where` argument, update it with this data.
     */
    update: XOR<noticesUpdateInput, noticesUncheckedUpdateInput>
  }

  /**
   * notices delete
   */
  export type noticesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notices
     */
    select?: noticesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notices
     */
    omit?: noticesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: noticesInclude<ExtArgs> | null
    /**
     * Filter which notices to delete.
     */
    where: noticesWhereUniqueInput
  }

  /**
   * notices deleteMany
   */
  export type noticesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which notices to delete
     */
    where?: noticesWhereInput
    /**
     * Limit how many notices to delete.
     */
    limit?: number
  }

  /**
   * notices.users
   */
  export type notices$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    where?: usersWhereInput
  }

  /**
   * notices without action
   */
  export type noticesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notices
     */
    select?: noticesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notices
     */
    omit?: noticesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: noticesInclude<ExtArgs> | null
  }


  /**
   * Model performance
   */

  export type AggregatePerformance = {
    _count: PerformanceCountAggregateOutputType | null
    _avg: PerformanceAvgAggregateOutputType | null
    _sum: PerformanceSumAggregateOutputType | null
    _min: PerformanceMinAggregateOutputType | null
    _max: PerformanceMaxAggregateOutputType | null
  }

  export type PerformanceAvgAggregateOutputType = {
    id: number | null
    class_teacher: number | null
    class_performance: number | null
    exam_id: number | null
  }

  export type PerformanceSumAggregateOutputType = {
    id: number | null
    class_teacher: number | null
    class_performance: number | null
    exam_id: number | null
  }

  export type PerformanceMinAggregateOutputType = {
    id: number | null
    class: string | null
    section: string | null
    class_teacher: number | null
    class_performance: number | null
    exam_id: number | null
  }

  export type PerformanceMaxAggregateOutputType = {
    id: number | null
    class: string | null
    section: string | null
    class_teacher: number | null
    class_performance: number | null
    exam_id: number | null
  }

  export type PerformanceCountAggregateOutputType = {
    id: number
    class: number
    section: number
    class_teacher: number
    class_performance: number
    exam_id: number
    _all: number
  }


  export type PerformanceAvgAggregateInputType = {
    id?: true
    class_teacher?: true
    class_performance?: true
    exam_id?: true
  }

  export type PerformanceSumAggregateInputType = {
    id?: true
    class_teacher?: true
    class_performance?: true
    exam_id?: true
  }

  export type PerformanceMinAggregateInputType = {
    id?: true
    class?: true
    section?: true
    class_teacher?: true
    class_performance?: true
    exam_id?: true
  }

  export type PerformanceMaxAggregateInputType = {
    id?: true
    class?: true
    section?: true
    class_teacher?: true
    class_performance?: true
    exam_id?: true
  }

  export type PerformanceCountAggregateInputType = {
    id?: true
    class?: true
    section?: true
    class_teacher?: true
    class_performance?: true
    exam_id?: true
    _all?: true
  }

  export type PerformanceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which performance to aggregate.
     */
    where?: performanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of performances to fetch.
     */
    orderBy?: performanceOrderByWithRelationInput | performanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: performanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` performances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` performances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned performances
    **/
    _count?: true | PerformanceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PerformanceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PerformanceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PerformanceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PerformanceMaxAggregateInputType
  }

  export type GetPerformanceAggregateType<T extends PerformanceAggregateArgs> = {
        [P in keyof T & keyof AggregatePerformance]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePerformance[P]>
      : GetScalarType<T[P], AggregatePerformance[P]>
  }




  export type performanceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: performanceWhereInput
    orderBy?: performanceOrderByWithAggregationInput | performanceOrderByWithAggregationInput[]
    by: PerformanceScalarFieldEnum[] | PerformanceScalarFieldEnum
    having?: performanceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PerformanceCountAggregateInputType | true
    _avg?: PerformanceAvgAggregateInputType
    _sum?: PerformanceSumAggregateInputType
    _min?: PerformanceMinAggregateInputType
    _max?: PerformanceMaxAggregateInputType
  }

  export type PerformanceGroupByOutputType = {
    id: number
    class: string
    section: string
    class_teacher: number | null
    class_performance: number | null
    exam_id: number | null
    _count: PerformanceCountAggregateOutputType | null
    _avg: PerformanceAvgAggregateOutputType | null
    _sum: PerformanceSumAggregateOutputType | null
    _min: PerformanceMinAggregateOutputType | null
    _max: PerformanceMaxAggregateOutputType | null
  }

  type GetPerformanceGroupByPayload<T extends performanceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PerformanceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PerformanceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PerformanceGroupByOutputType[P]>
            : GetScalarType<T[P], PerformanceGroupByOutputType[P]>
        }
      >
    >


  export type performanceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    class?: boolean
    section?: boolean
    class_teacher?: boolean
    class_performance?: boolean
    exam_id?: boolean
    exams?: boolean | performance$examsArgs<ExtArgs>
    student_performance?: boolean | performance$student_performanceArgs<ExtArgs>
    teachers?: boolean | performance$teachersArgs<ExtArgs>
  }, ExtArgs["result"]["performance"]>

  export type performanceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    class?: boolean
    section?: boolean
    class_teacher?: boolean
    class_performance?: boolean
    exam_id?: boolean
    exams?: boolean | performance$examsArgs<ExtArgs>
    student_performance?: boolean | performance$student_performanceArgs<ExtArgs>
    teachers?: boolean | performance$teachersArgs<ExtArgs>
  }, ExtArgs["result"]["performance"]>

  export type performanceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    class?: boolean
    section?: boolean
    class_teacher?: boolean
    class_performance?: boolean
    exam_id?: boolean
    exams?: boolean | performance$examsArgs<ExtArgs>
    student_performance?: boolean | performance$student_performanceArgs<ExtArgs>
    teachers?: boolean | performance$teachersArgs<ExtArgs>
  }, ExtArgs["result"]["performance"]>

  export type performanceSelectScalar = {
    id?: boolean
    class?: boolean
    section?: boolean
    class_teacher?: boolean
    class_performance?: boolean
    exam_id?: boolean
  }

  export type performanceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "class" | "section" | "class_teacher" | "class_performance" | "exam_id", ExtArgs["result"]["performance"]>
  export type performanceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    exams?: boolean | performance$examsArgs<ExtArgs>
    student_performance?: boolean | performance$student_performanceArgs<ExtArgs>
    teachers?: boolean | performance$teachersArgs<ExtArgs>
  }
  export type performanceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    exams?: boolean | performance$examsArgs<ExtArgs>
    student_performance?: boolean | performance$student_performanceArgs<ExtArgs>
    teachers?: boolean | performance$teachersArgs<ExtArgs>
  }
  export type performanceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    exams?: boolean | performance$examsArgs<ExtArgs>
    student_performance?: boolean | performance$student_performanceArgs<ExtArgs>
    teachers?: boolean | performance$teachersArgs<ExtArgs>
  }

  export type $performancePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "performance"
    objects: {
      exams: Prisma.$examsPayload<ExtArgs> | null
      student_performance: Prisma.$student_performancePayload<ExtArgs> | null
      teachers: Prisma.$teachersPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      class: string
      section: string
      class_teacher: number | null
      class_performance: number | null
      exam_id: number | null
    }, ExtArgs["result"]["performance"]>
    composites: {}
  }

  type performanceGetPayload<S extends boolean | null | undefined | performanceDefaultArgs> = $Result.GetResult<Prisma.$performancePayload, S>

  type performanceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<performanceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PerformanceCountAggregateInputType | true
    }

  export interface performanceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['performance'], meta: { name: 'performance' } }
    /**
     * Find zero or one Performance that matches the filter.
     * @param {performanceFindUniqueArgs} args - Arguments to find a Performance
     * @example
     * // Get one Performance
     * const performance = await prisma.performance.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends performanceFindUniqueArgs>(args: SelectSubset<T, performanceFindUniqueArgs<ExtArgs>>): Prisma__performanceClient<$Result.GetResult<Prisma.$performancePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Performance that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {performanceFindUniqueOrThrowArgs} args - Arguments to find a Performance
     * @example
     * // Get one Performance
     * const performance = await prisma.performance.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends performanceFindUniqueOrThrowArgs>(args: SelectSubset<T, performanceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__performanceClient<$Result.GetResult<Prisma.$performancePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Performance that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {performanceFindFirstArgs} args - Arguments to find a Performance
     * @example
     * // Get one Performance
     * const performance = await prisma.performance.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends performanceFindFirstArgs>(args?: SelectSubset<T, performanceFindFirstArgs<ExtArgs>>): Prisma__performanceClient<$Result.GetResult<Prisma.$performancePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Performance that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {performanceFindFirstOrThrowArgs} args - Arguments to find a Performance
     * @example
     * // Get one Performance
     * const performance = await prisma.performance.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends performanceFindFirstOrThrowArgs>(args?: SelectSubset<T, performanceFindFirstOrThrowArgs<ExtArgs>>): Prisma__performanceClient<$Result.GetResult<Prisma.$performancePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Performances that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {performanceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Performances
     * const performances = await prisma.performance.findMany()
     * 
     * // Get first 10 Performances
     * const performances = await prisma.performance.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const performanceWithIdOnly = await prisma.performance.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends performanceFindManyArgs>(args?: SelectSubset<T, performanceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$performancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Performance.
     * @param {performanceCreateArgs} args - Arguments to create a Performance.
     * @example
     * // Create one Performance
     * const Performance = await prisma.performance.create({
     *   data: {
     *     // ... data to create a Performance
     *   }
     * })
     * 
     */
    create<T extends performanceCreateArgs>(args: SelectSubset<T, performanceCreateArgs<ExtArgs>>): Prisma__performanceClient<$Result.GetResult<Prisma.$performancePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Performances.
     * @param {performanceCreateManyArgs} args - Arguments to create many Performances.
     * @example
     * // Create many Performances
     * const performance = await prisma.performance.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends performanceCreateManyArgs>(args?: SelectSubset<T, performanceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Performances and returns the data saved in the database.
     * @param {performanceCreateManyAndReturnArgs} args - Arguments to create many Performances.
     * @example
     * // Create many Performances
     * const performance = await prisma.performance.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Performances and only return the `id`
     * const performanceWithIdOnly = await prisma.performance.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends performanceCreateManyAndReturnArgs>(args?: SelectSubset<T, performanceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$performancePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Performance.
     * @param {performanceDeleteArgs} args - Arguments to delete one Performance.
     * @example
     * // Delete one Performance
     * const Performance = await prisma.performance.delete({
     *   where: {
     *     // ... filter to delete one Performance
     *   }
     * })
     * 
     */
    delete<T extends performanceDeleteArgs>(args: SelectSubset<T, performanceDeleteArgs<ExtArgs>>): Prisma__performanceClient<$Result.GetResult<Prisma.$performancePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Performance.
     * @param {performanceUpdateArgs} args - Arguments to update one Performance.
     * @example
     * // Update one Performance
     * const performance = await prisma.performance.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends performanceUpdateArgs>(args: SelectSubset<T, performanceUpdateArgs<ExtArgs>>): Prisma__performanceClient<$Result.GetResult<Prisma.$performancePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Performances.
     * @param {performanceDeleteManyArgs} args - Arguments to filter Performances to delete.
     * @example
     * // Delete a few Performances
     * const { count } = await prisma.performance.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends performanceDeleteManyArgs>(args?: SelectSubset<T, performanceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Performances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {performanceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Performances
     * const performance = await prisma.performance.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends performanceUpdateManyArgs>(args: SelectSubset<T, performanceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Performances and returns the data updated in the database.
     * @param {performanceUpdateManyAndReturnArgs} args - Arguments to update many Performances.
     * @example
     * // Update many Performances
     * const performance = await prisma.performance.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Performances and only return the `id`
     * const performanceWithIdOnly = await prisma.performance.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends performanceUpdateManyAndReturnArgs>(args: SelectSubset<T, performanceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$performancePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Performance.
     * @param {performanceUpsertArgs} args - Arguments to update or create a Performance.
     * @example
     * // Update or create a Performance
     * const performance = await prisma.performance.upsert({
     *   create: {
     *     // ... data to create a Performance
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Performance we want to update
     *   }
     * })
     */
    upsert<T extends performanceUpsertArgs>(args: SelectSubset<T, performanceUpsertArgs<ExtArgs>>): Prisma__performanceClient<$Result.GetResult<Prisma.$performancePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Performances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {performanceCountArgs} args - Arguments to filter Performances to count.
     * @example
     * // Count the number of Performances
     * const count = await prisma.performance.count({
     *   where: {
     *     // ... the filter for the Performances we want to count
     *   }
     * })
    **/
    count<T extends performanceCountArgs>(
      args?: Subset<T, performanceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PerformanceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Performance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerformanceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PerformanceAggregateArgs>(args: Subset<T, PerformanceAggregateArgs>): Prisma.PrismaPromise<GetPerformanceAggregateType<T>>

    /**
     * Group by Performance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {performanceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends performanceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: performanceGroupByArgs['orderBy'] }
        : { orderBy?: performanceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, performanceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPerformanceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the performance model
   */
  readonly fields: performanceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for performance.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__performanceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    exams<T extends performance$examsArgs<ExtArgs> = {}>(args?: Subset<T, performance$examsArgs<ExtArgs>>): Prisma__examsClient<$Result.GetResult<Prisma.$examsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    student_performance<T extends performance$student_performanceArgs<ExtArgs> = {}>(args?: Subset<T, performance$student_performanceArgs<ExtArgs>>): Prisma__student_performanceClient<$Result.GetResult<Prisma.$student_performancePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    teachers<T extends performance$teachersArgs<ExtArgs> = {}>(args?: Subset<T, performance$teachersArgs<ExtArgs>>): Prisma__teachersClient<$Result.GetResult<Prisma.$teachersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the performance model
   */
  interface performanceFieldRefs {
    readonly id: FieldRef<"performance", 'Int'>
    readonly class: FieldRef<"performance", 'String'>
    readonly section: FieldRef<"performance", 'String'>
    readonly class_teacher: FieldRef<"performance", 'Int'>
    readonly class_performance: FieldRef<"performance", 'Int'>
    readonly exam_id: FieldRef<"performance", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * performance findUnique
   */
  export type performanceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the performance
     */
    select?: performanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the performance
     */
    omit?: performanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: performanceInclude<ExtArgs> | null
    /**
     * Filter, which performance to fetch.
     */
    where: performanceWhereUniqueInput
  }

  /**
   * performance findUniqueOrThrow
   */
  export type performanceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the performance
     */
    select?: performanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the performance
     */
    omit?: performanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: performanceInclude<ExtArgs> | null
    /**
     * Filter, which performance to fetch.
     */
    where: performanceWhereUniqueInput
  }

  /**
   * performance findFirst
   */
  export type performanceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the performance
     */
    select?: performanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the performance
     */
    omit?: performanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: performanceInclude<ExtArgs> | null
    /**
     * Filter, which performance to fetch.
     */
    where?: performanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of performances to fetch.
     */
    orderBy?: performanceOrderByWithRelationInput | performanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for performances.
     */
    cursor?: performanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` performances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` performances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of performances.
     */
    distinct?: PerformanceScalarFieldEnum | PerformanceScalarFieldEnum[]
  }

  /**
   * performance findFirstOrThrow
   */
  export type performanceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the performance
     */
    select?: performanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the performance
     */
    omit?: performanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: performanceInclude<ExtArgs> | null
    /**
     * Filter, which performance to fetch.
     */
    where?: performanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of performances to fetch.
     */
    orderBy?: performanceOrderByWithRelationInput | performanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for performances.
     */
    cursor?: performanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` performances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` performances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of performances.
     */
    distinct?: PerformanceScalarFieldEnum | PerformanceScalarFieldEnum[]
  }

  /**
   * performance findMany
   */
  export type performanceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the performance
     */
    select?: performanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the performance
     */
    omit?: performanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: performanceInclude<ExtArgs> | null
    /**
     * Filter, which performances to fetch.
     */
    where?: performanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of performances to fetch.
     */
    orderBy?: performanceOrderByWithRelationInput | performanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing performances.
     */
    cursor?: performanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` performances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` performances.
     */
    skip?: number
    distinct?: PerformanceScalarFieldEnum | PerformanceScalarFieldEnum[]
  }

  /**
   * performance create
   */
  export type performanceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the performance
     */
    select?: performanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the performance
     */
    omit?: performanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: performanceInclude<ExtArgs> | null
    /**
     * The data needed to create a performance.
     */
    data: XOR<performanceCreateInput, performanceUncheckedCreateInput>
  }

  /**
   * performance createMany
   */
  export type performanceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many performances.
     */
    data: performanceCreateManyInput | performanceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * performance createManyAndReturn
   */
  export type performanceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the performance
     */
    select?: performanceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the performance
     */
    omit?: performanceOmit<ExtArgs> | null
    /**
     * The data used to create many performances.
     */
    data: performanceCreateManyInput | performanceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: performanceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * performance update
   */
  export type performanceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the performance
     */
    select?: performanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the performance
     */
    omit?: performanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: performanceInclude<ExtArgs> | null
    /**
     * The data needed to update a performance.
     */
    data: XOR<performanceUpdateInput, performanceUncheckedUpdateInput>
    /**
     * Choose, which performance to update.
     */
    where: performanceWhereUniqueInput
  }

  /**
   * performance updateMany
   */
  export type performanceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update performances.
     */
    data: XOR<performanceUpdateManyMutationInput, performanceUncheckedUpdateManyInput>
    /**
     * Filter which performances to update
     */
    where?: performanceWhereInput
    /**
     * Limit how many performances to update.
     */
    limit?: number
  }

  /**
   * performance updateManyAndReturn
   */
  export type performanceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the performance
     */
    select?: performanceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the performance
     */
    omit?: performanceOmit<ExtArgs> | null
    /**
     * The data used to update performances.
     */
    data: XOR<performanceUpdateManyMutationInput, performanceUncheckedUpdateManyInput>
    /**
     * Filter which performances to update
     */
    where?: performanceWhereInput
    /**
     * Limit how many performances to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: performanceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * performance upsert
   */
  export type performanceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the performance
     */
    select?: performanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the performance
     */
    omit?: performanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: performanceInclude<ExtArgs> | null
    /**
     * The filter to search for the performance to update in case it exists.
     */
    where: performanceWhereUniqueInput
    /**
     * In case the performance found by the `where` argument doesn't exist, create a new performance with this data.
     */
    create: XOR<performanceCreateInput, performanceUncheckedCreateInput>
    /**
     * In case the performance was found with the provided `where` argument, update it with this data.
     */
    update: XOR<performanceUpdateInput, performanceUncheckedUpdateInput>
  }

  /**
   * performance delete
   */
  export type performanceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the performance
     */
    select?: performanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the performance
     */
    omit?: performanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: performanceInclude<ExtArgs> | null
    /**
     * Filter which performance to delete.
     */
    where: performanceWhereUniqueInput
  }

  /**
   * performance deleteMany
   */
  export type performanceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which performances to delete
     */
    where?: performanceWhereInput
    /**
     * Limit how many performances to delete.
     */
    limit?: number
  }

  /**
   * performance.exams
   */
  export type performance$examsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the exams
     */
    select?: examsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the exams
     */
    omit?: examsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: examsInclude<ExtArgs> | null
    where?: examsWhereInput
  }

  /**
   * performance.student_performance
   */
  export type performance$student_performanceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student_performance
     */
    select?: student_performanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the student_performance
     */
    omit?: student_performanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: student_performanceInclude<ExtArgs> | null
    where?: student_performanceWhereInput
  }

  /**
   * performance.teachers
   */
  export type performance$teachersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the teachers
     */
    select?: teachersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the teachers
     */
    omit?: teachersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teachersInclude<ExtArgs> | null
    where?: teachersWhereInput
  }

  /**
   * performance without action
   */
  export type performanceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the performance
     */
    select?: performanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the performance
     */
    omit?: performanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: performanceInclude<ExtArgs> | null
  }


  /**
   * Model student_performance
   */

  export type AggregateStudent_performance = {
    _count: Student_performanceCountAggregateOutputType | null
    _avg: Student_performanceAvgAggregateOutputType | null
    _sum: Student_performanceSumAggregateOutputType | null
    _min: Student_performanceMinAggregateOutputType | null
    _max: Student_performanceMaxAggregateOutputType | null
  }

  export type Student_performanceAvgAggregateOutputType = {
    id: number | null
    student_id: number | null
    exam_id: number | null
    marks_obtained: Decimal | null
    total_marks: Decimal | null
  }

  export type Student_performanceSumAggregateOutputType = {
    id: number | null
    student_id: number | null
    exam_id: number | null
    marks_obtained: Decimal | null
    total_marks: Decimal | null
  }

  export type Student_performanceMinAggregateOutputType = {
    id: number | null
    student_id: number | null
    exam_id: number | null
    marks_obtained: Decimal | null
    total_marks: Decimal | null
  }

  export type Student_performanceMaxAggregateOutputType = {
    id: number | null
    student_id: number | null
    exam_id: number | null
    marks_obtained: Decimal | null
    total_marks: Decimal | null
  }

  export type Student_performanceCountAggregateOutputType = {
    id: number
    student_id: number
    exam_id: number
    marks_obtained: number
    total_marks: number
    _all: number
  }


  export type Student_performanceAvgAggregateInputType = {
    id?: true
    student_id?: true
    exam_id?: true
    marks_obtained?: true
    total_marks?: true
  }

  export type Student_performanceSumAggregateInputType = {
    id?: true
    student_id?: true
    exam_id?: true
    marks_obtained?: true
    total_marks?: true
  }

  export type Student_performanceMinAggregateInputType = {
    id?: true
    student_id?: true
    exam_id?: true
    marks_obtained?: true
    total_marks?: true
  }

  export type Student_performanceMaxAggregateInputType = {
    id?: true
    student_id?: true
    exam_id?: true
    marks_obtained?: true
    total_marks?: true
  }

  export type Student_performanceCountAggregateInputType = {
    id?: true
    student_id?: true
    exam_id?: true
    marks_obtained?: true
    total_marks?: true
    _all?: true
  }

  export type Student_performanceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which student_performance to aggregate.
     */
    where?: student_performanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of student_performances to fetch.
     */
    orderBy?: student_performanceOrderByWithRelationInput | student_performanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: student_performanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` student_performances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` student_performances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned student_performances
    **/
    _count?: true | Student_performanceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Student_performanceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Student_performanceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Student_performanceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Student_performanceMaxAggregateInputType
  }

  export type GetStudent_performanceAggregateType<T extends Student_performanceAggregateArgs> = {
        [P in keyof T & keyof AggregateStudent_performance]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStudent_performance[P]>
      : GetScalarType<T[P], AggregateStudent_performance[P]>
  }




  export type student_performanceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: student_performanceWhereInput
    orderBy?: student_performanceOrderByWithAggregationInput | student_performanceOrderByWithAggregationInput[]
    by: Student_performanceScalarFieldEnum[] | Student_performanceScalarFieldEnum
    having?: student_performanceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Student_performanceCountAggregateInputType | true
    _avg?: Student_performanceAvgAggregateInputType
    _sum?: Student_performanceSumAggregateInputType
    _min?: Student_performanceMinAggregateInputType
    _max?: Student_performanceMaxAggregateInputType
  }

  export type Student_performanceGroupByOutputType = {
    id: number
    student_id: number | null
    exam_id: number | null
    marks_obtained: Decimal
    total_marks: Decimal
    _count: Student_performanceCountAggregateOutputType | null
    _avg: Student_performanceAvgAggregateOutputType | null
    _sum: Student_performanceSumAggregateOutputType | null
    _min: Student_performanceMinAggregateOutputType | null
    _max: Student_performanceMaxAggregateOutputType | null
  }

  type GetStudent_performanceGroupByPayload<T extends student_performanceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Student_performanceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Student_performanceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Student_performanceGroupByOutputType[P]>
            : GetScalarType<T[P], Student_performanceGroupByOutputType[P]>
        }
      >
    >


  export type student_performanceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    student_id?: boolean
    exam_id?: boolean
    marks_obtained?: boolean
    total_marks?: boolean
    performance?: boolean | student_performance$performanceArgs<ExtArgs>
    exams?: boolean | student_performance$examsArgs<ExtArgs>
    students?: boolean | student_performance$studentsArgs<ExtArgs>
    _count?: boolean | Student_performanceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["student_performance"]>

  export type student_performanceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    student_id?: boolean
    exam_id?: boolean
    marks_obtained?: boolean
    total_marks?: boolean
    exams?: boolean | student_performance$examsArgs<ExtArgs>
    students?: boolean | student_performance$studentsArgs<ExtArgs>
  }, ExtArgs["result"]["student_performance"]>

  export type student_performanceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    student_id?: boolean
    exam_id?: boolean
    marks_obtained?: boolean
    total_marks?: boolean
    exams?: boolean | student_performance$examsArgs<ExtArgs>
    students?: boolean | student_performance$studentsArgs<ExtArgs>
  }, ExtArgs["result"]["student_performance"]>

  export type student_performanceSelectScalar = {
    id?: boolean
    student_id?: boolean
    exam_id?: boolean
    marks_obtained?: boolean
    total_marks?: boolean
  }

  export type student_performanceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "student_id" | "exam_id" | "marks_obtained" | "total_marks", ExtArgs["result"]["student_performance"]>
  export type student_performanceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    performance?: boolean | student_performance$performanceArgs<ExtArgs>
    exams?: boolean | student_performance$examsArgs<ExtArgs>
    students?: boolean | student_performance$studentsArgs<ExtArgs>
    _count?: boolean | Student_performanceCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type student_performanceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    exams?: boolean | student_performance$examsArgs<ExtArgs>
    students?: boolean | student_performance$studentsArgs<ExtArgs>
  }
  export type student_performanceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    exams?: boolean | student_performance$examsArgs<ExtArgs>
    students?: boolean | student_performance$studentsArgs<ExtArgs>
  }

  export type $student_performancePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "student_performance"
    objects: {
      performance: Prisma.$performancePayload<ExtArgs>[]
      exams: Prisma.$examsPayload<ExtArgs> | null
      students: Prisma.$studentsPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      student_id: number | null
      exam_id: number | null
      marks_obtained: Prisma.Decimal
      total_marks: Prisma.Decimal
    }, ExtArgs["result"]["student_performance"]>
    composites: {}
  }

  type student_performanceGetPayload<S extends boolean | null | undefined | student_performanceDefaultArgs> = $Result.GetResult<Prisma.$student_performancePayload, S>

  type student_performanceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<student_performanceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Student_performanceCountAggregateInputType | true
    }

  export interface student_performanceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['student_performance'], meta: { name: 'student_performance' } }
    /**
     * Find zero or one Student_performance that matches the filter.
     * @param {student_performanceFindUniqueArgs} args - Arguments to find a Student_performance
     * @example
     * // Get one Student_performance
     * const student_performance = await prisma.student_performance.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends student_performanceFindUniqueArgs>(args: SelectSubset<T, student_performanceFindUniqueArgs<ExtArgs>>): Prisma__student_performanceClient<$Result.GetResult<Prisma.$student_performancePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Student_performance that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {student_performanceFindUniqueOrThrowArgs} args - Arguments to find a Student_performance
     * @example
     * // Get one Student_performance
     * const student_performance = await prisma.student_performance.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends student_performanceFindUniqueOrThrowArgs>(args: SelectSubset<T, student_performanceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__student_performanceClient<$Result.GetResult<Prisma.$student_performancePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Student_performance that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {student_performanceFindFirstArgs} args - Arguments to find a Student_performance
     * @example
     * // Get one Student_performance
     * const student_performance = await prisma.student_performance.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends student_performanceFindFirstArgs>(args?: SelectSubset<T, student_performanceFindFirstArgs<ExtArgs>>): Prisma__student_performanceClient<$Result.GetResult<Prisma.$student_performancePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Student_performance that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {student_performanceFindFirstOrThrowArgs} args - Arguments to find a Student_performance
     * @example
     * // Get one Student_performance
     * const student_performance = await prisma.student_performance.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends student_performanceFindFirstOrThrowArgs>(args?: SelectSubset<T, student_performanceFindFirstOrThrowArgs<ExtArgs>>): Prisma__student_performanceClient<$Result.GetResult<Prisma.$student_performancePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Student_performances that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {student_performanceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Student_performances
     * const student_performances = await prisma.student_performance.findMany()
     * 
     * // Get first 10 Student_performances
     * const student_performances = await prisma.student_performance.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const student_performanceWithIdOnly = await prisma.student_performance.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends student_performanceFindManyArgs>(args?: SelectSubset<T, student_performanceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$student_performancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Student_performance.
     * @param {student_performanceCreateArgs} args - Arguments to create a Student_performance.
     * @example
     * // Create one Student_performance
     * const Student_performance = await prisma.student_performance.create({
     *   data: {
     *     // ... data to create a Student_performance
     *   }
     * })
     * 
     */
    create<T extends student_performanceCreateArgs>(args: SelectSubset<T, student_performanceCreateArgs<ExtArgs>>): Prisma__student_performanceClient<$Result.GetResult<Prisma.$student_performancePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Student_performances.
     * @param {student_performanceCreateManyArgs} args - Arguments to create many Student_performances.
     * @example
     * // Create many Student_performances
     * const student_performance = await prisma.student_performance.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends student_performanceCreateManyArgs>(args?: SelectSubset<T, student_performanceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Student_performances and returns the data saved in the database.
     * @param {student_performanceCreateManyAndReturnArgs} args - Arguments to create many Student_performances.
     * @example
     * // Create many Student_performances
     * const student_performance = await prisma.student_performance.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Student_performances and only return the `id`
     * const student_performanceWithIdOnly = await prisma.student_performance.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends student_performanceCreateManyAndReturnArgs>(args?: SelectSubset<T, student_performanceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$student_performancePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Student_performance.
     * @param {student_performanceDeleteArgs} args - Arguments to delete one Student_performance.
     * @example
     * // Delete one Student_performance
     * const Student_performance = await prisma.student_performance.delete({
     *   where: {
     *     // ... filter to delete one Student_performance
     *   }
     * })
     * 
     */
    delete<T extends student_performanceDeleteArgs>(args: SelectSubset<T, student_performanceDeleteArgs<ExtArgs>>): Prisma__student_performanceClient<$Result.GetResult<Prisma.$student_performancePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Student_performance.
     * @param {student_performanceUpdateArgs} args - Arguments to update one Student_performance.
     * @example
     * // Update one Student_performance
     * const student_performance = await prisma.student_performance.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends student_performanceUpdateArgs>(args: SelectSubset<T, student_performanceUpdateArgs<ExtArgs>>): Prisma__student_performanceClient<$Result.GetResult<Prisma.$student_performancePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Student_performances.
     * @param {student_performanceDeleteManyArgs} args - Arguments to filter Student_performances to delete.
     * @example
     * // Delete a few Student_performances
     * const { count } = await prisma.student_performance.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends student_performanceDeleteManyArgs>(args?: SelectSubset<T, student_performanceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Student_performances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {student_performanceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Student_performances
     * const student_performance = await prisma.student_performance.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends student_performanceUpdateManyArgs>(args: SelectSubset<T, student_performanceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Student_performances and returns the data updated in the database.
     * @param {student_performanceUpdateManyAndReturnArgs} args - Arguments to update many Student_performances.
     * @example
     * // Update many Student_performances
     * const student_performance = await prisma.student_performance.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Student_performances and only return the `id`
     * const student_performanceWithIdOnly = await prisma.student_performance.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends student_performanceUpdateManyAndReturnArgs>(args: SelectSubset<T, student_performanceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$student_performancePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Student_performance.
     * @param {student_performanceUpsertArgs} args - Arguments to update or create a Student_performance.
     * @example
     * // Update or create a Student_performance
     * const student_performance = await prisma.student_performance.upsert({
     *   create: {
     *     // ... data to create a Student_performance
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Student_performance we want to update
     *   }
     * })
     */
    upsert<T extends student_performanceUpsertArgs>(args: SelectSubset<T, student_performanceUpsertArgs<ExtArgs>>): Prisma__student_performanceClient<$Result.GetResult<Prisma.$student_performancePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Student_performances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {student_performanceCountArgs} args - Arguments to filter Student_performances to count.
     * @example
     * // Count the number of Student_performances
     * const count = await prisma.student_performance.count({
     *   where: {
     *     // ... the filter for the Student_performances we want to count
     *   }
     * })
    **/
    count<T extends student_performanceCountArgs>(
      args?: Subset<T, student_performanceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Student_performanceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Student_performance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Student_performanceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Student_performanceAggregateArgs>(args: Subset<T, Student_performanceAggregateArgs>): Prisma.PrismaPromise<GetStudent_performanceAggregateType<T>>

    /**
     * Group by Student_performance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {student_performanceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends student_performanceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: student_performanceGroupByArgs['orderBy'] }
        : { orderBy?: student_performanceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, student_performanceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStudent_performanceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the student_performance model
   */
  readonly fields: student_performanceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for student_performance.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__student_performanceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    performance<T extends student_performance$performanceArgs<ExtArgs> = {}>(args?: Subset<T, student_performance$performanceArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$performancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    exams<T extends student_performance$examsArgs<ExtArgs> = {}>(args?: Subset<T, student_performance$examsArgs<ExtArgs>>): Prisma__examsClient<$Result.GetResult<Prisma.$examsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    students<T extends student_performance$studentsArgs<ExtArgs> = {}>(args?: Subset<T, student_performance$studentsArgs<ExtArgs>>): Prisma__studentsClient<$Result.GetResult<Prisma.$studentsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the student_performance model
   */
  interface student_performanceFieldRefs {
    readonly id: FieldRef<"student_performance", 'Int'>
    readonly student_id: FieldRef<"student_performance", 'Int'>
    readonly exam_id: FieldRef<"student_performance", 'Int'>
    readonly marks_obtained: FieldRef<"student_performance", 'Decimal'>
    readonly total_marks: FieldRef<"student_performance", 'Decimal'>
  }
    

  // Custom InputTypes
  /**
   * student_performance findUnique
   */
  export type student_performanceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student_performance
     */
    select?: student_performanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the student_performance
     */
    omit?: student_performanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: student_performanceInclude<ExtArgs> | null
    /**
     * Filter, which student_performance to fetch.
     */
    where: student_performanceWhereUniqueInput
  }

  /**
   * student_performance findUniqueOrThrow
   */
  export type student_performanceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student_performance
     */
    select?: student_performanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the student_performance
     */
    omit?: student_performanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: student_performanceInclude<ExtArgs> | null
    /**
     * Filter, which student_performance to fetch.
     */
    where: student_performanceWhereUniqueInput
  }

  /**
   * student_performance findFirst
   */
  export type student_performanceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student_performance
     */
    select?: student_performanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the student_performance
     */
    omit?: student_performanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: student_performanceInclude<ExtArgs> | null
    /**
     * Filter, which student_performance to fetch.
     */
    where?: student_performanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of student_performances to fetch.
     */
    orderBy?: student_performanceOrderByWithRelationInput | student_performanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for student_performances.
     */
    cursor?: student_performanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` student_performances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` student_performances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of student_performances.
     */
    distinct?: Student_performanceScalarFieldEnum | Student_performanceScalarFieldEnum[]
  }

  /**
   * student_performance findFirstOrThrow
   */
  export type student_performanceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student_performance
     */
    select?: student_performanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the student_performance
     */
    omit?: student_performanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: student_performanceInclude<ExtArgs> | null
    /**
     * Filter, which student_performance to fetch.
     */
    where?: student_performanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of student_performances to fetch.
     */
    orderBy?: student_performanceOrderByWithRelationInput | student_performanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for student_performances.
     */
    cursor?: student_performanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` student_performances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` student_performances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of student_performances.
     */
    distinct?: Student_performanceScalarFieldEnum | Student_performanceScalarFieldEnum[]
  }

  /**
   * student_performance findMany
   */
  export type student_performanceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student_performance
     */
    select?: student_performanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the student_performance
     */
    omit?: student_performanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: student_performanceInclude<ExtArgs> | null
    /**
     * Filter, which student_performances to fetch.
     */
    where?: student_performanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of student_performances to fetch.
     */
    orderBy?: student_performanceOrderByWithRelationInput | student_performanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing student_performances.
     */
    cursor?: student_performanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` student_performances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` student_performances.
     */
    skip?: number
    distinct?: Student_performanceScalarFieldEnum | Student_performanceScalarFieldEnum[]
  }

  /**
   * student_performance create
   */
  export type student_performanceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student_performance
     */
    select?: student_performanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the student_performance
     */
    omit?: student_performanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: student_performanceInclude<ExtArgs> | null
    /**
     * The data needed to create a student_performance.
     */
    data: XOR<student_performanceCreateInput, student_performanceUncheckedCreateInput>
  }

  /**
   * student_performance createMany
   */
  export type student_performanceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many student_performances.
     */
    data: student_performanceCreateManyInput | student_performanceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * student_performance createManyAndReturn
   */
  export type student_performanceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student_performance
     */
    select?: student_performanceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the student_performance
     */
    omit?: student_performanceOmit<ExtArgs> | null
    /**
     * The data used to create many student_performances.
     */
    data: student_performanceCreateManyInput | student_performanceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: student_performanceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * student_performance update
   */
  export type student_performanceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student_performance
     */
    select?: student_performanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the student_performance
     */
    omit?: student_performanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: student_performanceInclude<ExtArgs> | null
    /**
     * The data needed to update a student_performance.
     */
    data: XOR<student_performanceUpdateInput, student_performanceUncheckedUpdateInput>
    /**
     * Choose, which student_performance to update.
     */
    where: student_performanceWhereUniqueInput
  }

  /**
   * student_performance updateMany
   */
  export type student_performanceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update student_performances.
     */
    data: XOR<student_performanceUpdateManyMutationInput, student_performanceUncheckedUpdateManyInput>
    /**
     * Filter which student_performances to update
     */
    where?: student_performanceWhereInput
    /**
     * Limit how many student_performances to update.
     */
    limit?: number
  }

  /**
   * student_performance updateManyAndReturn
   */
  export type student_performanceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student_performance
     */
    select?: student_performanceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the student_performance
     */
    omit?: student_performanceOmit<ExtArgs> | null
    /**
     * The data used to update student_performances.
     */
    data: XOR<student_performanceUpdateManyMutationInput, student_performanceUncheckedUpdateManyInput>
    /**
     * Filter which student_performances to update
     */
    where?: student_performanceWhereInput
    /**
     * Limit how many student_performances to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: student_performanceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * student_performance upsert
   */
  export type student_performanceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student_performance
     */
    select?: student_performanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the student_performance
     */
    omit?: student_performanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: student_performanceInclude<ExtArgs> | null
    /**
     * The filter to search for the student_performance to update in case it exists.
     */
    where: student_performanceWhereUniqueInput
    /**
     * In case the student_performance found by the `where` argument doesn't exist, create a new student_performance with this data.
     */
    create: XOR<student_performanceCreateInput, student_performanceUncheckedCreateInput>
    /**
     * In case the student_performance was found with the provided `where` argument, update it with this data.
     */
    update: XOR<student_performanceUpdateInput, student_performanceUncheckedUpdateInput>
  }

  /**
   * student_performance delete
   */
  export type student_performanceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student_performance
     */
    select?: student_performanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the student_performance
     */
    omit?: student_performanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: student_performanceInclude<ExtArgs> | null
    /**
     * Filter which student_performance to delete.
     */
    where: student_performanceWhereUniqueInput
  }

  /**
   * student_performance deleteMany
   */
  export type student_performanceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which student_performances to delete
     */
    where?: student_performanceWhereInput
    /**
     * Limit how many student_performances to delete.
     */
    limit?: number
  }

  /**
   * student_performance.performance
   */
  export type student_performance$performanceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the performance
     */
    select?: performanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the performance
     */
    omit?: performanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: performanceInclude<ExtArgs> | null
    where?: performanceWhereInput
    orderBy?: performanceOrderByWithRelationInput | performanceOrderByWithRelationInput[]
    cursor?: performanceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PerformanceScalarFieldEnum | PerformanceScalarFieldEnum[]
  }

  /**
   * student_performance.exams
   */
  export type student_performance$examsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the exams
     */
    select?: examsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the exams
     */
    omit?: examsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: examsInclude<ExtArgs> | null
    where?: examsWhereInput
  }

  /**
   * student_performance.students
   */
  export type student_performance$studentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the students
     */
    select?: studentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the students
     */
    omit?: studentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: studentsInclude<ExtArgs> | null
    where?: studentsWhereInput
  }

  /**
   * student_performance without action
   */
  export type student_performanceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student_performance
     */
    select?: student_performanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the student_performance
     */
    omit?: student_performanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: student_performanceInclude<ExtArgs> | null
  }


  /**
   * Model student_routine
   */

  export type AggregateStudent_routine = {
    _count: Student_routineCountAggregateOutputType | null
    _avg: Student_routineAvgAggregateOutputType | null
    _sum: Student_routineSumAggregateOutputType | null
    _min: Student_routineMinAggregateOutputType | null
    _max: Student_routineMaxAggregateOutputType | null
  }

  export type Student_routineAvgAggregateOutputType = {
    id: number | null
    teacher_id: number | null
  }

  export type Student_routineSumAggregateOutputType = {
    id: number | null
    teacher_id: number | null
  }

  export type Student_routineMinAggregateOutputType = {
    id: number | null
    class: string | null
    section: string | null
    day: string | null
    teacher_id: number | null
    teacher_name: string | null
    teacher_subject: string | null
    time_slot: string | null
  }

  export type Student_routineMaxAggregateOutputType = {
    id: number | null
    class: string | null
    section: string | null
    day: string | null
    teacher_id: number | null
    teacher_name: string | null
    teacher_subject: string | null
    time_slot: string | null
  }

  export type Student_routineCountAggregateOutputType = {
    id: number
    class: number
    section: number
    day: number
    teacher_id: number
    teacher_name: number
    teacher_subject: number
    time_slot: number
    _all: number
  }


  export type Student_routineAvgAggregateInputType = {
    id?: true
    teacher_id?: true
  }

  export type Student_routineSumAggregateInputType = {
    id?: true
    teacher_id?: true
  }

  export type Student_routineMinAggregateInputType = {
    id?: true
    class?: true
    section?: true
    day?: true
    teacher_id?: true
    teacher_name?: true
    teacher_subject?: true
    time_slot?: true
  }

  export type Student_routineMaxAggregateInputType = {
    id?: true
    class?: true
    section?: true
    day?: true
    teacher_id?: true
    teacher_name?: true
    teacher_subject?: true
    time_slot?: true
  }

  export type Student_routineCountAggregateInputType = {
    id?: true
    class?: true
    section?: true
    day?: true
    teacher_id?: true
    teacher_name?: true
    teacher_subject?: true
    time_slot?: true
    _all?: true
  }

  export type Student_routineAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which student_routine to aggregate.
     */
    where?: student_routineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of student_routines to fetch.
     */
    orderBy?: student_routineOrderByWithRelationInput | student_routineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: student_routineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` student_routines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` student_routines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned student_routines
    **/
    _count?: true | Student_routineCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Student_routineAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Student_routineSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Student_routineMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Student_routineMaxAggregateInputType
  }

  export type GetStudent_routineAggregateType<T extends Student_routineAggregateArgs> = {
        [P in keyof T & keyof AggregateStudent_routine]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStudent_routine[P]>
      : GetScalarType<T[P], AggregateStudent_routine[P]>
  }




  export type student_routineGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: student_routineWhereInput
    orderBy?: student_routineOrderByWithAggregationInput | student_routineOrderByWithAggregationInput[]
    by: Student_routineScalarFieldEnum[] | Student_routineScalarFieldEnum
    having?: student_routineScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Student_routineCountAggregateInputType | true
    _avg?: Student_routineAvgAggregateInputType
    _sum?: Student_routineSumAggregateInputType
    _min?: Student_routineMinAggregateInputType
    _max?: Student_routineMaxAggregateInputType
  }

  export type Student_routineGroupByOutputType = {
    id: number
    class: string
    section: string
    day: string
    teacher_id: number
    teacher_name: string
    teacher_subject: string | null
    time_slot: string
    _count: Student_routineCountAggregateOutputType | null
    _avg: Student_routineAvgAggregateOutputType | null
    _sum: Student_routineSumAggregateOutputType | null
    _min: Student_routineMinAggregateOutputType | null
    _max: Student_routineMaxAggregateOutputType | null
  }

  type GetStudent_routineGroupByPayload<T extends student_routineGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Student_routineGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Student_routineGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Student_routineGroupByOutputType[P]>
            : GetScalarType<T[P], Student_routineGroupByOutputType[P]>
        }
      >
    >


  export type student_routineSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    class?: boolean
    section?: boolean
    day?: boolean
    teacher_id?: boolean
    teacher_name?: boolean
    teacher_subject?: boolean
    time_slot?: boolean
    teachers?: boolean | teachersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["student_routine"]>

  export type student_routineSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    class?: boolean
    section?: boolean
    day?: boolean
    teacher_id?: boolean
    teacher_name?: boolean
    teacher_subject?: boolean
    time_slot?: boolean
    teachers?: boolean | teachersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["student_routine"]>

  export type student_routineSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    class?: boolean
    section?: boolean
    day?: boolean
    teacher_id?: boolean
    teacher_name?: boolean
    teacher_subject?: boolean
    time_slot?: boolean
    teachers?: boolean | teachersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["student_routine"]>

  export type student_routineSelectScalar = {
    id?: boolean
    class?: boolean
    section?: boolean
    day?: boolean
    teacher_id?: boolean
    teacher_name?: boolean
    teacher_subject?: boolean
    time_slot?: boolean
  }

  export type student_routineOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "class" | "section" | "day" | "teacher_id" | "teacher_name" | "teacher_subject" | "time_slot", ExtArgs["result"]["student_routine"]>
  export type student_routineInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    teachers?: boolean | teachersDefaultArgs<ExtArgs>
  }
  export type student_routineIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    teachers?: boolean | teachersDefaultArgs<ExtArgs>
  }
  export type student_routineIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    teachers?: boolean | teachersDefaultArgs<ExtArgs>
  }

  export type $student_routinePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "student_routine"
    objects: {
      teachers: Prisma.$teachersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      class: string
      section: string
      day: string
      teacher_id: number
      teacher_name: string
      teacher_subject: string | null
      time_slot: string
    }, ExtArgs["result"]["student_routine"]>
    composites: {}
  }

  type student_routineGetPayload<S extends boolean | null | undefined | student_routineDefaultArgs> = $Result.GetResult<Prisma.$student_routinePayload, S>

  type student_routineCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<student_routineFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Student_routineCountAggregateInputType | true
    }

  export interface student_routineDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['student_routine'], meta: { name: 'student_routine' } }
    /**
     * Find zero or one Student_routine that matches the filter.
     * @param {student_routineFindUniqueArgs} args - Arguments to find a Student_routine
     * @example
     * // Get one Student_routine
     * const student_routine = await prisma.student_routine.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends student_routineFindUniqueArgs>(args: SelectSubset<T, student_routineFindUniqueArgs<ExtArgs>>): Prisma__student_routineClient<$Result.GetResult<Prisma.$student_routinePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Student_routine that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {student_routineFindUniqueOrThrowArgs} args - Arguments to find a Student_routine
     * @example
     * // Get one Student_routine
     * const student_routine = await prisma.student_routine.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends student_routineFindUniqueOrThrowArgs>(args: SelectSubset<T, student_routineFindUniqueOrThrowArgs<ExtArgs>>): Prisma__student_routineClient<$Result.GetResult<Prisma.$student_routinePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Student_routine that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {student_routineFindFirstArgs} args - Arguments to find a Student_routine
     * @example
     * // Get one Student_routine
     * const student_routine = await prisma.student_routine.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends student_routineFindFirstArgs>(args?: SelectSubset<T, student_routineFindFirstArgs<ExtArgs>>): Prisma__student_routineClient<$Result.GetResult<Prisma.$student_routinePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Student_routine that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {student_routineFindFirstOrThrowArgs} args - Arguments to find a Student_routine
     * @example
     * // Get one Student_routine
     * const student_routine = await prisma.student_routine.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends student_routineFindFirstOrThrowArgs>(args?: SelectSubset<T, student_routineFindFirstOrThrowArgs<ExtArgs>>): Prisma__student_routineClient<$Result.GetResult<Prisma.$student_routinePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Student_routines that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {student_routineFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Student_routines
     * const student_routines = await prisma.student_routine.findMany()
     * 
     * // Get first 10 Student_routines
     * const student_routines = await prisma.student_routine.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const student_routineWithIdOnly = await prisma.student_routine.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends student_routineFindManyArgs>(args?: SelectSubset<T, student_routineFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$student_routinePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Student_routine.
     * @param {student_routineCreateArgs} args - Arguments to create a Student_routine.
     * @example
     * // Create one Student_routine
     * const Student_routine = await prisma.student_routine.create({
     *   data: {
     *     // ... data to create a Student_routine
     *   }
     * })
     * 
     */
    create<T extends student_routineCreateArgs>(args: SelectSubset<T, student_routineCreateArgs<ExtArgs>>): Prisma__student_routineClient<$Result.GetResult<Prisma.$student_routinePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Student_routines.
     * @param {student_routineCreateManyArgs} args - Arguments to create many Student_routines.
     * @example
     * // Create many Student_routines
     * const student_routine = await prisma.student_routine.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends student_routineCreateManyArgs>(args?: SelectSubset<T, student_routineCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Student_routines and returns the data saved in the database.
     * @param {student_routineCreateManyAndReturnArgs} args - Arguments to create many Student_routines.
     * @example
     * // Create many Student_routines
     * const student_routine = await prisma.student_routine.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Student_routines and only return the `id`
     * const student_routineWithIdOnly = await prisma.student_routine.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends student_routineCreateManyAndReturnArgs>(args?: SelectSubset<T, student_routineCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$student_routinePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Student_routine.
     * @param {student_routineDeleteArgs} args - Arguments to delete one Student_routine.
     * @example
     * // Delete one Student_routine
     * const Student_routine = await prisma.student_routine.delete({
     *   where: {
     *     // ... filter to delete one Student_routine
     *   }
     * })
     * 
     */
    delete<T extends student_routineDeleteArgs>(args: SelectSubset<T, student_routineDeleteArgs<ExtArgs>>): Prisma__student_routineClient<$Result.GetResult<Prisma.$student_routinePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Student_routine.
     * @param {student_routineUpdateArgs} args - Arguments to update one Student_routine.
     * @example
     * // Update one Student_routine
     * const student_routine = await prisma.student_routine.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends student_routineUpdateArgs>(args: SelectSubset<T, student_routineUpdateArgs<ExtArgs>>): Prisma__student_routineClient<$Result.GetResult<Prisma.$student_routinePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Student_routines.
     * @param {student_routineDeleteManyArgs} args - Arguments to filter Student_routines to delete.
     * @example
     * // Delete a few Student_routines
     * const { count } = await prisma.student_routine.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends student_routineDeleteManyArgs>(args?: SelectSubset<T, student_routineDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Student_routines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {student_routineUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Student_routines
     * const student_routine = await prisma.student_routine.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends student_routineUpdateManyArgs>(args: SelectSubset<T, student_routineUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Student_routines and returns the data updated in the database.
     * @param {student_routineUpdateManyAndReturnArgs} args - Arguments to update many Student_routines.
     * @example
     * // Update many Student_routines
     * const student_routine = await prisma.student_routine.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Student_routines and only return the `id`
     * const student_routineWithIdOnly = await prisma.student_routine.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends student_routineUpdateManyAndReturnArgs>(args: SelectSubset<T, student_routineUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$student_routinePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Student_routine.
     * @param {student_routineUpsertArgs} args - Arguments to update or create a Student_routine.
     * @example
     * // Update or create a Student_routine
     * const student_routine = await prisma.student_routine.upsert({
     *   create: {
     *     // ... data to create a Student_routine
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Student_routine we want to update
     *   }
     * })
     */
    upsert<T extends student_routineUpsertArgs>(args: SelectSubset<T, student_routineUpsertArgs<ExtArgs>>): Prisma__student_routineClient<$Result.GetResult<Prisma.$student_routinePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Student_routines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {student_routineCountArgs} args - Arguments to filter Student_routines to count.
     * @example
     * // Count the number of Student_routines
     * const count = await prisma.student_routine.count({
     *   where: {
     *     // ... the filter for the Student_routines we want to count
     *   }
     * })
    **/
    count<T extends student_routineCountArgs>(
      args?: Subset<T, student_routineCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Student_routineCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Student_routine.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Student_routineAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Student_routineAggregateArgs>(args: Subset<T, Student_routineAggregateArgs>): Prisma.PrismaPromise<GetStudent_routineAggregateType<T>>

    /**
     * Group by Student_routine.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {student_routineGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends student_routineGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: student_routineGroupByArgs['orderBy'] }
        : { orderBy?: student_routineGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, student_routineGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStudent_routineGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the student_routine model
   */
  readonly fields: student_routineFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for student_routine.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__student_routineClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    teachers<T extends teachersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, teachersDefaultArgs<ExtArgs>>): Prisma__teachersClient<$Result.GetResult<Prisma.$teachersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the student_routine model
   */
  interface student_routineFieldRefs {
    readonly id: FieldRef<"student_routine", 'Int'>
    readonly class: FieldRef<"student_routine", 'String'>
    readonly section: FieldRef<"student_routine", 'String'>
    readonly day: FieldRef<"student_routine", 'String'>
    readonly teacher_id: FieldRef<"student_routine", 'Int'>
    readonly teacher_name: FieldRef<"student_routine", 'String'>
    readonly teacher_subject: FieldRef<"student_routine", 'String'>
    readonly time_slot: FieldRef<"student_routine", 'String'>
  }
    

  // Custom InputTypes
  /**
   * student_routine findUnique
   */
  export type student_routineFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student_routine
     */
    select?: student_routineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the student_routine
     */
    omit?: student_routineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: student_routineInclude<ExtArgs> | null
    /**
     * Filter, which student_routine to fetch.
     */
    where: student_routineWhereUniqueInput
  }

  /**
   * student_routine findUniqueOrThrow
   */
  export type student_routineFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student_routine
     */
    select?: student_routineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the student_routine
     */
    omit?: student_routineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: student_routineInclude<ExtArgs> | null
    /**
     * Filter, which student_routine to fetch.
     */
    where: student_routineWhereUniqueInput
  }

  /**
   * student_routine findFirst
   */
  export type student_routineFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student_routine
     */
    select?: student_routineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the student_routine
     */
    omit?: student_routineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: student_routineInclude<ExtArgs> | null
    /**
     * Filter, which student_routine to fetch.
     */
    where?: student_routineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of student_routines to fetch.
     */
    orderBy?: student_routineOrderByWithRelationInput | student_routineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for student_routines.
     */
    cursor?: student_routineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` student_routines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` student_routines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of student_routines.
     */
    distinct?: Student_routineScalarFieldEnum | Student_routineScalarFieldEnum[]
  }

  /**
   * student_routine findFirstOrThrow
   */
  export type student_routineFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student_routine
     */
    select?: student_routineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the student_routine
     */
    omit?: student_routineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: student_routineInclude<ExtArgs> | null
    /**
     * Filter, which student_routine to fetch.
     */
    where?: student_routineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of student_routines to fetch.
     */
    orderBy?: student_routineOrderByWithRelationInput | student_routineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for student_routines.
     */
    cursor?: student_routineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` student_routines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` student_routines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of student_routines.
     */
    distinct?: Student_routineScalarFieldEnum | Student_routineScalarFieldEnum[]
  }

  /**
   * student_routine findMany
   */
  export type student_routineFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student_routine
     */
    select?: student_routineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the student_routine
     */
    omit?: student_routineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: student_routineInclude<ExtArgs> | null
    /**
     * Filter, which student_routines to fetch.
     */
    where?: student_routineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of student_routines to fetch.
     */
    orderBy?: student_routineOrderByWithRelationInput | student_routineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing student_routines.
     */
    cursor?: student_routineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` student_routines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` student_routines.
     */
    skip?: number
    distinct?: Student_routineScalarFieldEnum | Student_routineScalarFieldEnum[]
  }

  /**
   * student_routine create
   */
  export type student_routineCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student_routine
     */
    select?: student_routineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the student_routine
     */
    omit?: student_routineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: student_routineInclude<ExtArgs> | null
    /**
     * The data needed to create a student_routine.
     */
    data: XOR<student_routineCreateInput, student_routineUncheckedCreateInput>
  }

  /**
   * student_routine createMany
   */
  export type student_routineCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many student_routines.
     */
    data: student_routineCreateManyInput | student_routineCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * student_routine createManyAndReturn
   */
  export type student_routineCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student_routine
     */
    select?: student_routineSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the student_routine
     */
    omit?: student_routineOmit<ExtArgs> | null
    /**
     * The data used to create many student_routines.
     */
    data: student_routineCreateManyInput | student_routineCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: student_routineIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * student_routine update
   */
  export type student_routineUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student_routine
     */
    select?: student_routineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the student_routine
     */
    omit?: student_routineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: student_routineInclude<ExtArgs> | null
    /**
     * The data needed to update a student_routine.
     */
    data: XOR<student_routineUpdateInput, student_routineUncheckedUpdateInput>
    /**
     * Choose, which student_routine to update.
     */
    where: student_routineWhereUniqueInput
  }

  /**
   * student_routine updateMany
   */
  export type student_routineUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update student_routines.
     */
    data: XOR<student_routineUpdateManyMutationInput, student_routineUncheckedUpdateManyInput>
    /**
     * Filter which student_routines to update
     */
    where?: student_routineWhereInput
    /**
     * Limit how many student_routines to update.
     */
    limit?: number
  }

  /**
   * student_routine updateManyAndReturn
   */
  export type student_routineUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student_routine
     */
    select?: student_routineSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the student_routine
     */
    omit?: student_routineOmit<ExtArgs> | null
    /**
     * The data used to update student_routines.
     */
    data: XOR<student_routineUpdateManyMutationInput, student_routineUncheckedUpdateManyInput>
    /**
     * Filter which student_routines to update
     */
    where?: student_routineWhereInput
    /**
     * Limit how many student_routines to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: student_routineIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * student_routine upsert
   */
  export type student_routineUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student_routine
     */
    select?: student_routineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the student_routine
     */
    omit?: student_routineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: student_routineInclude<ExtArgs> | null
    /**
     * The filter to search for the student_routine to update in case it exists.
     */
    where: student_routineWhereUniqueInput
    /**
     * In case the student_routine found by the `where` argument doesn't exist, create a new student_routine with this data.
     */
    create: XOR<student_routineCreateInput, student_routineUncheckedCreateInput>
    /**
     * In case the student_routine was found with the provided `where` argument, update it with this data.
     */
    update: XOR<student_routineUpdateInput, student_routineUncheckedUpdateInput>
  }

  /**
   * student_routine delete
   */
  export type student_routineDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student_routine
     */
    select?: student_routineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the student_routine
     */
    omit?: student_routineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: student_routineInclude<ExtArgs> | null
    /**
     * Filter which student_routine to delete.
     */
    where: student_routineWhereUniqueInput
  }

  /**
   * student_routine deleteMany
   */
  export type student_routineDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which student_routines to delete
     */
    where?: student_routineWhereInput
    /**
     * Limit how many student_routines to delete.
     */
    limit?: number
  }

  /**
   * student_routine without action
   */
  export type student_routineDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student_routine
     */
    select?: student_routineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the student_routine
     */
    omit?: student_routineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: student_routineInclude<ExtArgs> | null
  }


  /**
   * Model students
   */

  export type AggregateStudents = {
    _count: StudentsCountAggregateOutputType | null
    _avg: StudentsAvgAggregateOutputType | null
    _sum: StudentsSumAggregateOutputType | null
    _min: StudentsMinAggregateOutputType | null
    _max: StudentsMaxAggregateOutputType | null
  }

  export type StudentsAvgAggregateOutputType = {
    id: number | null
    user_id: number | null
    roll_number: number | null
  }

  export type StudentsSumAggregateOutputType = {
    id: number | null
    user_id: number | null
    roll_number: number | null
  }

  export type StudentsMinAggregateOutputType = {
    id: number | null
    user_id: number | null
    admission_number: string | null
    class: string | null
    section: string | null
    parent_name: string | null
    parent_phone: string | null
    parent_email: string | null
    parent_work: string | null
    parent_photo1: string | null
    parent_photo2: string | null
    guardian_photo: string | null
    guardian_phone: string | null
    roll_number: number | null
  }

  export type StudentsMaxAggregateOutputType = {
    id: number | null
    user_id: number | null
    admission_number: string | null
    class: string | null
    section: string | null
    parent_name: string | null
    parent_phone: string | null
    parent_email: string | null
    parent_work: string | null
    parent_photo1: string | null
    parent_photo2: string | null
    guardian_photo: string | null
    guardian_phone: string | null
    roll_number: number | null
  }

  export type StudentsCountAggregateOutputType = {
    id: number
    user_id: number
    admission_number: number
    class: number
    section: number
    parent_name: number
    parent_phone: number
    parent_email: number
    parent_work: number
    parent_photo1: number
    parent_photo2: number
    guardian_photo: number
    guardian_phone: number
    roll_number: number
    _all: number
  }


  export type StudentsAvgAggregateInputType = {
    id?: true
    user_id?: true
    roll_number?: true
  }

  export type StudentsSumAggregateInputType = {
    id?: true
    user_id?: true
    roll_number?: true
  }

  export type StudentsMinAggregateInputType = {
    id?: true
    user_id?: true
    admission_number?: true
    class?: true
    section?: true
    parent_name?: true
    parent_phone?: true
    parent_email?: true
    parent_work?: true
    parent_photo1?: true
    parent_photo2?: true
    guardian_photo?: true
    guardian_phone?: true
    roll_number?: true
  }

  export type StudentsMaxAggregateInputType = {
    id?: true
    user_id?: true
    admission_number?: true
    class?: true
    section?: true
    parent_name?: true
    parent_phone?: true
    parent_email?: true
    parent_work?: true
    parent_photo1?: true
    parent_photo2?: true
    guardian_photo?: true
    guardian_phone?: true
    roll_number?: true
  }

  export type StudentsCountAggregateInputType = {
    id?: true
    user_id?: true
    admission_number?: true
    class?: true
    section?: true
    parent_name?: true
    parent_phone?: true
    parent_email?: true
    parent_work?: true
    parent_photo1?: true
    parent_photo2?: true
    guardian_photo?: true
    guardian_phone?: true
    roll_number?: true
    _all?: true
  }

  export type StudentsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which students to aggregate.
     */
    where?: studentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of students to fetch.
     */
    orderBy?: studentsOrderByWithRelationInput | studentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: studentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` students from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` students.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned students
    **/
    _count?: true | StudentsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StudentsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StudentsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StudentsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StudentsMaxAggregateInputType
  }

  export type GetStudentsAggregateType<T extends StudentsAggregateArgs> = {
        [P in keyof T & keyof AggregateStudents]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStudents[P]>
      : GetScalarType<T[P], AggregateStudents[P]>
  }




  export type studentsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: studentsWhereInput
    orderBy?: studentsOrderByWithAggregationInput | studentsOrderByWithAggregationInput[]
    by: StudentsScalarFieldEnum[] | StudentsScalarFieldEnum
    having?: studentsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StudentsCountAggregateInputType | true
    _avg?: StudentsAvgAggregateInputType
    _sum?: StudentsSumAggregateInputType
    _min?: StudentsMinAggregateInputType
    _max?: StudentsMaxAggregateInputType
  }

  export type StudentsGroupByOutputType = {
    id: number
    user_id: number | null
    admission_number: string
    class: string
    section: string
    parent_name: string | null
    parent_phone: string | null
    parent_email: string | null
    parent_work: string | null
    parent_photo1: string | null
    parent_photo2: string | null
    guardian_photo: string | null
    guardian_phone: string | null
    roll_number: number | null
    _count: StudentsCountAggregateOutputType | null
    _avg: StudentsAvgAggregateOutputType | null
    _sum: StudentsSumAggregateOutputType | null
    _min: StudentsMinAggregateOutputType | null
    _max: StudentsMaxAggregateOutputType | null
  }

  type GetStudentsGroupByPayload<T extends studentsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StudentsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StudentsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StudentsGroupByOutputType[P]>
            : GetScalarType<T[P], StudentsGroupByOutputType[P]>
        }
      >
    >


  export type studentsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    admission_number?: boolean
    class?: boolean
    section?: boolean
    parent_name?: boolean
    parent_phone?: boolean
    parent_email?: boolean
    parent_work?: boolean
    parent_photo1?: boolean
    parent_photo2?: boolean
    guardian_photo?: boolean
    guardian_phone?: boolean
    roll_number?: boolean
    attendance?: boolean | students$attendanceArgs<ExtArgs>
    class_representatives?: boolean | students$class_representativesArgs<ExtArgs>
    class_teachers?: boolean | students$class_teachersArgs<ExtArgs>
    finances?: boolean | students$financesArgs<ExtArgs>
    student_performance?: boolean | students$student_performanceArgs<ExtArgs>
    users?: boolean | students$usersArgs<ExtArgs>
    _count?: boolean | StudentsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["students"]>

  export type studentsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    admission_number?: boolean
    class?: boolean
    section?: boolean
    parent_name?: boolean
    parent_phone?: boolean
    parent_email?: boolean
    parent_work?: boolean
    parent_photo1?: boolean
    parent_photo2?: boolean
    guardian_photo?: boolean
    guardian_phone?: boolean
    roll_number?: boolean
    users?: boolean | students$usersArgs<ExtArgs>
  }, ExtArgs["result"]["students"]>

  export type studentsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    admission_number?: boolean
    class?: boolean
    section?: boolean
    parent_name?: boolean
    parent_phone?: boolean
    parent_email?: boolean
    parent_work?: boolean
    parent_photo1?: boolean
    parent_photo2?: boolean
    guardian_photo?: boolean
    guardian_phone?: boolean
    roll_number?: boolean
    users?: boolean | students$usersArgs<ExtArgs>
  }, ExtArgs["result"]["students"]>

  export type studentsSelectScalar = {
    id?: boolean
    user_id?: boolean
    admission_number?: boolean
    class?: boolean
    section?: boolean
    parent_name?: boolean
    parent_phone?: boolean
    parent_email?: boolean
    parent_work?: boolean
    parent_photo1?: boolean
    parent_photo2?: boolean
    guardian_photo?: boolean
    guardian_phone?: boolean
    roll_number?: boolean
  }

  export type studentsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "user_id" | "admission_number" | "class" | "section" | "parent_name" | "parent_phone" | "parent_email" | "parent_work" | "parent_photo1" | "parent_photo2" | "guardian_photo" | "guardian_phone" | "roll_number", ExtArgs["result"]["students"]>
  export type studentsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    attendance?: boolean | students$attendanceArgs<ExtArgs>
    class_representatives?: boolean | students$class_representativesArgs<ExtArgs>
    class_teachers?: boolean | students$class_teachersArgs<ExtArgs>
    finances?: boolean | students$financesArgs<ExtArgs>
    student_performance?: boolean | students$student_performanceArgs<ExtArgs>
    users?: boolean | students$usersArgs<ExtArgs>
    _count?: boolean | StudentsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type studentsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | students$usersArgs<ExtArgs>
  }
  export type studentsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | students$usersArgs<ExtArgs>
  }

  export type $studentsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "students"
    objects: {
      attendance: Prisma.$attendancePayload<ExtArgs>[]
      class_representatives: Prisma.$class_representativesPayload<ExtArgs>[]
      class_teachers: Prisma.$class_teachersPayload<ExtArgs>[]
      finances: Prisma.$financesPayload<ExtArgs>[]
      student_performance: Prisma.$student_performancePayload<ExtArgs>[]
      users: Prisma.$usersPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      user_id: number | null
      admission_number: string
      class: string
      section: string
      parent_name: string | null
      parent_phone: string | null
      parent_email: string | null
      parent_work: string | null
      parent_photo1: string | null
      parent_photo2: string | null
      guardian_photo: string | null
      guardian_phone: string | null
      roll_number: number | null
    }, ExtArgs["result"]["students"]>
    composites: {}
  }

  type studentsGetPayload<S extends boolean | null | undefined | studentsDefaultArgs> = $Result.GetResult<Prisma.$studentsPayload, S>

  type studentsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<studentsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StudentsCountAggregateInputType | true
    }

  export interface studentsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['students'], meta: { name: 'students' } }
    /**
     * Find zero or one Students that matches the filter.
     * @param {studentsFindUniqueArgs} args - Arguments to find a Students
     * @example
     * // Get one Students
     * const students = await prisma.students.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends studentsFindUniqueArgs>(args: SelectSubset<T, studentsFindUniqueArgs<ExtArgs>>): Prisma__studentsClient<$Result.GetResult<Prisma.$studentsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Students that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {studentsFindUniqueOrThrowArgs} args - Arguments to find a Students
     * @example
     * // Get one Students
     * const students = await prisma.students.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends studentsFindUniqueOrThrowArgs>(args: SelectSubset<T, studentsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__studentsClient<$Result.GetResult<Prisma.$studentsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Students that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {studentsFindFirstArgs} args - Arguments to find a Students
     * @example
     * // Get one Students
     * const students = await prisma.students.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends studentsFindFirstArgs>(args?: SelectSubset<T, studentsFindFirstArgs<ExtArgs>>): Prisma__studentsClient<$Result.GetResult<Prisma.$studentsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Students that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {studentsFindFirstOrThrowArgs} args - Arguments to find a Students
     * @example
     * // Get one Students
     * const students = await prisma.students.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends studentsFindFirstOrThrowArgs>(args?: SelectSubset<T, studentsFindFirstOrThrowArgs<ExtArgs>>): Prisma__studentsClient<$Result.GetResult<Prisma.$studentsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Students that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {studentsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Students
     * const students = await prisma.students.findMany()
     * 
     * // Get first 10 Students
     * const students = await prisma.students.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const studentsWithIdOnly = await prisma.students.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends studentsFindManyArgs>(args?: SelectSubset<T, studentsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$studentsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Students.
     * @param {studentsCreateArgs} args - Arguments to create a Students.
     * @example
     * // Create one Students
     * const Students = await prisma.students.create({
     *   data: {
     *     // ... data to create a Students
     *   }
     * })
     * 
     */
    create<T extends studentsCreateArgs>(args: SelectSubset<T, studentsCreateArgs<ExtArgs>>): Prisma__studentsClient<$Result.GetResult<Prisma.$studentsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Students.
     * @param {studentsCreateManyArgs} args - Arguments to create many Students.
     * @example
     * // Create many Students
     * const students = await prisma.students.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends studentsCreateManyArgs>(args?: SelectSubset<T, studentsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Students and returns the data saved in the database.
     * @param {studentsCreateManyAndReturnArgs} args - Arguments to create many Students.
     * @example
     * // Create many Students
     * const students = await prisma.students.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Students and only return the `id`
     * const studentsWithIdOnly = await prisma.students.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends studentsCreateManyAndReturnArgs>(args?: SelectSubset<T, studentsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$studentsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Students.
     * @param {studentsDeleteArgs} args - Arguments to delete one Students.
     * @example
     * // Delete one Students
     * const Students = await prisma.students.delete({
     *   where: {
     *     // ... filter to delete one Students
     *   }
     * })
     * 
     */
    delete<T extends studentsDeleteArgs>(args: SelectSubset<T, studentsDeleteArgs<ExtArgs>>): Prisma__studentsClient<$Result.GetResult<Prisma.$studentsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Students.
     * @param {studentsUpdateArgs} args - Arguments to update one Students.
     * @example
     * // Update one Students
     * const students = await prisma.students.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends studentsUpdateArgs>(args: SelectSubset<T, studentsUpdateArgs<ExtArgs>>): Prisma__studentsClient<$Result.GetResult<Prisma.$studentsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Students.
     * @param {studentsDeleteManyArgs} args - Arguments to filter Students to delete.
     * @example
     * // Delete a few Students
     * const { count } = await prisma.students.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends studentsDeleteManyArgs>(args?: SelectSubset<T, studentsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Students.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {studentsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Students
     * const students = await prisma.students.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends studentsUpdateManyArgs>(args: SelectSubset<T, studentsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Students and returns the data updated in the database.
     * @param {studentsUpdateManyAndReturnArgs} args - Arguments to update many Students.
     * @example
     * // Update many Students
     * const students = await prisma.students.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Students and only return the `id`
     * const studentsWithIdOnly = await prisma.students.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends studentsUpdateManyAndReturnArgs>(args: SelectSubset<T, studentsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$studentsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Students.
     * @param {studentsUpsertArgs} args - Arguments to update or create a Students.
     * @example
     * // Update or create a Students
     * const students = await prisma.students.upsert({
     *   create: {
     *     // ... data to create a Students
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Students we want to update
     *   }
     * })
     */
    upsert<T extends studentsUpsertArgs>(args: SelectSubset<T, studentsUpsertArgs<ExtArgs>>): Prisma__studentsClient<$Result.GetResult<Prisma.$studentsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Students.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {studentsCountArgs} args - Arguments to filter Students to count.
     * @example
     * // Count the number of Students
     * const count = await prisma.students.count({
     *   where: {
     *     // ... the filter for the Students we want to count
     *   }
     * })
    **/
    count<T extends studentsCountArgs>(
      args?: Subset<T, studentsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StudentsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Students.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StudentsAggregateArgs>(args: Subset<T, StudentsAggregateArgs>): Prisma.PrismaPromise<GetStudentsAggregateType<T>>

    /**
     * Group by Students.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {studentsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends studentsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: studentsGroupByArgs['orderBy'] }
        : { orderBy?: studentsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, studentsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStudentsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the students model
   */
  readonly fields: studentsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for students.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__studentsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    attendance<T extends students$attendanceArgs<ExtArgs> = {}>(args?: Subset<T, students$attendanceArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$attendancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    class_representatives<T extends students$class_representativesArgs<ExtArgs> = {}>(args?: Subset<T, students$class_representativesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$class_representativesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    class_teachers<T extends students$class_teachersArgs<ExtArgs> = {}>(args?: Subset<T, students$class_teachersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$class_teachersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    finances<T extends students$financesArgs<ExtArgs> = {}>(args?: Subset<T, students$financesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$financesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    student_performance<T extends students$student_performanceArgs<ExtArgs> = {}>(args?: Subset<T, students$student_performanceArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$student_performancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    users<T extends students$usersArgs<ExtArgs> = {}>(args?: Subset<T, students$usersArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the students model
   */
  interface studentsFieldRefs {
    readonly id: FieldRef<"students", 'Int'>
    readonly user_id: FieldRef<"students", 'Int'>
    readonly admission_number: FieldRef<"students", 'String'>
    readonly class: FieldRef<"students", 'String'>
    readonly section: FieldRef<"students", 'String'>
    readonly parent_name: FieldRef<"students", 'String'>
    readonly parent_phone: FieldRef<"students", 'String'>
    readonly parent_email: FieldRef<"students", 'String'>
    readonly parent_work: FieldRef<"students", 'String'>
    readonly parent_photo1: FieldRef<"students", 'String'>
    readonly parent_photo2: FieldRef<"students", 'String'>
    readonly guardian_photo: FieldRef<"students", 'String'>
    readonly guardian_phone: FieldRef<"students", 'String'>
    readonly roll_number: FieldRef<"students", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * students findUnique
   */
  export type studentsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the students
     */
    select?: studentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the students
     */
    omit?: studentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: studentsInclude<ExtArgs> | null
    /**
     * Filter, which students to fetch.
     */
    where: studentsWhereUniqueInput
  }

  /**
   * students findUniqueOrThrow
   */
  export type studentsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the students
     */
    select?: studentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the students
     */
    omit?: studentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: studentsInclude<ExtArgs> | null
    /**
     * Filter, which students to fetch.
     */
    where: studentsWhereUniqueInput
  }

  /**
   * students findFirst
   */
  export type studentsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the students
     */
    select?: studentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the students
     */
    omit?: studentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: studentsInclude<ExtArgs> | null
    /**
     * Filter, which students to fetch.
     */
    where?: studentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of students to fetch.
     */
    orderBy?: studentsOrderByWithRelationInput | studentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for students.
     */
    cursor?: studentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` students from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` students.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of students.
     */
    distinct?: StudentsScalarFieldEnum | StudentsScalarFieldEnum[]
  }

  /**
   * students findFirstOrThrow
   */
  export type studentsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the students
     */
    select?: studentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the students
     */
    omit?: studentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: studentsInclude<ExtArgs> | null
    /**
     * Filter, which students to fetch.
     */
    where?: studentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of students to fetch.
     */
    orderBy?: studentsOrderByWithRelationInput | studentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for students.
     */
    cursor?: studentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` students from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` students.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of students.
     */
    distinct?: StudentsScalarFieldEnum | StudentsScalarFieldEnum[]
  }

  /**
   * students findMany
   */
  export type studentsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the students
     */
    select?: studentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the students
     */
    omit?: studentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: studentsInclude<ExtArgs> | null
    /**
     * Filter, which students to fetch.
     */
    where?: studentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of students to fetch.
     */
    orderBy?: studentsOrderByWithRelationInput | studentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing students.
     */
    cursor?: studentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` students from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` students.
     */
    skip?: number
    distinct?: StudentsScalarFieldEnum | StudentsScalarFieldEnum[]
  }

  /**
   * students create
   */
  export type studentsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the students
     */
    select?: studentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the students
     */
    omit?: studentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: studentsInclude<ExtArgs> | null
    /**
     * The data needed to create a students.
     */
    data: XOR<studentsCreateInput, studentsUncheckedCreateInput>
  }

  /**
   * students createMany
   */
  export type studentsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many students.
     */
    data: studentsCreateManyInput | studentsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * students createManyAndReturn
   */
  export type studentsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the students
     */
    select?: studentsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the students
     */
    omit?: studentsOmit<ExtArgs> | null
    /**
     * The data used to create many students.
     */
    data: studentsCreateManyInput | studentsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: studentsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * students update
   */
  export type studentsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the students
     */
    select?: studentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the students
     */
    omit?: studentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: studentsInclude<ExtArgs> | null
    /**
     * The data needed to update a students.
     */
    data: XOR<studentsUpdateInput, studentsUncheckedUpdateInput>
    /**
     * Choose, which students to update.
     */
    where: studentsWhereUniqueInput
  }

  /**
   * students updateMany
   */
  export type studentsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update students.
     */
    data: XOR<studentsUpdateManyMutationInput, studentsUncheckedUpdateManyInput>
    /**
     * Filter which students to update
     */
    where?: studentsWhereInput
    /**
     * Limit how many students to update.
     */
    limit?: number
  }

  /**
   * students updateManyAndReturn
   */
  export type studentsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the students
     */
    select?: studentsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the students
     */
    omit?: studentsOmit<ExtArgs> | null
    /**
     * The data used to update students.
     */
    data: XOR<studentsUpdateManyMutationInput, studentsUncheckedUpdateManyInput>
    /**
     * Filter which students to update
     */
    where?: studentsWhereInput
    /**
     * Limit how many students to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: studentsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * students upsert
   */
  export type studentsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the students
     */
    select?: studentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the students
     */
    omit?: studentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: studentsInclude<ExtArgs> | null
    /**
     * The filter to search for the students to update in case it exists.
     */
    where: studentsWhereUniqueInput
    /**
     * In case the students found by the `where` argument doesn't exist, create a new students with this data.
     */
    create: XOR<studentsCreateInput, studentsUncheckedCreateInput>
    /**
     * In case the students was found with the provided `where` argument, update it with this data.
     */
    update: XOR<studentsUpdateInput, studentsUncheckedUpdateInput>
  }

  /**
   * students delete
   */
  export type studentsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the students
     */
    select?: studentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the students
     */
    omit?: studentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: studentsInclude<ExtArgs> | null
    /**
     * Filter which students to delete.
     */
    where: studentsWhereUniqueInput
  }

  /**
   * students deleteMany
   */
  export type studentsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which students to delete
     */
    where?: studentsWhereInput
    /**
     * Limit how many students to delete.
     */
    limit?: number
  }

  /**
   * students.attendance
   */
  export type students$attendanceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the attendance
     */
    select?: attendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the attendance
     */
    omit?: attendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: attendanceInclude<ExtArgs> | null
    where?: attendanceWhereInput
    orderBy?: attendanceOrderByWithRelationInput | attendanceOrderByWithRelationInput[]
    cursor?: attendanceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AttendanceScalarFieldEnum | AttendanceScalarFieldEnum[]
  }

  /**
   * students.class_representatives
   */
  export type students$class_representativesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the class_representatives
     */
    select?: class_representativesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the class_representatives
     */
    omit?: class_representativesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: class_representativesInclude<ExtArgs> | null
    where?: class_representativesWhereInput
    orderBy?: class_representativesOrderByWithRelationInput | class_representativesOrderByWithRelationInput[]
    cursor?: class_representativesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Class_representativesScalarFieldEnum | Class_representativesScalarFieldEnum[]
  }

  /**
   * students.class_teachers
   */
  export type students$class_teachersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the class_teachers
     */
    select?: class_teachersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the class_teachers
     */
    omit?: class_teachersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: class_teachersInclude<ExtArgs> | null
    where?: class_teachersWhereInput
    orderBy?: class_teachersOrderByWithRelationInput | class_teachersOrderByWithRelationInput[]
    cursor?: class_teachersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Class_teachersScalarFieldEnum | Class_teachersScalarFieldEnum[]
  }

  /**
   * students.finances
   */
  export type students$financesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the finances
     */
    select?: financesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the finances
     */
    omit?: financesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: financesInclude<ExtArgs> | null
    where?: financesWhereInput
    orderBy?: financesOrderByWithRelationInput | financesOrderByWithRelationInput[]
    cursor?: financesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FinancesScalarFieldEnum | FinancesScalarFieldEnum[]
  }

  /**
   * students.student_performance
   */
  export type students$student_performanceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student_performance
     */
    select?: student_performanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the student_performance
     */
    omit?: student_performanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: student_performanceInclude<ExtArgs> | null
    where?: student_performanceWhereInput
    orderBy?: student_performanceOrderByWithRelationInput | student_performanceOrderByWithRelationInput[]
    cursor?: student_performanceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Student_performanceScalarFieldEnum | Student_performanceScalarFieldEnum[]
  }

  /**
   * students.users
   */
  export type students$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    where?: usersWhereInput
  }

  /**
   * students without action
   */
  export type studentsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the students
     */
    select?: studentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the students
     */
    omit?: studentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: studentsInclude<ExtArgs> | null
  }


  /**
   * Model teacher_routine
   */

  export type AggregateTeacher_routine = {
    _count: Teacher_routineCountAggregateOutputType | null
    _avg: Teacher_routineAvgAggregateOutputType | null
    _sum: Teacher_routineSumAggregateOutputType | null
    _min: Teacher_routineMinAggregateOutputType | null
    _max: Teacher_routineMaxAggregateOutputType | null
  }

  export type Teacher_routineAvgAggregateOutputType = {
    id: number | null
    teacher_id: number | null
  }

  export type Teacher_routineSumAggregateOutputType = {
    id: number | null
    teacher_id: number | null
  }

  export type Teacher_routineMinAggregateOutputType = {
    id: number | null
    teacher_id: number | null
    day: string | null
    time_slot: string | null
    class: string | null
    section: string | null
  }

  export type Teacher_routineMaxAggregateOutputType = {
    id: number | null
    teacher_id: number | null
    day: string | null
    time_slot: string | null
    class: string | null
    section: string | null
  }

  export type Teacher_routineCountAggregateOutputType = {
    id: number
    teacher_id: number
    day: number
    time_slot: number
    class: number
    section: number
    _all: number
  }


  export type Teacher_routineAvgAggregateInputType = {
    id?: true
    teacher_id?: true
  }

  export type Teacher_routineSumAggregateInputType = {
    id?: true
    teacher_id?: true
  }

  export type Teacher_routineMinAggregateInputType = {
    id?: true
    teacher_id?: true
    day?: true
    time_slot?: true
    class?: true
    section?: true
  }

  export type Teacher_routineMaxAggregateInputType = {
    id?: true
    teacher_id?: true
    day?: true
    time_slot?: true
    class?: true
    section?: true
  }

  export type Teacher_routineCountAggregateInputType = {
    id?: true
    teacher_id?: true
    day?: true
    time_slot?: true
    class?: true
    section?: true
    _all?: true
  }

  export type Teacher_routineAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which teacher_routine to aggregate.
     */
    where?: teacher_routineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of teacher_routines to fetch.
     */
    orderBy?: teacher_routineOrderByWithRelationInput | teacher_routineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: teacher_routineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` teacher_routines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` teacher_routines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned teacher_routines
    **/
    _count?: true | Teacher_routineCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Teacher_routineAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Teacher_routineSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Teacher_routineMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Teacher_routineMaxAggregateInputType
  }

  export type GetTeacher_routineAggregateType<T extends Teacher_routineAggregateArgs> = {
        [P in keyof T & keyof AggregateTeacher_routine]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTeacher_routine[P]>
      : GetScalarType<T[P], AggregateTeacher_routine[P]>
  }




  export type teacher_routineGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: teacher_routineWhereInput
    orderBy?: teacher_routineOrderByWithAggregationInput | teacher_routineOrderByWithAggregationInput[]
    by: Teacher_routineScalarFieldEnum[] | Teacher_routineScalarFieldEnum
    having?: teacher_routineScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Teacher_routineCountAggregateInputType | true
    _avg?: Teacher_routineAvgAggregateInputType
    _sum?: Teacher_routineSumAggregateInputType
    _min?: Teacher_routineMinAggregateInputType
    _max?: Teacher_routineMaxAggregateInputType
  }

  export type Teacher_routineGroupByOutputType = {
    id: number
    teacher_id: number
    day: string
    time_slot: string
    class: string
    section: string
    _count: Teacher_routineCountAggregateOutputType | null
    _avg: Teacher_routineAvgAggregateOutputType | null
    _sum: Teacher_routineSumAggregateOutputType | null
    _min: Teacher_routineMinAggregateOutputType | null
    _max: Teacher_routineMaxAggregateOutputType | null
  }

  type GetTeacher_routineGroupByPayload<T extends teacher_routineGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Teacher_routineGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Teacher_routineGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Teacher_routineGroupByOutputType[P]>
            : GetScalarType<T[P], Teacher_routineGroupByOutputType[P]>
        }
      >
    >


  export type teacher_routineSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    teacher_id?: boolean
    day?: boolean
    time_slot?: boolean
    class?: boolean
    section?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["teacher_routine"]>

  export type teacher_routineSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    teacher_id?: boolean
    day?: boolean
    time_slot?: boolean
    class?: boolean
    section?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["teacher_routine"]>

  export type teacher_routineSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    teacher_id?: boolean
    day?: boolean
    time_slot?: boolean
    class?: boolean
    section?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["teacher_routine"]>

  export type teacher_routineSelectScalar = {
    id?: boolean
    teacher_id?: boolean
    day?: boolean
    time_slot?: boolean
    class?: boolean
    section?: boolean
  }

  export type teacher_routineOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "teacher_id" | "day" | "time_slot" | "class" | "section", ExtArgs["result"]["teacher_routine"]>
  export type teacher_routineInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type teacher_routineIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type teacher_routineIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
  }

  export type $teacher_routinePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "teacher_routine"
    objects: {
      users: Prisma.$usersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      teacher_id: number
      day: string
      time_slot: string
      class: string
      section: string
    }, ExtArgs["result"]["teacher_routine"]>
    composites: {}
  }

  type teacher_routineGetPayload<S extends boolean | null | undefined | teacher_routineDefaultArgs> = $Result.GetResult<Prisma.$teacher_routinePayload, S>

  type teacher_routineCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<teacher_routineFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Teacher_routineCountAggregateInputType | true
    }

  export interface teacher_routineDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['teacher_routine'], meta: { name: 'teacher_routine' } }
    /**
     * Find zero or one Teacher_routine that matches the filter.
     * @param {teacher_routineFindUniqueArgs} args - Arguments to find a Teacher_routine
     * @example
     * // Get one Teacher_routine
     * const teacher_routine = await prisma.teacher_routine.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends teacher_routineFindUniqueArgs>(args: SelectSubset<T, teacher_routineFindUniqueArgs<ExtArgs>>): Prisma__teacher_routineClient<$Result.GetResult<Prisma.$teacher_routinePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Teacher_routine that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {teacher_routineFindUniqueOrThrowArgs} args - Arguments to find a Teacher_routine
     * @example
     * // Get one Teacher_routine
     * const teacher_routine = await prisma.teacher_routine.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends teacher_routineFindUniqueOrThrowArgs>(args: SelectSubset<T, teacher_routineFindUniqueOrThrowArgs<ExtArgs>>): Prisma__teacher_routineClient<$Result.GetResult<Prisma.$teacher_routinePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Teacher_routine that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {teacher_routineFindFirstArgs} args - Arguments to find a Teacher_routine
     * @example
     * // Get one Teacher_routine
     * const teacher_routine = await prisma.teacher_routine.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends teacher_routineFindFirstArgs>(args?: SelectSubset<T, teacher_routineFindFirstArgs<ExtArgs>>): Prisma__teacher_routineClient<$Result.GetResult<Prisma.$teacher_routinePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Teacher_routine that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {teacher_routineFindFirstOrThrowArgs} args - Arguments to find a Teacher_routine
     * @example
     * // Get one Teacher_routine
     * const teacher_routine = await prisma.teacher_routine.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends teacher_routineFindFirstOrThrowArgs>(args?: SelectSubset<T, teacher_routineFindFirstOrThrowArgs<ExtArgs>>): Prisma__teacher_routineClient<$Result.GetResult<Prisma.$teacher_routinePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Teacher_routines that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {teacher_routineFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Teacher_routines
     * const teacher_routines = await prisma.teacher_routine.findMany()
     * 
     * // Get first 10 Teacher_routines
     * const teacher_routines = await prisma.teacher_routine.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const teacher_routineWithIdOnly = await prisma.teacher_routine.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends teacher_routineFindManyArgs>(args?: SelectSubset<T, teacher_routineFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$teacher_routinePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Teacher_routine.
     * @param {teacher_routineCreateArgs} args - Arguments to create a Teacher_routine.
     * @example
     * // Create one Teacher_routine
     * const Teacher_routine = await prisma.teacher_routine.create({
     *   data: {
     *     // ... data to create a Teacher_routine
     *   }
     * })
     * 
     */
    create<T extends teacher_routineCreateArgs>(args: SelectSubset<T, teacher_routineCreateArgs<ExtArgs>>): Prisma__teacher_routineClient<$Result.GetResult<Prisma.$teacher_routinePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Teacher_routines.
     * @param {teacher_routineCreateManyArgs} args - Arguments to create many Teacher_routines.
     * @example
     * // Create many Teacher_routines
     * const teacher_routine = await prisma.teacher_routine.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends teacher_routineCreateManyArgs>(args?: SelectSubset<T, teacher_routineCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Teacher_routines and returns the data saved in the database.
     * @param {teacher_routineCreateManyAndReturnArgs} args - Arguments to create many Teacher_routines.
     * @example
     * // Create many Teacher_routines
     * const teacher_routine = await prisma.teacher_routine.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Teacher_routines and only return the `id`
     * const teacher_routineWithIdOnly = await prisma.teacher_routine.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends teacher_routineCreateManyAndReturnArgs>(args?: SelectSubset<T, teacher_routineCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$teacher_routinePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Teacher_routine.
     * @param {teacher_routineDeleteArgs} args - Arguments to delete one Teacher_routine.
     * @example
     * // Delete one Teacher_routine
     * const Teacher_routine = await prisma.teacher_routine.delete({
     *   where: {
     *     // ... filter to delete one Teacher_routine
     *   }
     * })
     * 
     */
    delete<T extends teacher_routineDeleteArgs>(args: SelectSubset<T, teacher_routineDeleteArgs<ExtArgs>>): Prisma__teacher_routineClient<$Result.GetResult<Prisma.$teacher_routinePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Teacher_routine.
     * @param {teacher_routineUpdateArgs} args - Arguments to update one Teacher_routine.
     * @example
     * // Update one Teacher_routine
     * const teacher_routine = await prisma.teacher_routine.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends teacher_routineUpdateArgs>(args: SelectSubset<T, teacher_routineUpdateArgs<ExtArgs>>): Prisma__teacher_routineClient<$Result.GetResult<Prisma.$teacher_routinePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Teacher_routines.
     * @param {teacher_routineDeleteManyArgs} args - Arguments to filter Teacher_routines to delete.
     * @example
     * // Delete a few Teacher_routines
     * const { count } = await prisma.teacher_routine.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends teacher_routineDeleteManyArgs>(args?: SelectSubset<T, teacher_routineDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Teacher_routines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {teacher_routineUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Teacher_routines
     * const teacher_routine = await prisma.teacher_routine.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends teacher_routineUpdateManyArgs>(args: SelectSubset<T, teacher_routineUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Teacher_routines and returns the data updated in the database.
     * @param {teacher_routineUpdateManyAndReturnArgs} args - Arguments to update many Teacher_routines.
     * @example
     * // Update many Teacher_routines
     * const teacher_routine = await prisma.teacher_routine.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Teacher_routines and only return the `id`
     * const teacher_routineWithIdOnly = await prisma.teacher_routine.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends teacher_routineUpdateManyAndReturnArgs>(args: SelectSubset<T, teacher_routineUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$teacher_routinePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Teacher_routine.
     * @param {teacher_routineUpsertArgs} args - Arguments to update or create a Teacher_routine.
     * @example
     * // Update or create a Teacher_routine
     * const teacher_routine = await prisma.teacher_routine.upsert({
     *   create: {
     *     // ... data to create a Teacher_routine
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Teacher_routine we want to update
     *   }
     * })
     */
    upsert<T extends teacher_routineUpsertArgs>(args: SelectSubset<T, teacher_routineUpsertArgs<ExtArgs>>): Prisma__teacher_routineClient<$Result.GetResult<Prisma.$teacher_routinePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Teacher_routines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {teacher_routineCountArgs} args - Arguments to filter Teacher_routines to count.
     * @example
     * // Count the number of Teacher_routines
     * const count = await prisma.teacher_routine.count({
     *   where: {
     *     // ... the filter for the Teacher_routines we want to count
     *   }
     * })
    **/
    count<T extends teacher_routineCountArgs>(
      args?: Subset<T, teacher_routineCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Teacher_routineCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Teacher_routine.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Teacher_routineAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Teacher_routineAggregateArgs>(args: Subset<T, Teacher_routineAggregateArgs>): Prisma.PrismaPromise<GetTeacher_routineAggregateType<T>>

    /**
     * Group by Teacher_routine.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {teacher_routineGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends teacher_routineGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: teacher_routineGroupByArgs['orderBy'] }
        : { orderBy?: teacher_routineGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, teacher_routineGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTeacher_routineGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the teacher_routine model
   */
  readonly fields: teacher_routineFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for teacher_routine.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__teacher_routineClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the teacher_routine model
   */
  interface teacher_routineFieldRefs {
    readonly id: FieldRef<"teacher_routine", 'Int'>
    readonly teacher_id: FieldRef<"teacher_routine", 'Int'>
    readonly day: FieldRef<"teacher_routine", 'String'>
    readonly time_slot: FieldRef<"teacher_routine", 'String'>
    readonly class: FieldRef<"teacher_routine", 'String'>
    readonly section: FieldRef<"teacher_routine", 'String'>
  }
    

  // Custom InputTypes
  /**
   * teacher_routine findUnique
   */
  export type teacher_routineFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the teacher_routine
     */
    select?: teacher_routineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the teacher_routine
     */
    omit?: teacher_routineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teacher_routineInclude<ExtArgs> | null
    /**
     * Filter, which teacher_routine to fetch.
     */
    where: teacher_routineWhereUniqueInput
  }

  /**
   * teacher_routine findUniqueOrThrow
   */
  export type teacher_routineFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the teacher_routine
     */
    select?: teacher_routineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the teacher_routine
     */
    omit?: teacher_routineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teacher_routineInclude<ExtArgs> | null
    /**
     * Filter, which teacher_routine to fetch.
     */
    where: teacher_routineWhereUniqueInput
  }

  /**
   * teacher_routine findFirst
   */
  export type teacher_routineFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the teacher_routine
     */
    select?: teacher_routineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the teacher_routine
     */
    omit?: teacher_routineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teacher_routineInclude<ExtArgs> | null
    /**
     * Filter, which teacher_routine to fetch.
     */
    where?: teacher_routineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of teacher_routines to fetch.
     */
    orderBy?: teacher_routineOrderByWithRelationInput | teacher_routineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for teacher_routines.
     */
    cursor?: teacher_routineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` teacher_routines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` teacher_routines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of teacher_routines.
     */
    distinct?: Teacher_routineScalarFieldEnum | Teacher_routineScalarFieldEnum[]
  }

  /**
   * teacher_routine findFirstOrThrow
   */
  export type teacher_routineFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the teacher_routine
     */
    select?: teacher_routineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the teacher_routine
     */
    omit?: teacher_routineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teacher_routineInclude<ExtArgs> | null
    /**
     * Filter, which teacher_routine to fetch.
     */
    where?: teacher_routineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of teacher_routines to fetch.
     */
    orderBy?: teacher_routineOrderByWithRelationInput | teacher_routineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for teacher_routines.
     */
    cursor?: teacher_routineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` teacher_routines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` teacher_routines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of teacher_routines.
     */
    distinct?: Teacher_routineScalarFieldEnum | Teacher_routineScalarFieldEnum[]
  }

  /**
   * teacher_routine findMany
   */
  export type teacher_routineFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the teacher_routine
     */
    select?: teacher_routineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the teacher_routine
     */
    omit?: teacher_routineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teacher_routineInclude<ExtArgs> | null
    /**
     * Filter, which teacher_routines to fetch.
     */
    where?: teacher_routineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of teacher_routines to fetch.
     */
    orderBy?: teacher_routineOrderByWithRelationInput | teacher_routineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing teacher_routines.
     */
    cursor?: teacher_routineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` teacher_routines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` teacher_routines.
     */
    skip?: number
    distinct?: Teacher_routineScalarFieldEnum | Teacher_routineScalarFieldEnum[]
  }

  /**
   * teacher_routine create
   */
  export type teacher_routineCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the teacher_routine
     */
    select?: teacher_routineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the teacher_routine
     */
    omit?: teacher_routineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teacher_routineInclude<ExtArgs> | null
    /**
     * The data needed to create a teacher_routine.
     */
    data: XOR<teacher_routineCreateInput, teacher_routineUncheckedCreateInput>
  }

  /**
   * teacher_routine createMany
   */
  export type teacher_routineCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many teacher_routines.
     */
    data: teacher_routineCreateManyInput | teacher_routineCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * teacher_routine createManyAndReturn
   */
  export type teacher_routineCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the teacher_routine
     */
    select?: teacher_routineSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the teacher_routine
     */
    omit?: teacher_routineOmit<ExtArgs> | null
    /**
     * The data used to create many teacher_routines.
     */
    data: teacher_routineCreateManyInput | teacher_routineCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teacher_routineIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * teacher_routine update
   */
  export type teacher_routineUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the teacher_routine
     */
    select?: teacher_routineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the teacher_routine
     */
    omit?: teacher_routineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teacher_routineInclude<ExtArgs> | null
    /**
     * The data needed to update a teacher_routine.
     */
    data: XOR<teacher_routineUpdateInput, teacher_routineUncheckedUpdateInput>
    /**
     * Choose, which teacher_routine to update.
     */
    where: teacher_routineWhereUniqueInput
  }

  /**
   * teacher_routine updateMany
   */
  export type teacher_routineUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update teacher_routines.
     */
    data: XOR<teacher_routineUpdateManyMutationInput, teacher_routineUncheckedUpdateManyInput>
    /**
     * Filter which teacher_routines to update
     */
    where?: teacher_routineWhereInput
    /**
     * Limit how many teacher_routines to update.
     */
    limit?: number
  }

  /**
   * teacher_routine updateManyAndReturn
   */
  export type teacher_routineUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the teacher_routine
     */
    select?: teacher_routineSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the teacher_routine
     */
    omit?: teacher_routineOmit<ExtArgs> | null
    /**
     * The data used to update teacher_routines.
     */
    data: XOR<teacher_routineUpdateManyMutationInput, teacher_routineUncheckedUpdateManyInput>
    /**
     * Filter which teacher_routines to update
     */
    where?: teacher_routineWhereInput
    /**
     * Limit how many teacher_routines to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teacher_routineIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * teacher_routine upsert
   */
  export type teacher_routineUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the teacher_routine
     */
    select?: teacher_routineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the teacher_routine
     */
    omit?: teacher_routineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teacher_routineInclude<ExtArgs> | null
    /**
     * The filter to search for the teacher_routine to update in case it exists.
     */
    where: teacher_routineWhereUniqueInput
    /**
     * In case the teacher_routine found by the `where` argument doesn't exist, create a new teacher_routine with this data.
     */
    create: XOR<teacher_routineCreateInput, teacher_routineUncheckedCreateInput>
    /**
     * In case the teacher_routine was found with the provided `where` argument, update it with this data.
     */
    update: XOR<teacher_routineUpdateInput, teacher_routineUncheckedUpdateInput>
  }

  /**
   * teacher_routine delete
   */
  export type teacher_routineDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the teacher_routine
     */
    select?: teacher_routineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the teacher_routine
     */
    omit?: teacher_routineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teacher_routineInclude<ExtArgs> | null
    /**
     * Filter which teacher_routine to delete.
     */
    where: teacher_routineWhereUniqueInput
  }

  /**
   * teacher_routine deleteMany
   */
  export type teacher_routineDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which teacher_routines to delete
     */
    where?: teacher_routineWhereInput
    /**
     * Limit how many teacher_routines to delete.
     */
    limit?: number
  }

  /**
   * teacher_routine without action
   */
  export type teacher_routineDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the teacher_routine
     */
    select?: teacher_routineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the teacher_routine
     */
    omit?: teacher_routineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teacher_routineInclude<ExtArgs> | null
  }


  /**
   * Model teachers
   */

  export type AggregateTeachers = {
    _count: TeachersCountAggregateOutputType | null
    _avg: TeachersAvgAggregateOutputType | null
    _sum: TeachersSumAggregateOutputType | null
    _min: TeachersMinAggregateOutputType | null
    _max: TeachersMaxAggregateOutputType | null
  }

  export type TeachersAvgAggregateOutputType = {
    id: number | null
    user_id: number | null
  }

  export type TeachersSumAggregateOutputType = {
    id: number | null
    user_id: number | null
  }

  export type TeachersMinAggregateOutputType = {
    id: number | null
    user_id: number | null
    specialised_subject: string | null
    assigned_class: string | null
    assigned_section: string | null
  }

  export type TeachersMaxAggregateOutputType = {
    id: number | null
    user_id: number | null
    specialised_subject: string | null
    assigned_class: string | null
    assigned_section: string | null
  }

  export type TeachersCountAggregateOutputType = {
    id: number
    user_id: number
    specialised_subject: number
    assigned_class: number
    assigned_section: number
    _all: number
  }


  export type TeachersAvgAggregateInputType = {
    id?: true
    user_id?: true
  }

  export type TeachersSumAggregateInputType = {
    id?: true
    user_id?: true
  }

  export type TeachersMinAggregateInputType = {
    id?: true
    user_id?: true
    specialised_subject?: true
    assigned_class?: true
    assigned_section?: true
  }

  export type TeachersMaxAggregateInputType = {
    id?: true
    user_id?: true
    specialised_subject?: true
    assigned_class?: true
    assigned_section?: true
  }

  export type TeachersCountAggregateInputType = {
    id?: true
    user_id?: true
    specialised_subject?: true
    assigned_class?: true
    assigned_section?: true
    _all?: true
  }

  export type TeachersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which teachers to aggregate.
     */
    where?: teachersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of teachers to fetch.
     */
    orderBy?: teachersOrderByWithRelationInput | teachersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: teachersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` teachers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` teachers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned teachers
    **/
    _count?: true | TeachersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TeachersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TeachersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TeachersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TeachersMaxAggregateInputType
  }

  export type GetTeachersAggregateType<T extends TeachersAggregateArgs> = {
        [P in keyof T & keyof AggregateTeachers]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTeachers[P]>
      : GetScalarType<T[P], AggregateTeachers[P]>
  }




  export type teachersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: teachersWhereInput
    orderBy?: teachersOrderByWithAggregationInput | teachersOrderByWithAggregationInput[]
    by: TeachersScalarFieldEnum[] | TeachersScalarFieldEnum
    having?: teachersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TeachersCountAggregateInputType | true
    _avg?: TeachersAvgAggregateInputType
    _sum?: TeachersSumAggregateInputType
    _min?: TeachersMinAggregateInputType
    _max?: TeachersMaxAggregateInputType
  }

  export type TeachersGroupByOutputType = {
    id: number
    user_id: number | null
    specialised_subject: string
    assigned_class: string | null
    assigned_section: string | null
    _count: TeachersCountAggregateOutputType | null
    _avg: TeachersAvgAggregateOutputType | null
    _sum: TeachersSumAggregateOutputType | null
    _min: TeachersMinAggregateOutputType | null
    _max: TeachersMaxAggregateOutputType | null
  }

  type GetTeachersGroupByPayload<T extends teachersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TeachersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TeachersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TeachersGroupByOutputType[P]>
            : GetScalarType<T[P], TeachersGroupByOutputType[P]>
        }
      >
    >


  export type teachersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    specialised_subject?: boolean
    assigned_class?: boolean
    assigned_section?: boolean
    assignments?: boolean | teachers$assignmentsArgs<ExtArgs>
    attendance?: boolean | teachers$attendanceArgs<ExtArgs>
    class_routine?: boolean | teachers$class_routineArgs<ExtArgs>
    class_teachers?: boolean | teachers$class_teachersArgs<ExtArgs>
    exams?: boolean | teachers$examsArgs<ExtArgs>
    performance?: boolean | teachers$performanceArgs<ExtArgs>
    student_routine?: boolean | teachers$student_routineArgs<ExtArgs>
    users?: boolean | teachers$usersArgs<ExtArgs>
    _count?: boolean | TeachersCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["teachers"]>

  export type teachersSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    specialised_subject?: boolean
    assigned_class?: boolean
    assigned_section?: boolean
    users?: boolean | teachers$usersArgs<ExtArgs>
  }, ExtArgs["result"]["teachers"]>

  export type teachersSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    specialised_subject?: boolean
    assigned_class?: boolean
    assigned_section?: boolean
    users?: boolean | teachers$usersArgs<ExtArgs>
  }, ExtArgs["result"]["teachers"]>

  export type teachersSelectScalar = {
    id?: boolean
    user_id?: boolean
    specialised_subject?: boolean
    assigned_class?: boolean
    assigned_section?: boolean
  }

  export type teachersOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "user_id" | "specialised_subject" | "assigned_class" | "assigned_section", ExtArgs["result"]["teachers"]>
  export type teachersInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assignments?: boolean | teachers$assignmentsArgs<ExtArgs>
    attendance?: boolean | teachers$attendanceArgs<ExtArgs>
    class_routine?: boolean | teachers$class_routineArgs<ExtArgs>
    class_teachers?: boolean | teachers$class_teachersArgs<ExtArgs>
    exams?: boolean | teachers$examsArgs<ExtArgs>
    performance?: boolean | teachers$performanceArgs<ExtArgs>
    student_routine?: boolean | teachers$student_routineArgs<ExtArgs>
    users?: boolean | teachers$usersArgs<ExtArgs>
    _count?: boolean | TeachersCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type teachersIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | teachers$usersArgs<ExtArgs>
  }
  export type teachersIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | teachers$usersArgs<ExtArgs>
  }

  export type $teachersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "teachers"
    objects: {
      assignments: Prisma.$assignmentsPayload<ExtArgs>[]
      attendance: Prisma.$attendancePayload<ExtArgs>[]
      class_routine: Prisma.$class_routinePayload<ExtArgs>[]
      class_teachers: Prisma.$class_teachersPayload<ExtArgs>[]
      exams: Prisma.$examsPayload<ExtArgs>[]
      performance: Prisma.$performancePayload<ExtArgs>[]
      student_routine: Prisma.$student_routinePayload<ExtArgs>[]
      users: Prisma.$usersPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      user_id: number | null
      specialised_subject: string
      assigned_class: string | null
      assigned_section: string | null
    }, ExtArgs["result"]["teachers"]>
    composites: {}
  }

  type teachersGetPayload<S extends boolean | null | undefined | teachersDefaultArgs> = $Result.GetResult<Prisma.$teachersPayload, S>

  type teachersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<teachersFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TeachersCountAggregateInputType | true
    }

  export interface teachersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['teachers'], meta: { name: 'teachers' } }
    /**
     * Find zero or one Teachers that matches the filter.
     * @param {teachersFindUniqueArgs} args - Arguments to find a Teachers
     * @example
     * // Get one Teachers
     * const teachers = await prisma.teachers.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends teachersFindUniqueArgs>(args: SelectSubset<T, teachersFindUniqueArgs<ExtArgs>>): Prisma__teachersClient<$Result.GetResult<Prisma.$teachersPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Teachers that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {teachersFindUniqueOrThrowArgs} args - Arguments to find a Teachers
     * @example
     * // Get one Teachers
     * const teachers = await prisma.teachers.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends teachersFindUniqueOrThrowArgs>(args: SelectSubset<T, teachersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__teachersClient<$Result.GetResult<Prisma.$teachersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Teachers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {teachersFindFirstArgs} args - Arguments to find a Teachers
     * @example
     * // Get one Teachers
     * const teachers = await prisma.teachers.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends teachersFindFirstArgs>(args?: SelectSubset<T, teachersFindFirstArgs<ExtArgs>>): Prisma__teachersClient<$Result.GetResult<Prisma.$teachersPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Teachers that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {teachersFindFirstOrThrowArgs} args - Arguments to find a Teachers
     * @example
     * // Get one Teachers
     * const teachers = await prisma.teachers.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends teachersFindFirstOrThrowArgs>(args?: SelectSubset<T, teachersFindFirstOrThrowArgs<ExtArgs>>): Prisma__teachersClient<$Result.GetResult<Prisma.$teachersPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Teachers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {teachersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Teachers
     * const teachers = await prisma.teachers.findMany()
     * 
     * // Get first 10 Teachers
     * const teachers = await prisma.teachers.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const teachersWithIdOnly = await prisma.teachers.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends teachersFindManyArgs>(args?: SelectSubset<T, teachersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$teachersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Teachers.
     * @param {teachersCreateArgs} args - Arguments to create a Teachers.
     * @example
     * // Create one Teachers
     * const Teachers = await prisma.teachers.create({
     *   data: {
     *     // ... data to create a Teachers
     *   }
     * })
     * 
     */
    create<T extends teachersCreateArgs>(args: SelectSubset<T, teachersCreateArgs<ExtArgs>>): Prisma__teachersClient<$Result.GetResult<Prisma.$teachersPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Teachers.
     * @param {teachersCreateManyArgs} args - Arguments to create many Teachers.
     * @example
     * // Create many Teachers
     * const teachers = await prisma.teachers.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends teachersCreateManyArgs>(args?: SelectSubset<T, teachersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Teachers and returns the data saved in the database.
     * @param {teachersCreateManyAndReturnArgs} args - Arguments to create many Teachers.
     * @example
     * // Create many Teachers
     * const teachers = await prisma.teachers.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Teachers and only return the `id`
     * const teachersWithIdOnly = await prisma.teachers.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends teachersCreateManyAndReturnArgs>(args?: SelectSubset<T, teachersCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$teachersPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Teachers.
     * @param {teachersDeleteArgs} args - Arguments to delete one Teachers.
     * @example
     * // Delete one Teachers
     * const Teachers = await prisma.teachers.delete({
     *   where: {
     *     // ... filter to delete one Teachers
     *   }
     * })
     * 
     */
    delete<T extends teachersDeleteArgs>(args: SelectSubset<T, teachersDeleteArgs<ExtArgs>>): Prisma__teachersClient<$Result.GetResult<Prisma.$teachersPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Teachers.
     * @param {teachersUpdateArgs} args - Arguments to update one Teachers.
     * @example
     * // Update one Teachers
     * const teachers = await prisma.teachers.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends teachersUpdateArgs>(args: SelectSubset<T, teachersUpdateArgs<ExtArgs>>): Prisma__teachersClient<$Result.GetResult<Prisma.$teachersPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Teachers.
     * @param {teachersDeleteManyArgs} args - Arguments to filter Teachers to delete.
     * @example
     * // Delete a few Teachers
     * const { count } = await prisma.teachers.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends teachersDeleteManyArgs>(args?: SelectSubset<T, teachersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Teachers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {teachersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Teachers
     * const teachers = await prisma.teachers.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends teachersUpdateManyArgs>(args: SelectSubset<T, teachersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Teachers and returns the data updated in the database.
     * @param {teachersUpdateManyAndReturnArgs} args - Arguments to update many Teachers.
     * @example
     * // Update many Teachers
     * const teachers = await prisma.teachers.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Teachers and only return the `id`
     * const teachersWithIdOnly = await prisma.teachers.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends teachersUpdateManyAndReturnArgs>(args: SelectSubset<T, teachersUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$teachersPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Teachers.
     * @param {teachersUpsertArgs} args - Arguments to update or create a Teachers.
     * @example
     * // Update or create a Teachers
     * const teachers = await prisma.teachers.upsert({
     *   create: {
     *     // ... data to create a Teachers
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Teachers we want to update
     *   }
     * })
     */
    upsert<T extends teachersUpsertArgs>(args: SelectSubset<T, teachersUpsertArgs<ExtArgs>>): Prisma__teachersClient<$Result.GetResult<Prisma.$teachersPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Teachers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {teachersCountArgs} args - Arguments to filter Teachers to count.
     * @example
     * // Count the number of Teachers
     * const count = await prisma.teachers.count({
     *   where: {
     *     // ... the filter for the Teachers we want to count
     *   }
     * })
    **/
    count<T extends teachersCountArgs>(
      args?: Subset<T, teachersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TeachersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Teachers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeachersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TeachersAggregateArgs>(args: Subset<T, TeachersAggregateArgs>): Prisma.PrismaPromise<GetTeachersAggregateType<T>>

    /**
     * Group by Teachers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {teachersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends teachersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: teachersGroupByArgs['orderBy'] }
        : { orderBy?: teachersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, teachersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTeachersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the teachers model
   */
  readonly fields: teachersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for teachers.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__teachersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    assignments<T extends teachers$assignmentsArgs<ExtArgs> = {}>(args?: Subset<T, teachers$assignmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$assignmentsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    attendance<T extends teachers$attendanceArgs<ExtArgs> = {}>(args?: Subset<T, teachers$attendanceArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$attendancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    class_routine<T extends teachers$class_routineArgs<ExtArgs> = {}>(args?: Subset<T, teachers$class_routineArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$class_routinePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    class_teachers<T extends teachers$class_teachersArgs<ExtArgs> = {}>(args?: Subset<T, teachers$class_teachersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$class_teachersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    exams<T extends teachers$examsArgs<ExtArgs> = {}>(args?: Subset<T, teachers$examsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$examsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    performance<T extends teachers$performanceArgs<ExtArgs> = {}>(args?: Subset<T, teachers$performanceArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$performancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    student_routine<T extends teachers$student_routineArgs<ExtArgs> = {}>(args?: Subset<T, teachers$student_routineArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$student_routinePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    users<T extends teachers$usersArgs<ExtArgs> = {}>(args?: Subset<T, teachers$usersArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the teachers model
   */
  interface teachersFieldRefs {
    readonly id: FieldRef<"teachers", 'Int'>
    readonly user_id: FieldRef<"teachers", 'Int'>
    readonly specialised_subject: FieldRef<"teachers", 'String'>
    readonly assigned_class: FieldRef<"teachers", 'String'>
    readonly assigned_section: FieldRef<"teachers", 'String'>
  }
    

  // Custom InputTypes
  /**
   * teachers findUnique
   */
  export type teachersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the teachers
     */
    select?: teachersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the teachers
     */
    omit?: teachersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teachersInclude<ExtArgs> | null
    /**
     * Filter, which teachers to fetch.
     */
    where: teachersWhereUniqueInput
  }

  /**
   * teachers findUniqueOrThrow
   */
  export type teachersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the teachers
     */
    select?: teachersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the teachers
     */
    omit?: teachersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teachersInclude<ExtArgs> | null
    /**
     * Filter, which teachers to fetch.
     */
    where: teachersWhereUniqueInput
  }

  /**
   * teachers findFirst
   */
  export type teachersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the teachers
     */
    select?: teachersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the teachers
     */
    omit?: teachersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teachersInclude<ExtArgs> | null
    /**
     * Filter, which teachers to fetch.
     */
    where?: teachersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of teachers to fetch.
     */
    orderBy?: teachersOrderByWithRelationInput | teachersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for teachers.
     */
    cursor?: teachersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` teachers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` teachers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of teachers.
     */
    distinct?: TeachersScalarFieldEnum | TeachersScalarFieldEnum[]
  }

  /**
   * teachers findFirstOrThrow
   */
  export type teachersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the teachers
     */
    select?: teachersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the teachers
     */
    omit?: teachersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teachersInclude<ExtArgs> | null
    /**
     * Filter, which teachers to fetch.
     */
    where?: teachersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of teachers to fetch.
     */
    orderBy?: teachersOrderByWithRelationInput | teachersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for teachers.
     */
    cursor?: teachersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` teachers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` teachers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of teachers.
     */
    distinct?: TeachersScalarFieldEnum | TeachersScalarFieldEnum[]
  }

  /**
   * teachers findMany
   */
  export type teachersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the teachers
     */
    select?: teachersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the teachers
     */
    omit?: teachersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teachersInclude<ExtArgs> | null
    /**
     * Filter, which teachers to fetch.
     */
    where?: teachersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of teachers to fetch.
     */
    orderBy?: teachersOrderByWithRelationInput | teachersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing teachers.
     */
    cursor?: teachersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` teachers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` teachers.
     */
    skip?: number
    distinct?: TeachersScalarFieldEnum | TeachersScalarFieldEnum[]
  }

  /**
   * teachers create
   */
  export type teachersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the teachers
     */
    select?: teachersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the teachers
     */
    omit?: teachersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teachersInclude<ExtArgs> | null
    /**
     * The data needed to create a teachers.
     */
    data: XOR<teachersCreateInput, teachersUncheckedCreateInput>
  }

  /**
   * teachers createMany
   */
  export type teachersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many teachers.
     */
    data: teachersCreateManyInput | teachersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * teachers createManyAndReturn
   */
  export type teachersCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the teachers
     */
    select?: teachersSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the teachers
     */
    omit?: teachersOmit<ExtArgs> | null
    /**
     * The data used to create many teachers.
     */
    data: teachersCreateManyInput | teachersCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teachersIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * teachers update
   */
  export type teachersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the teachers
     */
    select?: teachersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the teachers
     */
    omit?: teachersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teachersInclude<ExtArgs> | null
    /**
     * The data needed to update a teachers.
     */
    data: XOR<teachersUpdateInput, teachersUncheckedUpdateInput>
    /**
     * Choose, which teachers to update.
     */
    where: teachersWhereUniqueInput
  }

  /**
   * teachers updateMany
   */
  export type teachersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update teachers.
     */
    data: XOR<teachersUpdateManyMutationInput, teachersUncheckedUpdateManyInput>
    /**
     * Filter which teachers to update
     */
    where?: teachersWhereInput
    /**
     * Limit how many teachers to update.
     */
    limit?: number
  }

  /**
   * teachers updateManyAndReturn
   */
  export type teachersUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the teachers
     */
    select?: teachersSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the teachers
     */
    omit?: teachersOmit<ExtArgs> | null
    /**
     * The data used to update teachers.
     */
    data: XOR<teachersUpdateManyMutationInput, teachersUncheckedUpdateManyInput>
    /**
     * Filter which teachers to update
     */
    where?: teachersWhereInput
    /**
     * Limit how many teachers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teachersIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * teachers upsert
   */
  export type teachersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the teachers
     */
    select?: teachersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the teachers
     */
    omit?: teachersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teachersInclude<ExtArgs> | null
    /**
     * The filter to search for the teachers to update in case it exists.
     */
    where: teachersWhereUniqueInput
    /**
     * In case the teachers found by the `where` argument doesn't exist, create a new teachers with this data.
     */
    create: XOR<teachersCreateInput, teachersUncheckedCreateInput>
    /**
     * In case the teachers was found with the provided `where` argument, update it with this data.
     */
    update: XOR<teachersUpdateInput, teachersUncheckedUpdateInput>
  }

  /**
   * teachers delete
   */
  export type teachersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the teachers
     */
    select?: teachersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the teachers
     */
    omit?: teachersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teachersInclude<ExtArgs> | null
    /**
     * Filter which teachers to delete.
     */
    where: teachersWhereUniqueInput
  }

  /**
   * teachers deleteMany
   */
  export type teachersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which teachers to delete
     */
    where?: teachersWhereInput
    /**
     * Limit how many teachers to delete.
     */
    limit?: number
  }

  /**
   * teachers.assignments
   */
  export type teachers$assignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the assignments
     */
    select?: assignmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the assignments
     */
    omit?: assignmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: assignmentsInclude<ExtArgs> | null
    where?: assignmentsWhereInput
    orderBy?: assignmentsOrderByWithRelationInput | assignmentsOrderByWithRelationInput[]
    cursor?: assignmentsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AssignmentsScalarFieldEnum | AssignmentsScalarFieldEnum[]
  }

  /**
   * teachers.attendance
   */
  export type teachers$attendanceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the attendance
     */
    select?: attendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the attendance
     */
    omit?: attendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: attendanceInclude<ExtArgs> | null
    where?: attendanceWhereInput
    orderBy?: attendanceOrderByWithRelationInput | attendanceOrderByWithRelationInput[]
    cursor?: attendanceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AttendanceScalarFieldEnum | AttendanceScalarFieldEnum[]
  }

  /**
   * teachers.class_routine
   */
  export type teachers$class_routineArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the class_routine
     */
    select?: class_routineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the class_routine
     */
    omit?: class_routineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: class_routineInclude<ExtArgs> | null
    where?: class_routineWhereInput
    orderBy?: class_routineOrderByWithRelationInput | class_routineOrderByWithRelationInput[]
    cursor?: class_routineWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Class_routineScalarFieldEnum | Class_routineScalarFieldEnum[]
  }

  /**
   * teachers.class_teachers
   */
  export type teachers$class_teachersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the class_teachers
     */
    select?: class_teachersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the class_teachers
     */
    omit?: class_teachersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: class_teachersInclude<ExtArgs> | null
    where?: class_teachersWhereInput
    orderBy?: class_teachersOrderByWithRelationInput | class_teachersOrderByWithRelationInput[]
    cursor?: class_teachersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Class_teachersScalarFieldEnum | Class_teachersScalarFieldEnum[]
  }

  /**
   * teachers.exams
   */
  export type teachers$examsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the exams
     */
    select?: examsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the exams
     */
    omit?: examsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: examsInclude<ExtArgs> | null
    where?: examsWhereInput
    orderBy?: examsOrderByWithRelationInput | examsOrderByWithRelationInput[]
    cursor?: examsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExamsScalarFieldEnum | ExamsScalarFieldEnum[]
  }

  /**
   * teachers.performance
   */
  export type teachers$performanceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the performance
     */
    select?: performanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the performance
     */
    omit?: performanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: performanceInclude<ExtArgs> | null
    where?: performanceWhereInput
    orderBy?: performanceOrderByWithRelationInput | performanceOrderByWithRelationInput[]
    cursor?: performanceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PerformanceScalarFieldEnum | PerformanceScalarFieldEnum[]
  }

  /**
   * teachers.student_routine
   */
  export type teachers$student_routineArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the student_routine
     */
    select?: student_routineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the student_routine
     */
    omit?: student_routineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: student_routineInclude<ExtArgs> | null
    where?: student_routineWhereInput
    orderBy?: student_routineOrderByWithRelationInput | student_routineOrderByWithRelationInput[]
    cursor?: student_routineWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Student_routineScalarFieldEnum | Student_routineScalarFieldEnum[]
  }

  /**
   * teachers.users
   */
  export type teachers$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    where?: usersWhereInput
  }

  /**
   * teachers without action
   */
  export type teachersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the teachers
     */
    select?: teachersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the teachers
     */
    omit?: teachersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teachersInclude<ExtArgs> | null
  }


  /**
   * Model upcoming_events
   */

  export type AggregateUpcoming_events = {
    _count: Upcoming_eventsCountAggregateOutputType | null
    _avg: Upcoming_eventsAvgAggregateOutputType | null
    _sum: Upcoming_eventsSumAggregateOutputType | null
    _min: Upcoming_eventsMinAggregateOutputType | null
    _max: Upcoming_eventsMaxAggregateOutputType | null
  }

  export type Upcoming_eventsAvgAggregateOutputType = {
    id: number | null
    calendar_id: number | null
  }

  export type Upcoming_eventsSumAggregateOutputType = {
    id: number | null
    calendar_id: number | null
  }

  export type Upcoming_eventsMinAggregateOutputType = {
    id: number | null
    calendar_id: number | null
    event_date: Date | null
    event_name: string | null
    holiday: boolean | null
  }

  export type Upcoming_eventsMaxAggregateOutputType = {
    id: number | null
    calendar_id: number | null
    event_date: Date | null
    event_name: string | null
    holiday: boolean | null
  }

  export type Upcoming_eventsCountAggregateOutputType = {
    id: number
    calendar_id: number
    event_date: number
    event_name: number
    holiday: number
    _all: number
  }


  export type Upcoming_eventsAvgAggregateInputType = {
    id?: true
    calendar_id?: true
  }

  export type Upcoming_eventsSumAggregateInputType = {
    id?: true
    calendar_id?: true
  }

  export type Upcoming_eventsMinAggregateInputType = {
    id?: true
    calendar_id?: true
    event_date?: true
    event_name?: true
    holiday?: true
  }

  export type Upcoming_eventsMaxAggregateInputType = {
    id?: true
    calendar_id?: true
    event_date?: true
    event_name?: true
    holiday?: true
  }

  export type Upcoming_eventsCountAggregateInputType = {
    id?: true
    calendar_id?: true
    event_date?: true
    event_name?: true
    holiday?: true
    _all?: true
  }

  export type Upcoming_eventsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which upcoming_events to aggregate.
     */
    where?: upcoming_eventsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of upcoming_events to fetch.
     */
    orderBy?: upcoming_eventsOrderByWithRelationInput | upcoming_eventsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: upcoming_eventsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` upcoming_events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` upcoming_events.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned upcoming_events
    **/
    _count?: true | Upcoming_eventsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Upcoming_eventsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Upcoming_eventsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Upcoming_eventsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Upcoming_eventsMaxAggregateInputType
  }

  export type GetUpcoming_eventsAggregateType<T extends Upcoming_eventsAggregateArgs> = {
        [P in keyof T & keyof AggregateUpcoming_events]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUpcoming_events[P]>
      : GetScalarType<T[P], AggregateUpcoming_events[P]>
  }




  export type upcoming_eventsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: upcoming_eventsWhereInput
    orderBy?: upcoming_eventsOrderByWithAggregationInput | upcoming_eventsOrderByWithAggregationInput[]
    by: Upcoming_eventsScalarFieldEnum[] | Upcoming_eventsScalarFieldEnum
    having?: upcoming_eventsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Upcoming_eventsCountAggregateInputType | true
    _avg?: Upcoming_eventsAvgAggregateInputType
    _sum?: Upcoming_eventsSumAggregateInputType
    _min?: Upcoming_eventsMinAggregateInputType
    _max?: Upcoming_eventsMaxAggregateInputType
  }

  export type Upcoming_eventsGroupByOutputType = {
    id: number
    calendar_id: number | null
    event_date: Date
    event_name: string
    holiday: boolean
    _count: Upcoming_eventsCountAggregateOutputType | null
    _avg: Upcoming_eventsAvgAggregateOutputType | null
    _sum: Upcoming_eventsSumAggregateOutputType | null
    _min: Upcoming_eventsMinAggregateOutputType | null
    _max: Upcoming_eventsMaxAggregateOutputType | null
  }

  type GetUpcoming_eventsGroupByPayload<T extends upcoming_eventsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Upcoming_eventsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Upcoming_eventsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Upcoming_eventsGroupByOutputType[P]>
            : GetScalarType<T[P], Upcoming_eventsGroupByOutputType[P]>
        }
      >
    >


  export type upcoming_eventsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    calendar_id?: boolean
    event_date?: boolean
    event_name?: boolean
    holiday?: boolean
    calendar?: boolean | upcoming_events$calendarArgs<ExtArgs>
  }, ExtArgs["result"]["upcoming_events"]>

  export type upcoming_eventsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    calendar_id?: boolean
    event_date?: boolean
    event_name?: boolean
    holiday?: boolean
    calendar?: boolean | upcoming_events$calendarArgs<ExtArgs>
  }, ExtArgs["result"]["upcoming_events"]>

  export type upcoming_eventsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    calendar_id?: boolean
    event_date?: boolean
    event_name?: boolean
    holiday?: boolean
    calendar?: boolean | upcoming_events$calendarArgs<ExtArgs>
  }, ExtArgs["result"]["upcoming_events"]>

  export type upcoming_eventsSelectScalar = {
    id?: boolean
    calendar_id?: boolean
    event_date?: boolean
    event_name?: boolean
    holiday?: boolean
  }

  export type upcoming_eventsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "calendar_id" | "event_date" | "event_name" | "holiday", ExtArgs["result"]["upcoming_events"]>
  export type upcoming_eventsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    calendar?: boolean | upcoming_events$calendarArgs<ExtArgs>
  }
  export type upcoming_eventsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    calendar?: boolean | upcoming_events$calendarArgs<ExtArgs>
  }
  export type upcoming_eventsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    calendar?: boolean | upcoming_events$calendarArgs<ExtArgs>
  }

  export type $upcoming_eventsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "upcoming_events"
    objects: {
      calendar: Prisma.$calendarPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      calendar_id: number | null
      event_date: Date
      event_name: string
      holiday: boolean
    }, ExtArgs["result"]["upcoming_events"]>
    composites: {}
  }

  type upcoming_eventsGetPayload<S extends boolean | null | undefined | upcoming_eventsDefaultArgs> = $Result.GetResult<Prisma.$upcoming_eventsPayload, S>

  type upcoming_eventsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<upcoming_eventsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Upcoming_eventsCountAggregateInputType | true
    }

  export interface upcoming_eventsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['upcoming_events'], meta: { name: 'upcoming_events' } }
    /**
     * Find zero or one Upcoming_events that matches the filter.
     * @param {upcoming_eventsFindUniqueArgs} args - Arguments to find a Upcoming_events
     * @example
     * // Get one Upcoming_events
     * const upcoming_events = await prisma.upcoming_events.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends upcoming_eventsFindUniqueArgs>(args: SelectSubset<T, upcoming_eventsFindUniqueArgs<ExtArgs>>): Prisma__upcoming_eventsClient<$Result.GetResult<Prisma.$upcoming_eventsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Upcoming_events that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {upcoming_eventsFindUniqueOrThrowArgs} args - Arguments to find a Upcoming_events
     * @example
     * // Get one Upcoming_events
     * const upcoming_events = await prisma.upcoming_events.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends upcoming_eventsFindUniqueOrThrowArgs>(args: SelectSubset<T, upcoming_eventsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__upcoming_eventsClient<$Result.GetResult<Prisma.$upcoming_eventsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Upcoming_events that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {upcoming_eventsFindFirstArgs} args - Arguments to find a Upcoming_events
     * @example
     * // Get one Upcoming_events
     * const upcoming_events = await prisma.upcoming_events.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends upcoming_eventsFindFirstArgs>(args?: SelectSubset<T, upcoming_eventsFindFirstArgs<ExtArgs>>): Prisma__upcoming_eventsClient<$Result.GetResult<Prisma.$upcoming_eventsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Upcoming_events that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {upcoming_eventsFindFirstOrThrowArgs} args - Arguments to find a Upcoming_events
     * @example
     * // Get one Upcoming_events
     * const upcoming_events = await prisma.upcoming_events.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends upcoming_eventsFindFirstOrThrowArgs>(args?: SelectSubset<T, upcoming_eventsFindFirstOrThrowArgs<ExtArgs>>): Prisma__upcoming_eventsClient<$Result.GetResult<Prisma.$upcoming_eventsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Upcoming_events that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {upcoming_eventsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Upcoming_events
     * const upcoming_events = await prisma.upcoming_events.findMany()
     * 
     * // Get first 10 Upcoming_events
     * const upcoming_events = await prisma.upcoming_events.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const upcoming_eventsWithIdOnly = await prisma.upcoming_events.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends upcoming_eventsFindManyArgs>(args?: SelectSubset<T, upcoming_eventsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$upcoming_eventsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Upcoming_events.
     * @param {upcoming_eventsCreateArgs} args - Arguments to create a Upcoming_events.
     * @example
     * // Create one Upcoming_events
     * const Upcoming_events = await prisma.upcoming_events.create({
     *   data: {
     *     // ... data to create a Upcoming_events
     *   }
     * })
     * 
     */
    create<T extends upcoming_eventsCreateArgs>(args: SelectSubset<T, upcoming_eventsCreateArgs<ExtArgs>>): Prisma__upcoming_eventsClient<$Result.GetResult<Prisma.$upcoming_eventsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Upcoming_events.
     * @param {upcoming_eventsCreateManyArgs} args - Arguments to create many Upcoming_events.
     * @example
     * // Create many Upcoming_events
     * const upcoming_events = await prisma.upcoming_events.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends upcoming_eventsCreateManyArgs>(args?: SelectSubset<T, upcoming_eventsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Upcoming_events and returns the data saved in the database.
     * @param {upcoming_eventsCreateManyAndReturnArgs} args - Arguments to create many Upcoming_events.
     * @example
     * // Create many Upcoming_events
     * const upcoming_events = await prisma.upcoming_events.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Upcoming_events and only return the `id`
     * const upcoming_eventsWithIdOnly = await prisma.upcoming_events.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends upcoming_eventsCreateManyAndReturnArgs>(args?: SelectSubset<T, upcoming_eventsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$upcoming_eventsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Upcoming_events.
     * @param {upcoming_eventsDeleteArgs} args - Arguments to delete one Upcoming_events.
     * @example
     * // Delete one Upcoming_events
     * const Upcoming_events = await prisma.upcoming_events.delete({
     *   where: {
     *     // ... filter to delete one Upcoming_events
     *   }
     * })
     * 
     */
    delete<T extends upcoming_eventsDeleteArgs>(args: SelectSubset<T, upcoming_eventsDeleteArgs<ExtArgs>>): Prisma__upcoming_eventsClient<$Result.GetResult<Prisma.$upcoming_eventsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Upcoming_events.
     * @param {upcoming_eventsUpdateArgs} args - Arguments to update one Upcoming_events.
     * @example
     * // Update one Upcoming_events
     * const upcoming_events = await prisma.upcoming_events.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends upcoming_eventsUpdateArgs>(args: SelectSubset<T, upcoming_eventsUpdateArgs<ExtArgs>>): Prisma__upcoming_eventsClient<$Result.GetResult<Prisma.$upcoming_eventsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Upcoming_events.
     * @param {upcoming_eventsDeleteManyArgs} args - Arguments to filter Upcoming_events to delete.
     * @example
     * // Delete a few Upcoming_events
     * const { count } = await prisma.upcoming_events.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends upcoming_eventsDeleteManyArgs>(args?: SelectSubset<T, upcoming_eventsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Upcoming_events.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {upcoming_eventsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Upcoming_events
     * const upcoming_events = await prisma.upcoming_events.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends upcoming_eventsUpdateManyArgs>(args: SelectSubset<T, upcoming_eventsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Upcoming_events and returns the data updated in the database.
     * @param {upcoming_eventsUpdateManyAndReturnArgs} args - Arguments to update many Upcoming_events.
     * @example
     * // Update many Upcoming_events
     * const upcoming_events = await prisma.upcoming_events.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Upcoming_events and only return the `id`
     * const upcoming_eventsWithIdOnly = await prisma.upcoming_events.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends upcoming_eventsUpdateManyAndReturnArgs>(args: SelectSubset<T, upcoming_eventsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$upcoming_eventsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Upcoming_events.
     * @param {upcoming_eventsUpsertArgs} args - Arguments to update or create a Upcoming_events.
     * @example
     * // Update or create a Upcoming_events
     * const upcoming_events = await prisma.upcoming_events.upsert({
     *   create: {
     *     // ... data to create a Upcoming_events
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Upcoming_events we want to update
     *   }
     * })
     */
    upsert<T extends upcoming_eventsUpsertArgs>(args: SelectSubset<T, upcoming_eventsUpsertArgs<ExtArgs>>): Prisma__upcoming_eventsClient<$Result.GetResult<Prisma.$upcoming_eventsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Upcoming_events.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {upcoming_eventsCountArgs} args - Arguments to filter Upcoming_events to count.
     * @example
     * // Count the number of Upcoming_events
     * const count = await prisma.upcoming_events.count({
     *   where: {
     *     // ... the filter for the Upcoming_events we want to count
     *   }
     * })
    **/
    count<T extends upcoming_eventsCountArgs>(
      args?: Subset<T, upcoming_eventsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Upcoming_eventsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Upcoming_events.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Upcoming_eventsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Upcoming_eventsAggregateArgs>(args: Subset<T, Upcoming_eventsAggregateArgs>): Prisma.PrismaPromise<GetUpcoming_eventsAggregateType<T>>

    /**
     * Group by Upcoming_events.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {upcoming_eventsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends upcoming_eventsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: upcoming_eventsGroupByArgs['orderBy'] }
        : { orderBy?: upcoming_eventsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, upcoming_eventsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUpcoming_eventsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the upcoming_events model
   */
  readonly fields: upcoming_eventsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for upcoming_events.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__upcoming_eventsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    calendar<T extends upcoming_events$calendarArgs<ExtArgs> = {}>(args?: Subset<T, upcoming_events$calendarArgs<ExtArgs>>): Prisma__calendarClient<$Result.GetResult<Prisma.$calendarPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the upcoming_events model
   */
  interface upcoming_eventsFieldRefs {
    readonly id: FieldRef<"upcoming_events", 'Int'>
    readonly calendar_id: FieldRef<"upcoming_events", 'Int'>
    readonly event_date: FieldRef<"upcoming_events", 'DateTime'>
    readonly event_name: FieldRef<"upcoming_events", 'String'>
    readonly holiday: FieldRef<"upcoming_events", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * upcoming_events findUnique
   */
  export type upcoming_eventsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the upcoming_events
     */
    select?: upcoming_eventsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the upcoming_events
     */
    omit?: upcoming_eventsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: upcoming_eventsInclude<ExtArgs> | null
    /**
     * Filter, which upcoming_events to fetch.
     */
    where: upcoming_eventsWhereUniqueInput
  }

  /**
   * upcoming_events findUniqueOrThrow
   */
  export type upcoming_eventsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the upcoming_events
     */
    select?: upcoming_eventsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the upcoming_events
     */
    omit?: upcoming_eventsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: upcoming_eventsInclude<ExtArgs> | null
    /**
     * Filter, which upcoming_events to fetch.
     */
    where: upcoming_eventsWhereUniqueInput
  }

  /**
   * upcoming_events findFirst
   */
  export type upcoming_eventsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the upcoming_events
     */
    select?: upcoming_eventsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the upcoming_events
     */
    omit?: upcoming_eventsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: upcoming_eventsInclude<ExtArgs> | null
    /**
     * Filter, which upcoming_events to fetch.
     */
    where?: upcoming_eventsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of upcoming_events to fetch.
     */
    orderBy?: upcoming_eventsOrderByWithRelationInput | upcoming_eventsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for upcoming_events.
     */
    cursor?: upcoming_eventsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` upcoming_events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` upcoming_events.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of upcoming_events.
     */
    distinct?: Upcoming_eventsScalarFieldEnum | Upcoming_eventsScalarFieldEnum[]
  }

  /**
   * upcoming_events findFirstOrThrow
   */
  export type upcoming_eventsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the upcoming_events
     */
    select?: upcoming_eventsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the upcoming_events
     */
    omit?: upcoming_eventsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: upcoming_eventsInclude<ExtArgs> | null
    /**
     * Filter, which upcoming_events to fetch.
     */
    where?: upcoming_eventsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of upcoming_events to fetch.
     */
    orderBy?: upcoming_eventsOrderByWithRelationInput | upcoming_eventsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for upcoming_events.
     */
    cursor?: upcoming_eventsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` upcoming_events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` upcoming_events.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of upcoming_events.
     */
    distinct?: Upcoming_eventsScalarFieldEnum | Upcoming_eventsScalarFieldEnum[]
  }

  /**
   * upcoming_events findMany
   */
  export type upcoming_eventsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the upcoming_events
     */
    select?: upcoming_eventsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the upcoming_events
     */
    omit?: upcoming_eventsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: upcoming_eventsInclude<ExtArgs> | null
    /**
     * Filter, which upcoming_events to fetch.
     */
    where?: upcoming_eventsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of upcoming_events to fetch.
     */
    orderBy?: upcoming_eventsOrderByWithRelationInput | upcoming_eventsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing upcoming_events.
     */
    cursor?: upcoming_eventsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` upcoming_events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` upcoming_events.
     */
    skip?: number
    distinct?: Upcoming_eventsScalarFieldEnum | Upcoming_eventsScalarFieldEnum[]
  }

  /**
   * upcoming_events create
   */
  export type upcoming_eventsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the upcoming_events
     */
    select?: upcoming_eventsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the upcoming_events
     */
    omit?: upcoming_eventsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: upcoming_eventsInclude<ExtArgs> | null
    /**
     * The data needed to create a upcoming_events.
     */
    data: XOR<upcoming_eventsCreateInput, upcoming_eventsUncheckedCreateInput>
  }

  /**
   * upcoming_events createMany
   */
  export type upcoming_eventsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many upcoming_events.
     */
    data: upcoming_eventsCreateManyInput | upcoming_eventsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * upcoming_events createManyAndReturn
   */
  export type upcoming_eventsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the upcoming_events
     */
    select?: upcoming_eventsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the upcoming_events
     */
    omit?: upcoming_eventsOmit<ExtArgs> | null
    /**
     * The data used to create many upcoming_events.
     */
    data: upcoming_eventsCreateManyInput | upcoming_eventsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: upcoming_eventsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * upcoming_events update
   */
  export type upcoming_eventsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the upcoming_events
     */
    select?: upcoming_eventsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the upcoming_events
     */
    omit?: upcoming_eventsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: upcoming_eventsInclude<ExtArgs> | null
    /**
     * The data needed to update a upcoming_events.
     */
    data: XOR<upcoming_eventsUpdateInput, upcoming_eventsUncheckedUpdateInput>
    /**
     * Choose, which upcoming_events to update.
     */
    where: upcoming_eventsWhereUniqueInput
  }

  /**
   * upcoming_events updateMany
   */
  export type upcoming_eventsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update upcoming_events.
     */
    data: XOR<upcoming_eventsUpdateManyMutationInput, upcoming_eventsUncheckedUpdateManyInput>
    /**
     * Filter which upcoming_events to update
     */
    where?: upcoming_eventsWhereInput
    /**
     * Limit how many upcoming_events to update.
     */
    limit?: number
  }

  /**
   * upcoming_events updateManyAndReturn
   */
  export type upcoming_eventsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the upcoming_events
     */
    select?: upcoming_eventsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the upcoming_events
     */
    omit?: upcoming_eventsOmit<ExtArgs> | null
    /**
     * The data used to update upcoming_events.
     */
    data: XOR<upcoming_eventsUpdateManyMutationInput, upcoming_eventsUncheckedUpdateManyInput>
    /**
     * Filter which upcoming_events to update
     */
    where?: upcoming_eventsWhereInput
    /**
     * Limit how many upcoming_events to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: upcoming_eventsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * upcoming_events upsert
   */
  export type upcoming_eventsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the upcoming_events
     */
    select?: upcoming_eventsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the upcoming_events
     */
    omit?: upcoming_eventsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: upcoming_eventsInclude<ExtArgs> | null
    /**
     * The filter to search for the upcoming_events to update in case it exists.
     */
    where: upcoming_eventsWhereUniqueInput
    /**
     * In case the upcoming_events found by the `where` argument doesn't exist, create a new upcoming_events with this data.
     */
    create: XOR<upcoming_eventsCreateInput, upcoming_eventsUncheckedCreateInput>
    /**
     * In case the upcoming_events was found with the provided `where` argument, update it with this data.
     */
    update: XOR<upcoming_eventsUpdateInput, upcoming_eventsUncheckedUpdateInput>
  }

  /**
   * upcoming_events delete
   */
  export type upcoming_eventsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the upcoming_events
     */
    select?: upcoming_eventsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the upcoming_events
     */
    omit?: upcoming_eventsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: upcoming_eventsInclude<ExtArgs> | null
    /**
     * Filter which upcoming_events to delete.
     */
    where: upcoming_eventsWhereUniqueInput
  }

  /**
   * upcoming_events deleteMany
   */
  export type upcoming_eventsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which upcoming_events to delete
     */
    where?: upcoming_eventsWhereInput
    /**
     * Limit how many upcoming_events to delete.
     */
    limit?: number
  }

  /**
   * upcoming_events.calendar
   */
  export type upcoming_events$calendarArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the calendar
     */
    select?: calendarSelect<ExtArgs> | null
    /**
     * Omit specific fields from the calendar
     */
    omit?: calendarOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: calendarInclude<ExtArgs> | null
    where?: calendarWhereInput
  }

  /**
   * upcoming_events without action
   */
  export type upcoming_eventsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the upcoming_events
     */
    select?: upcoming_eventsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the upcoming_events
     */
    omit?: upcoming_eventsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: upcoming_eventsInclude<ExtArgs> | null
  }


  /**
   * Model users
   */

  export type AggregateUsers = {
    _count: UsersCountAggregateOutputType | null
    _avg: UsersAvgAggregateOutputType | null
    _sum: UsersSumAggregateOutputType | null
    _min: UsersMinAggregateOutputType | null
    _max: UsersMaxAggregateOutputType | null
  }

  export type UsersAvgAggregateOutputType = {
    id: number | null
  }

  export type UsersSumAggregateOutputType = {
    id: number | null
  }

  export type UsersMinAggregateOutputType = {
    id: number | null
    name: string | null
    email: string | null
    password: string | null
    role: string | null
    phone: string | null
    address: string | null
    photo: string | null
  }

  export type UsersMaxAggregateOutputType = {
    id: number | null
    name: string | null
    email: string | null
    password: string | null
    role: string | null
    phone: string | null
    address: string | null
    photo: string | null
  }

  export type UsersCountAggregateOutputType = {
    id: number
    name: number
    email: number
    password: number
    role: number
    phone: number
    address: number
    photo: number
    _all: number
  }


  export type UsersAvgAggregateInputType = {
    id?: true
  }

  export type UsersSumAggregateInputType = {
    id?: true
  }

  export type UsersMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    password?: true
    role?: true
    phone?: true
    address?: true
    photo?: true
  }

  export type UsersMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    password?: true
    role?: true
    phone?: true
    address?: true
    photo?: true
  }

  export type UsersCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    password?: true
    role?: true
    phone?: true
    address?: true
    photo?: true
    _all?: true
  }

  export type UsersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which users to aggregate.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned users
    **/
    _count?: true | UsersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UsersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UsersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsersMaxAggregateInputType
  }

  export type GetUsersAggregateType<T extends UsersAggregateArgs> = {
        [P in keyof T & keyof AggregateUsers]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsers[P]>
      : GetScalarType<T[P], AggregateUsers[P]>
  }




  export type usersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: usersWhereInput
    orderBy?: usersOrderByWithAggregationInput | usersOrderByWithAggregationInput[]
    by: UsersScalarFieldEnum[] | UsersScalarFieldEnum
    having?: usersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsersCountAggregateInputType | true
    _avg?: UsersAvgAggregateInputType
    _sum?: UsersSumAggregateInputType
    _min?: UsersMinAggregateInputType
    _max?: UsersMaxAggregateInputType
  }

  export type UsersGroupByOutputType = {
    id: number
    name: string
    email: string
    password: string
    role: string
    phone: string | null
    address: string | null
    photo: string | null
    _count: UsersCountAggregateOutputType | null
    _avg: UsersAvgAggregateOutputType | null
    _sum: UsersSumAggregateOutputType | null
    _min: UsersMinAggregateOutputType | null
    _max: UsersMaxAggregateOutputType | null
  }

  type GetUsersGroupByPayload<T extends usersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UsersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsersGroupByOutputType[P]>
            : GetScalarType<T[P], UsersGroupByOutputType[P]>
        }
      >
    >


  export type usersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    password?: boolean
    role?: boolean
    phone?: boolean
    address?: boolean
    photo?: boolean
    notes?: boolean | users$notesArgs<ExtArgs>
    notices?: boolean | users$noticesArgs<ExtArgs>
    students?: boolean | users$studentsArgs<ExtArgs>
    teacher_routine?: boolean | users$teacher_routineArgs<ExtArgs>
    teachers?: boolean | users$teachersArgs<ExtArgs>
    workroom_messages_workroom_messages_receiver_idTousers?: boolean | users$workroom_messages_workroom_messages_receiver_idTousersArgs<ExtArgs>
    workroom_messages_workroom_messages_sender_idTousers?: boolean | users$workroom_messages_workroom_messages_sender_idTousersArgs<ExtArgs>
    _count?: boolean | UsersCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["users"]>

  export type usersSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    password?: boolean
    role?: boolean
    phone?: boolean
    address?: boolean
    photo?: boolean
  }, ExtArgs["result"]["users"]>

  export type usersSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    password?: boolean
    role?: boolean
    phone?: boolean
    address?: boolean
    photo?: boolean
  }, ExtArgs["result"]["users"]>

  export type usersSelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
    password?: boolean
    role?: boolean
    phone?: boolean
    address?: boolean
    photo?: boolean
  }

  export type usersOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "email" | "password" | "role" | "phone" | "address" | "photo", ExtArgs["result"]["users"]>
  export type usersInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    notes?: boolean | users$notesArgs<ExtArgs>
    notices?: boolean | users$noticesArgs<ExtArgs>
    students?: boolean | users$studentsArgs<ExtArgs>
    teacher_routine?: boolean | users$teacher_routineArgs<ExtArgs>
    teachers?: boolean | users$teachersArgs<ExtArgs>
    workroom_messages_workroom_messages_receiver_idTousers?: boolean | users$workroom_messages_workroom_messages_receiver_idTousersArgs<ExtArgs>
    workroom_messages_workroom_messages_sender_idTousers?: boolean | users$workroom_messages_workroom_messages_sender_idTousersArgs<ExtArgs>
    _count?: boolean | UsersCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type usersIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type usersIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $usersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "users"
    objects: {
      notes: Prisma.$notesPayload<ExtArgs>[]
      notices: Prisma.$noticesPayload<ExtArgs>[]
      students: Prisma.$studentsPayload<ExtArgs>[]
      teacher_routine: Prisma.$teacher_routinePayload<ExtArgs>[]
      teachers: Prisma.$teachersPayload<ExtArgs>[]
      workroom_messages_workroom_messages_receiver_idTousers: Prisma.$workroom_messagesPayload<ExtArgs>[]
      workroom_messages_workroom_messages_sender_idTousers: Prisma.$workroom_messagesPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      email: string
      password: string
      role: string
      phone: string | null
      address: string | null
      photo: string | null
    }, ExtArgs["result"]["users"]>
    composites: {}
  }

  type usersGetPayload<S extends boolean | null | undefined | usersDefaultArgs> = $Result.GetResult<Prisma.$usersPayload, S>

  type usersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<usersFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UsersCountAggregateInputType | true
    }

  export interface usersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['users'], meta: { name: 'users' } }
    /**
     * Find zero or one Users that matches the filter.
     * @param {usersFindUniqueArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends usersFindUniqueArgs>(args: SelectSubset<T, usersFindUniqueArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Users that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {usersFindUniqueOrThrowArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends usersFindUniqueOrThrowArgs>(args: SelectSubset<T, usersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindFirstArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends usersFindFirstArgs>(args?: SelectSubset<T, usersFindFirstArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Users that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindFirstOrThrowArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends usersFindFirstOrThrowArgs>(args?: SelectSubset<T, usersFindFirstOrThrowArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.users.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.users.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const usersWithIdOnly = await prisma.users.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends usersFindManyArgs>(args?: SelectSubset<T, usersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Users.
     * @param {usersCreateArgs} args - Arguments to create a Users.
     * @example
     * // Create one Users
     * const Users = await prisma.users.create({
     *   data: {
     *     // ... data to create a Users
     *   }
     * })
     * 
     */
    create<T extends usersCreateArgs>(args: SelectSubset<T, usersCreateArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {usersCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const users = await prisma.users.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends usersCreateManyArgs>(args?: SelectSubset<T, usersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {usersCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const users = await prisma.users.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const usersWithIdOnly = await prisma.users.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends usersCreateManyAndReturnArgs>(args?: SelectSubset<T, usersCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Users.
     * @param {usersDeleteArgs} args - Arguments to delete one Users.
     * @example
     * // Delete one Users
     * const Users = await prisma.users.delete({
     *   where: {
     *     // ... filter to delete one Users
     *   }
     * })
     * 
     */
    delete<T extends usersDeleteArgs>(args: SelectSubset<T, usersDeleteArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Users.
     * @param {usersUpdateArgs} args - Arguments to update one Users.
     * @example
     * // Update one Users
     * const users = await prisma.users.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends usersUpdateArgs>(args: SelectSubset<T, usersUpdateArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {usersDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.users.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends usersDeleteManyArgs>(args?: SelectSubset<T, usersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const users = await prisma.users.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends usersUpdateManyArgs>(args: SelectSubset<T, usersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {usersUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const users = await prisma.users.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const usersWithIdOnly = await prisma.users.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends usersUpdateManyAndReturnArgs>(args: SelectSubset<T, usersUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Users.
     * @param {usersUpsertArgs} args - Arguments to update or create a Users.
     * @example
     * // Update or create a Users
     * const users = await prisma.users.upsert({
     *   create: {
     *     // ... data to create a Users
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Users we want to update
     *   }
     * })
     */
    upsert<T extends usersUpsertArgs>(args: SelectSubset<T, usersUpsertArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.users.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends usersCountArgs>(
      args?: Subset<T, usersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsersAggregateArgs>(args: Subset<T, UsersAggregateArgs>): Prisma.PrismaPromise<GetUsersAggregateType<T>>

    /**
     * Group by Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends usersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: usersGroupByArgs['orderBy'] }
        : { orderBy?: usersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, usersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the users model
   */
  readonly fields: usersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for users.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__usersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    notes<T extends users$notesArgs<ExtArgs> = {}>(args?: Subset<T, users$notesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$notesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    notices<T extends users$noticesArgs<ExtArgs> = {}>(args?: Subset<T, users$noticesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$noticesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    students<T extends users$studentsArgs<ExtArgs> = {}>(args?: Subset<T, users$studentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$studentsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    teacher_routine<T extends users$teacher_routineArgs<ExtArgs> = {}>(args?: Subset<T, users$teacher_routineArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$teacher_routinePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    teachers<T extends users$teachersArgs<ExtArgs> = {}>(args?: Subset<T, users$teachersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$teachersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    workroom_messages_workroom_messages_receiver_idTousers<T extends users$workroom_messages_workroom_messages_receiver_idTousersArgs<ExtArgs> = {}>(args?: Subset<T, users$workroom_messages_workroom_messages_receiver_idTousersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$workroom_messagesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    workroom_messages_workroom_messages_sender_idTousers<T extends users$workroom_messages_workroom_messages_sender_idTousersArgs<ExtArgs> = {}>(args?: Subset<T, users$workroom_messages_workroom_messages_sender_idTousersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$workroom_messagesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the users model
   */
  interface usersFieldRefs {
    readonly id: FieldRef<"users", 'Int'>
    readonly name: FieldRef<"users", 'String'>
    readonly email: FieldRef<"users", 'String'>
    readonly password: FieldRef<"users", 'String'>
    readonly role: FieldRef<"users", 'String'>
    readonly phone: FieldRef<"users", 'String'>
    readonly address: FieldRef<"users", 'String'>
    readonly photo: FieldRef<"users", 'String'>
  }
    

  // Custom InputTypes
  /**
   * users findUnique
   */
  export type usersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users findUniqueOrThrow
   */
  export type usersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users findFirst
   */
  export type usersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * users findFirstOrThrow
   */
  export type usersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * users findMany
   */
  export type usersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing users.
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * users create
   */
  export type usersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * The data needed to create a users.
     */
    data: XOR<usersCreateInput, usersUncheckedCreateInput>
  }

  /**
   * users createMany
   */
  export type usersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many users.
     */
    data: usersCreateManyInput | usersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * users createManyAndReturn
   */
  export type usersCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * The data used to create many users.
     */
    data: usersCreateManyInput | usersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * users update
   */
  export type usersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * The data needed to update a users.
     */
    data: XOR<usersUpdateInput, usersUncheckedUpdateInput>
    /**
     * Choose, which users to update.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users updateMany
   */
  export type usersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update users.
     */
    data: XOR<usersUpdateManyMutationInput, usersUncheckedUpdateManyInput>
    /**
     * Filter which users to update
     */
    where?: usersWhereInput
    /**
     * Limit how many users to update.
     */
    limit?: number
  }

  /**
   * users updateManyAndReturn
   */
  export type usersUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * The data used to update users.
     */
    data: XOR<usersUpdateManyMutationInput, usersUncheckedUpdateManyInput>
    /**
     * Filter which users to update
     */
    where?: usersWhereInput
    /**
     * Limit how many users to update.
     */
    limit?: number
  }

  /**
   * users upsert
   */
  export type usersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * The filter to search for the users to update in case it exists.
     */
    where: usersWhereUniqueInput
    /**
     * In case the users found by the `where` argument doesn't exist, create a new users with this data.
     */
    create: XOR<usersCreateInput, usersUncheckedCreateInput>
    /**
     * In case the users was found with the provided `where` argument, update it with this data.
     */
    update: XOR<usersUpdateInput, usersUncheckedUpdateInput>
  }

  /**
   * users delete
   */
  export type usersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter which users to delete.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users deleteMany
   */
  export type usersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which users to delete
     */
    where?: usersWhereInput
    /**
     * Limit how many users to delete.
     */
    limit?: number
  }

  /**
   * users.notes
   */
  export type users$notesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notes
     */
    select?: notesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notes
     */
    omit?: notesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notesInclude<ExtArgs> | null
    where?: notesWhereInput
    orderBy?: notesOrderByWithRelationInput | notesOrderByWithRelationInput[]
    cursor?: notesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotesScalarFieldEnum | NotesScalarFieldEnum[]
  }

  /**
   * users.notices
   */
  export type users$noticesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notices
     */
    select?: noticesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notices
     */
    omit?: noticesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: noticesInclude<ExtArgs> | null
    where?: noticesWhereInput
    orderBy?: noticesOrderByWithRelationInput | noticesOrderByWithRelationInput[]
    cursor?: noticesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NoticesScalarFieldEnum | NoticesScalarFieldEnum[]
  }

  /**
   * users.students
   */
  export type users$studentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the students
     */
    select?: studentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the students
     */
    omit?: studentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: studentsInclude<ExtArgs> | null
    where?: studentsWhereInput
    orderBy?: studentsOrderByWithRelationInput | studentsOrderByWithRelationInput[]
    cursor?: studentsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentsScalarFieldEnum | StudentsScalarFieldEnum[]
  }

  /**
   * users.teacher_routine
   */
  export type users$teacher_routineArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the teacher_routine
     */
    select?: teacher_routineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the teacher_routine
     */
    omit?: teacher_routineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teacher_routineInclude<ExtArgs> | null
    where?: teacher_routineWhereInput
    orderBy?: teacher_routineOrderByWithRelationInput | teacher_routineOrderByWithRelationInput[]
    cursor?: teacher_routineWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Teacher_routineScalarFieldEnum | Teacher_routineScalarFieldEnum[]
  }

  /**
   * users.teachers
   */
  export type users$teachersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the teachers
     */
    select?: teachersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the teachers
     */
    omit?: teachersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teachersInclude<ExtArgs> | null
    where?: teachersWhereInput
    orderBy?: teachersOrderByWithRelationInput | teachersOrderByWithRelationInput[]
    cursor?: teachersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TeachersScalarFieldEnum | TeachersScalarFieldEnum[]
  }

  /**
   * users.workroom_messages_workroom_messages_receiver_idTousers
   */
  export type users$workroom_messages_workroom_messages_receiver_idTousersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the workroom_messages
     */
    select?: workroom_messagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the workroom_messages
     */
    omit?: workroom_messagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: workroom_messagesInclude<ExtArgs> | null
    where?: workroom_messagesWhereInput
    orderBy?: workroom_messagesOrderByWithRelationInput | workroom_messagesOrderByWithRelationInput[]
    cursor?: workroom_messagesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Workroom_messagesScalarFieldEnum | Workroom_messagesScalarFieldEnum[]
  }

  /**
   * users.workroom_messages_workroom_messages_sender_idTousers
   */
  export type users$workroom_messages_workroom_messages_sender_idTousersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the workroom_messages
     */
    select?: workroom_messagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the workroom_messages
     */
    omit?: workroom_messagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: workroom_messagesInclude<ExtArgs> | null
    where?: workroom_messagesWhereInput
    orderBy?: workroom_messagesOrderByWithRelationInput | workroom_messagesOrderByWithRelationInput[]
    cursor?: workroom_messagesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Workroom_messagesScalarFieldEnum | Workroom_messagesScalarFieldEnum[]
  }

  /**
   * users without action
   */
  export type usersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
  }


  /**
   * Model workroom_messages
   */

  export type AggregateWorkroom_messages = {
    _count: Workroom_messagesCountAggregateOutputType | null
    _avg: Workroom_messagesAvgAggregateOutputType | null
    _sum: Workroom_messagesSumAggregateOutputType | null
    _min: Workroom_messagesMinAggregateOutputType | null
    _max: Workroom_messagesMaxAggregateOutputType | null
  }

  export type Workroom_messagesAvgAggregateOutputType = {
    id: number | null
    sender_id: number | null
    receiver_id: number | null
  }

  export type Workroom_messagesSumAggregateOutputType = {
    id: number | null
    sender_id: number | null
    receiver_id: number | null
  }

  export type Workroom_messagesMinAggregateOutputType = {
    id: number | null
    sender_id: number | null
    receiver_id: number | null
    message: string | null
    sent_at: Date | null
  }

  export type Workroom_messagesMaxAggregateOutputType = {
    id: number | null
    sender_id: number | null
    receiver_id: number | null
    message: string | null
    sent_at: Date | null
  }

  export type Workroom_messagesCountAggregateOutputType = {
    id: number
    sender_id: number
    receiver_id: number
    message: number
    sent_at: number
    _all: number
  }


  export type Workroom_messagesAvgAggregateInputType = {
    id?: true
    sender_id?: true
    receiver_id?: true
  }

  export type Workroom_messagesSumAggregateInputType = {
    id?: true
    sender_id?: true
    receiver_id?: true
  }

  export type Workroom_messagesMinAggregateInputType = {
    id?: true
    sender_id?: true
    receiver_id?: true
    message?: true
    sent_at?: true
  }

  export type Workroom_messagesMaxAggregateInputType = {
    id?: true
    sender_id?: true
    receiver_id?: true
    message?: true
    sent_at?: true
  }

  export type Workroom_messagesCountAggregateInputType = {
    id?: true
    sender_id?: true
    receiver_id?: true
    message?: true
    sent_at?: true
    _all?: true
  }

  export type Workroom_messagesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which workroom_messages to aggregate.
     */
    where?: workroom_messagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of workroom_messages to fetch.
     */
    orderBy?: workroom_messagesOrderByWithRelationInput | workroom_messagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: workroom_messagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` workroom_messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` workroom_messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned workroom_messages
    **/
    _count?: true | Workroom_messagesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Workroom_messagesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Workroom_messagesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Workroom_messagesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Workroom_messagesMaxAggregateInputType
  }

  export type GetWorkroom_messagesAggregateType<T extends Workroom_messagesAggregateArgs> = {
        [P in keyof T & keyof AggregateWorkroom_messages]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWorkroom_messages[P]>
      : GetScalarType<T[P], AggregateWorkroom_messages[P]>
  }




  export type workroom_messagesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: workroom_messagesWhereInput
    orderBy?: workroom_messagesOrderByWithAggregationInput | workroom_messagesOrderByWithAggregationInput[]
    by: Workroom_messagesScalarFieldEnum[] | Workroom_messagesScalarFieldEnum
    having?: workroom_messagesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Workroom_messagesCountAggregateInputType | true
    _avg?: Workroom_messagesAvgAggregateInputType
    _sum?: Workroom_messagesSumAggregateInputType
    _min?: Workroom_messagesMinAggregateInputType
    _max?: Workroom_messagesMaxAggregateInputType
  }

  export type Workroom_messagesGroupByOutputType = {
    id: number
    sender_id: number | null
    receiver_id: number | null
    message: string
    sent_at: Date | null
    _count: Workroom_messagesCountAggregateOutputType | null
    _avg: Workroom_messagesAvgAggregateOutputType | null
    _sum: Workroom_messagesSumAggregateOutputType | null
    _min: Workroom_messagesMinAggregateOutputType | null
    _max: Workroom_messagesMaxAggregateOutputType | null
  }

  type GetWorkroom_messagesGroupByPayload<T extends workroom_messagesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Workroom_messagesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Workroom_messagesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Workroom_messagesGroupByOutputType[P]>
            : GetScalarType<T[P], Workroom_messagesGroupByOutputType[P]>
        }
      >
    >


  export type workroom_messagesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sender_id?: boolean
    receiver_id?: boolean
    message?: boolean
    sent_at?: boolean
    users_workroom_messages_receiver_idTousers?: boolean | workroom_messages$users_workroom_messages_receiver_idTousersArgs<ExtArgs>
    users_workroom_messages_sender_idTousers?: boolean | workroom_messages$users_workroom_messages_sender_idTousersArgs<ExtArgs>
  }, ExtArgs["result"]["workroom_messages"]>

  export type workroom_messagesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sender_id?: boolean
    receiver_id?: boolean
    message?: boolean
    sent_at?: boolean
    users_workroom_messages_receiver_idTousers?: boolean | workroom_messages$users_workroom_messages_receiver_idTousersArgs<ExtArgs>
    users_workroom_messages_sender_idTousers?: boolean | workroom_messages$users_workroom_messages_sender_idTousersArgs<ExtArgs>
  }, ExtArgs["result"]["workroom_messages"]>

  export type workroom_messagesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sender_id?: boolean
    receiver_id?: boolean
    message?: boolean
    sent_at?: boolean
    users_workroom_messages_receiver_idTousers?: boolean | workroom_messages$users_workroom_messages_receiver_idTousersArgs<ExtArgs>
    users_workroom_messages_sender_idTousers?: boolean | workroom_messages$users_workroom_messages_sender_idTousersArgs<ExtArgs>
  }, ExtArgs["result"]["workroom_messages"]>

  export type workroom_messagesSelectScalar = {
    id?: boolean
    sender_id?: boolean
    receiver_id?: boolean
    message?: boolean
    sent_at?: boolean
  }

  export type workroom_messagesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "sender_id" | "receiver_id" | "message" | "sent_at", ExtArgs["result"]["workroom_messages"]>
  export type workroom_messagesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users_workroom_messages_receiver_idTousers?: boolean | workroom_messages$users_workroom_messages_receiver_idTousersArgs<ExtArgs>
    users_workroom_messages_sender_idTousers?: boolean | workroom_messages$users_workroom_messages_sender_idTousersArgs<ExtArgs>
  }
  export type workroom_messagesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users_workroom_messages_receiver_idTousers?: boolean | workroom_messages$users_workroom_messages_receiver_idTousersArgs<ExtArgs>
    users_workroom_messages_sender_idTousers?: boolean | workroom_messages$users_workroom_messages_sender_idTousersArgs<ExtArgs>
  }
  export type workroom_messagesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users_workroom_messages_receiver_idTousers?: boolean | workroom_messages$users_workroom_messages_receiver_idTousersArgs<ExtArgs>
    users_workroom_messages_sender_idTousers?: boolean | workroom_messages$users_workroom_messages_sender_idTousersArgs<ExtArgs>
  }

  export type $workroom_messagesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "workroom_messages"
    objects: {
      users_workroom_messages_receiver_idTousers: Prisma.$usersPayload<ExtArgs> | null
      users_workroom_messages_sender_idTousers: Prisma.$usersPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      sender_id: number | null
      receiver_id: number | null
      message: string
      sent_at: Date | null
    }, ExtArgs["result"]["workroom_messages"]>
    composites: {}
  }

  type workroom_messagesGetPayload<S extends boolean | null | undefined | workroom_messagesDefaultArgs> = $Result.GetResult<Prisma.$workroom_messagesPayload, S>

  type workroom_messagesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<workroom_messagesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Workroom_messagesCountAggregateInputType | true
    }

  export interface workroom_messagesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['workroom_messages'], meta: { name: 'workroom_messages' } }
    /**
     * Find zero or one Workroom_messages that matches the filter.
     * @param {workroom_messagesFindUniqueArgs} args - Arguments to find a Workroom_messages
     * @example
     * // Get one Workroom_messages
     * const workroom_messages = await prisma.workroom_messages.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends workroom_messagesFindUniqueArgs>(args: SelectSubset<T, workroom_messagesFindUniqueArgs<ExtArgs>>): Prisma__workroom_messagesClient<$Result.GetResult<Prisma.$workroom_messagesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Workroom_messages that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {workroom_messagesFindUniqueOrThrowArgs} args - Arguments to find a Workroom_messages
     * @example
     * // Get one Workroom_messages
     * const workroom_messages = await prisma.workroom_messages.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends workroom_messagesFindUniqueOrThrowArgs>(args: SelectSubset<T, workroom_messagesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__workroom_messagesClient<$Result.GetResult<Prisma.$workroom_messagesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Workroom_messages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {workroom_messagesFindFirstArgs} args - Arguments to find a Workroom_messages
     * @example
     * // Get one Workroom_messages
     * const workroom_messages = await prisma.workroom_messages.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends workroom_messagesFindFirstArgs>(args?: SelectSubset<T, workroom_messagesFindFirstArgs<ExtArgs>>): Prisma__workroom_messagesClient<$Result.GetResult<Prisma.$workroom_messagesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Workroom_messages that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {workroom_messagesFindFirstOrThrowArgs} args - Arguments to find a Workroom_messages
     * @example
     * // Get one Workroom_messages
     * const workroom_messages = await prisma.workroom_messages.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends workroom_messagesFindFirstOrThrowArgs>(args?: SelectSubset<T, workroom_messagesFindFirstOrThrowArgs<ExtArgs>>): Prisma__workroom_messagesClient<$Result.GetResult<Prisma.$workroom_messagesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Workroom_messages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {workroom_messagesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Workroom_messages
     * const workroom_messages = await prisma.workroom_messages.findMany()
     * 
     * // Get first 10 Workroom_messages
     * const workroom_messages = await prisma.workroom_messages.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const workroom_messagesWithIdOnly = await prisma.workroom_messages.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends workroom_messagesFindManyArgs>(args?: SelectSubset<T, workroom_messagesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$workroom_messagesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Workroom_messages.
     * @param {workroom_messagesCreateArgs} args - Arguments to create a Workroom_messages.
     * @example
     * // Create one Workroom_messages
     * const Workroom_messages = await prisma.workroom_messages.create({
     *   data: {
     *     // ... data to create a Workroom_messages
     *   }
     * })
     * 
     */
    create<T extends workroom_messagesCreateArgs>(args: SelectSubset<T, workroom_messagesCreateArgs<ExtArgs>>): Prisma__workroom_messagesClient<$Result.GetResult<Prisma.$workroom_messagesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Workroom_messages.
     * @param {workroom_messagesCreateManyArgs} args - Arguments to create many Workroom_messages.
     * @example
     * // Create many Workroom_messages
     * const workroom_messages = await prisma.workroom_messages.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends workroom_messagesCreateManyArgs>(args?: SelectSubset<T, workroom_messagesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Workroom_messages and returns the data saved in the database.
     * @param {workroom_messagesCreateManyAndReturnArgs} args - Arguments to create many Workroom_messages.
     * @example
     * // Create many Workroom_messages
     * const workroom_messages = await prisma.workroom_messages.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Workroom_messages and only return the `id`
     * const workroom_messagesWithIdOnly = await prisma.workroom_messages.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends workroom_messagesCreateManyAndReturnArgs>(args?: SelectSubset<T, workroom_messagesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$workroom_messagesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Workroom_messages.
     * @param {workroom_messagesDeleteArgs} args - Arguments to delete one Workroom_messages.
     * @example
     * // Delete one Workroom_messages
     * const Workroom_messages = await prisma.workroom_messages.delete({
     *   where: {
     *     // ... filter to delete one Workroom_messages
     *   }
     * })
     * 
     */
    delete<T extends workroom_messagesDeleteArgs>(args: SelectSubset<T, workroom_messagesDeleteArgs<ExtArgs>>): Prisma__workroom_messagesClient<$Result.GetResult<Prisma.$workroom_messagesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Workroom_messages.
     * @param {workroom_messagesUpdateArgs} args - Arguments to update one Workroom_messages.
     * @example
     * // Update one Workroom_messages
     * const workroom_messages = await prisma.workroom_messages.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends workroom_messagesUpdateArgs>(args: SelectSubset<T, workroom_messagesUpdateArgs<ExtArgs>>): Prisma__workroom_messagesClient<$Result.GetResult<Prisma.$workroom_messagesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Workroom_messages.
     * @param {workroom_messagesDeleteManyArgs} args - Arguments to filter Workroom_messages to delete.
     * @example
     * // Delete a few Workroom_messages
     * const { count } = await prisma.workroom_messages.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends workroom_messagesDeleteManyArgs>(args?: SelectSubset<T, workroom_messagesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Workroom_messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {workroom_messagesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Workroom_messages
     * const workroom_messages = await prisma.workroom_messages.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends workroom_messagesUpdateManyArgs>(args: SelectSubset<T, workroom_messagesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Workroom_messages and returns the data updated in the database.
     * @param {workroom_messagesUpdateManyAndReturnArgs} args - Arguments to update many Workroom_messages.
     * @example
     * // Update many Workroom_messages
     * const workroom_messages = await prisma.workroom_messages.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Workroom_messages and only return the `id`
     * const workroom_messagesWithIdOnly = await prisma.workroom_messages.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends workroom_messagesUpdateManyAndReturnArgs>(args: SelectSubset<T, workroom_messagesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$workroom_messagesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Workroom_messages.
     * @param {workroom_messagesUpsertArgs} args - Arguments to update or create a Workroom_messages.
     * @example
     * // Update or create a Workroom_messages
     * const workroom_messages = await prisma.workroom_messages.upsert({
     *   create: {
     *     // ... data to create a Workroom_messages
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Workroom_messages we want to update
     *   }
     * })
     */
    upsert<T extends workroom_messagesUpsertArgs>(args: SelectSubset<T, workroom_messagesUpsertArgs<ExtArgs>>): Prisma__workroom_messagesClient<$Result.GetResult<Prisma.$workroom_messagesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Workroom_messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {workroom_messagesCountArgs} args - Arguments to filter Workroom_messages to count.
     * @example
     * // Count the number of Workroom_messages
     * const count = await prisma.workroom_messages.count({
     *   where: {
     *     // ... the filter for the Workroom_messages we want to count
     *   }
     * })
    **/
    count<T extends workroom_messagesCountArgs>(
      args?: Subset<T, workroom_messagesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Workroom_messagesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Workroom_messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Workroom_messagesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Workroom_messagesAggregateArgs>(args: Subset<T, Workroom_messagesAggregateArgs>): Prisma.PrismaPromise<GetWorkroom_messagesAggregateType<T>>

    /**
     * Group by Workroom_messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {workroom_messagesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends workroom_messagesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: workroom_messagesGroupByArgs['orderBy'] }
        : { orderBy?: workroom_messagesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, workroom_messagesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWorkroom_messagesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the workroom_messages model
   */
  readonly fields: workroom_messagesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for workroom_messages.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__workroom_messagesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users_workroom_messages_receiver_idTousers<T extends workroom_messages$users_workroom_messages_receiver_idTousersArgs<ExtArgs> = {}>(args?: Subset<T, workroom_messages$users_workroom_messages_receiver_idTousersArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    users_workroom_messages_sender_idTousers<T extends workroom_messages$users_workroom_messages_sender_idTousersArgs<ExtArgs> = {}>(args?: Subset<T, workroom_messages$users_workroom_messages_sender_idTousersArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the workroom_messages model
   */
  interface workroom_messagesFieldRefs {
    readonly id: FieldRef<"workroom_messages", 'Int'>
    readonly sender_id: FieldRef<"workroom_messages", 'Int'>
    readonly receiver_id: FieldRef<"workroom_messages", 'Int'>
    readonly message: FieldRef<"workroom_messages", 'String'>
    readonly sent_at: FieldRef<"workroom_messages", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * workroom_messages findUnique
   */
  export type workroom_messagesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the workroom_messages
     */
    select?: workroom_messagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the workroom_messages
     */
    omit?: workroom_messagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: workroom_messagesInclude<ExtArgs> | null
    /**
     * Filter, which workroom_messages to fetch.
     */
    where: workroom_messagesWhereUniqueInput
  }

  /**
   * workroom_messages findUniqueOrThrow
   */
  export type workroom_messagesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the workroom_messages
     */
    select?: workroom_messagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the workroom_messages
     */
    omit?: workroom_messagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: workroom_messagesInclude<ExtArgs> | null
    /**
     * Filter, which workroom_messages to fetch.
     */
    where: workroom_messagesWhereUniqueInput
  }

  /**
   * workroom_messages findFirst
   */
  export type workroom_messagesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the workroom_messages
     */
    select?: workroom_messagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the workroom_messages
     */
    omit?: workroom_messagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: workroom_messagesInclude<ExtArgs> | null
    /**
     * Filter, which workroom_messages to fetch.
     */
    where?: workroom_messagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of workroom_messages to fetch.
     */
    orderBy?: workroom_messagesOrderByWithRelationInput | workroom_messagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for workroom_messages.
     */
    cursor?: workroom_messagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` workroom_messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` workroom_messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of workroom_messages.
     */
    distinct?: Workroom_messagesScalarFieldEnum | Workroom_messagesScalarFieldEnum[]
  }

  /**
   * workroom_messages findFirstOrThrow
   */
  export type workroom_messagesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the workroom_messages
     */
    select?: workroom_messagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the workroom_messages
     */
    omit?: workroom_messagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: workroom_messagesInclude<ExtArgs> | null
    /**
     * Filter, which workroom_messages to fetch.
     */
    where?: workroom_messagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of workroom_messages to fetch.
     */
    orderBy?: workroom_messagesOrderByWithRelationInput | workroom_messagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for workroom_messages.
     */
    cursor?: workroom_messagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` workroom_messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` workroom_messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of workroom_messages.
     */
    distinct?: Workroom_messagesScalarFieldEnum | Workroom_messagesScalarFieldEnum[]
  }

  /**
   * workroom_messages findMany
   */
  export type workroom_messagesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the workroom_messages
     */
    select?: workroom_messagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the workroom_messages
     */
    omit?: workroom_messagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: workroom_messagesInclude<ExtArgs> | null
    /**
     * Filter, which workroom_messages to fetch.
     */
    where?: workroom_messagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of workroom_messages to fetch.
     */
    orderBy?: workroom_messagesOrderByWithRelationInput | workroom_messagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing workroom_messages.
     */
    cursor?: workroom_messagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` workroom_messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` workroom_messages.
     */
    skip?: number
    distinct?: Workroom_messagesScalarFieldEnum | Workroom_messagesScalarFieldEnum[]
  }

  /**
   * workroom_messages create
   */
  export type workroom_messagesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the workroom_messages
     */
    select?: workroom_messagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the workroom_messages
     */
    omit?: workroom_messagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: workroom_messagesInclude<ExtArgs> | null
    /**
     * The data needed to create a workroom_messages.
     */
    data: XOR<workroom_messagesCreateInput, workroom_messagesUncheckedCreateInput>
  }

  /**
   * workroom_messages createMany
   */
  export type workroom_messagesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many workroom_messages.
     */
    data: workroom_messagesCreateManyInput | workroom_messagesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * workroom_messages createManyAndReturn
   */
  export type workroom_messagesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the workroom_messages
     */
    select?: workroom_messagesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the workroom_messages
     */
    omit?: workroom_messagesOmit<ExtArgs> | null
    /**
     * The data used to create many workroom_messages.
     */
    data: workroom_messagesCreateManyInput | workroom_messagesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: workroom_messagesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * workroom_messages update
   */
  export type workroom_messagesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the workroom_messages
     */
    select?: workroom_messagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the workroom_messages
     */
    omit?: workroom_messagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: workroom_messagesInclude<ExtArgs> | null
    /**
     * The data needed to update a workroom_messages.
     */
    data: XOR<workroom_messagesUpdateInput, workroom_messagesUncheckedUpdateInput>
    /**
     * Choose, which workroom_messages to update.
     */
    where: workroom_messagesWhereUniqueInput
  }

  /**
   * workroom_messages updateMany
   */
  export type workroom_messagesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update workroom_messages.
     */
    data: XOR<workroom_messagesUpdateManyMutationInput, workroom_messagesUncheckedUpdateManyInput>
    /**
     * Filter which workroom_messages to update
     */
    where?: workroom_messagesWhereInput
    /**
     * Limit how many workroom_messages to update.
     */
    limit?: number
  }

  /**
   * workroom_messages updateManyAndReturn
   */
  export type workroom_messagesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the workroom_messages
     */
    select?: workroom_messagesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the workroom_messages
     */
    omit?: workroom_messagesOmit<ExtArgs> | null
    /**
     * The data used to update workroom_messages.
     */
    data: XOR<workroom_messagesUpdateManyMutationInput, workroom_messagesUncheckedUpdateManyInput>
    /**
     * Filter which workroom_messages to update
     */
    where?: workroom_messagesWhereInput
    /**
     * Limit how many workroom_messages to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: workroom_messagesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * workroom_messages upsert
   */
  export type workroom_messagesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the workroom_messages
     */
    select?: workroom_messagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the workroom_messages
     */
    omit?: workroom_messagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: workroom_messagesInclude<ExtArgs> | null
    /**
     * The filter to search for the workroom_messages to update in case it exists.
     */
    where: workroom_messagesWhereUniqueInput
    /**
     * In case the workroom_messages found by the `where` argument doesn't exist, create a new workroom_messages with this data.
     */
    create: XOR<workroom_messagesCreateInput, workroom_messagesUncheckedCreateInput>
    /**
     * In case the workroom_messages was found with the provided `where` argument, update it with this data.
     */
    update: XOR<workroom_messagesUpdateInput, workroom_messagesUncheckedUpdateInput>
  }

  /**
   * workroom_messages delete
   */
  export type workroom_messagesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the workroom_messages
     */
    select?: workroom_messagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the workroom_messages
     */
    omit?: workroom_messagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: workroom_messagesInclude<ExtArgs> | null
    /**
     * Filter which workroom_messages to delete.
     */
    where: workroom_messagesWhereUniqueInput
  }

  /**
   * workroom_messages deleteMany
   */
  export type workroom_messagesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which workroom_messages to delete
     */
    where?: workroom_messagesWhereInput
    /**
     * Limit how many workroom_messages to delete.
     */
    limit?: number
  }

  /**
   * workroom_messages.users_workroom_messages_receiver_idTousers
   */
  export type workroom_messages$users_workroom_messages_receiver_idTousersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    where?: usersWhereInput
  }

  /**
   * workroom_messages.users_workroom_messages_sender_idTousers
   */
  export type workroom_messages$users_workroom_messages_sender_idTousersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    where?: usersWhereInput
  }

  /**
   * workroom_messages without action
   */
  export type workroom_messagesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the workroom_messages
     */
    select?: workroom_messagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the workroom_messages
     */
    omit?: workroom_messagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: workroom_messagesInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const AssignmentsScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    subject: 'subject',
    class: 'class',
    section: 'section',
    assigned_by: 'assigned_by',
    due_date: 'due_date',
    file: 'file'
  };

  export type AssignmentsScalarFieldEnum = (typeof AssignmentsScalarFieldEnum)[keyof typeof AssignmentsScalarFieldEnum]


  export const AttendanceScalarFieldEnum: {
    id: 'id',
    student_id: 'student_id',
    teacher_id: 'teacher_id',
    class: 'class',
    section: 'section',
    date: 'date',
    status: 'status',
    created_at: 'created_at'
  };

  export type AttendanceScalarFieldEnum = (typeof AttendanceScalarFieldEnum)[keyof typeof AttendanceScalarFieldEnum]


  export const CalendarScalarFieldEnum: {
    id: 'id',
    month: 'month',
    calendar: 'calendar',
    year: 'year'
  };

  export type CalendarScalarFieldEnum = (typeof CalendarScalarFieldEnum)[keyof typeof CalendarScalarFieldEnum]


  export const Class_representativesScalarFieldEnum: {
    id: 'id',
    student_id: 'student_id',
    class: 'class',
    section: 'section'
  };

  export type Class_representativesScalarFieldEnum = (typeof Class_representativesScalarFieldEnum)[keyof typeof Class_representativesScalarFieldEnum]


  export const Class_routineScalarFieldEnum: {
    id: 'id',
    class: 'class',
    section: 'section',
    day: 'day',
    period: 'period',
    subject: 'subject',
    teacher_id: 'teacher_id'
  };

  export type Class_routineScalarFieldEnum = (typeof Class_routineScalarFieldEnum)[keyof typeof Class_routineScalarFieldEnum]


  export const Class_teachersScalarFieldEnum: {
    id: 'id',
    class: 'class',
    section: 'section',
    teacher_id: 'teacher_id',
    class_representative_student_id: 'class_representative_student_id',
    second_class_representative_student_id: 'second_class_representative_student_id'
  };

  export type Class_teachersScalarFieldEnum = (typeof Class_teachersScalarFieldEnum)[keyof typeof Class_teachersScalarFieldEnum]


  export const ExamsScalarFieldEnum: {
    id: 'id',
    class: 'class',
    section: 'section',
    subject: 'subject',
    exam_date: 'exam_date',
    exam_duration: 'exam_duration',
    exam_type: 'exam_type',
    created_by: 'created_by'
  };

  export type ExamsScalarFieldEnum = (typeof ExamsScalarFieldEnum)[keyof typeof ExamsScalarFieldEnum]


  export const FinancecheckbookScalarFieldEnum: {
    id: 'id',
    month: 'month',
    income: 'income',
    expenses: 'expenses',
    total_due_amount: 'total_due_amount'
  };

  export type FinancecheckbookScalarFieldEnum = (typeof FinancecheckbookScalarFieldEnum)[keyof typeof FinancecheckbookScalarFieldEnum]


  export const FinancesScalarFieldEnum: {
    id: 'id',
    student_id: 'student_id',
    total_fee: 'total_fee',
    paid_amount: 'paid_amount',
    due_amount: 'due_amount',
    month: 'month',
    payment_status: 'payment_status',
    penalty: 'penalty',
    expenses: 'expenses'
  };

  export type FinancesScalarFieldEnum = (typeof FinancesScalarFieldEnum)[keyof typeof FinancesScalarFieldEnum]


  export const NotesScalarFieldEnum: {
    id: 'id',
    title: 'title',
    content: 'content',
    subject: 'subject',
    class: 'class',
    section: 'section',
    created_by: 'created_by',
    files: 'files',
    created_at: 'created_at'
  };

  export type NotesScalarFieldEnum = (typeof NotesScalarFieldEnum)[keyof typeof NotesScalarFieldEnum]


  export const NoticesScalarFieldEnum: {
    id: 'id',
    title: 'title',
    content: 'content',
    created_at: 'created_at',
    created_by: 'created_by',
    target_role: 'target_role'
  };

  export type NoticesScalarFieldEnum = (typeof NoticesScalarFieldEnum)[keyof typeof NoticesScalarFieldEnum]


  export const PerformanceScalarFieldEnum: {
    id: 'id',
    class: 'class',
    section: 'section',
    class_teacher: 'class_teacher',
    class_performance: 'class_performance',
    exam_id: 'exam_id'
  };

  export type PerformanceScalarFieldEnum = (typeof PerformanceScalarFieldEnum)[keyof typeof PerformanceScalarFieldEnum]


  export const Student_performanceScalarFieldEnum: {
    id: 'id',
    student_id: 'student_id',
    exam_id: 'exam_id',
    marks_obtained: 'marks_obtained',
    total_marks: 'total_marks'
  };

  export type Student_performanceScalarFieldEnum = (typeof Student_performanceScalarFieldEnum)[keyof typeof Student_performanceScalarFieldEnum]


  export const Student_routineScalarFieldEnum: {
    id: 'id',
    class: 'class',
    section: 'section',
    day: 'day',
    teacher_id: 'teacher_id',
    teacher_name: 'teacher_name',
    teacher_subject: 'teacher_subject',
    time_slot: 'time_slot'
  };

  export type Student_routineScalarFieldEnum = (typeof Student_routineScalarFieldEnum)[keyof typeof Student_routineScalarFieldEnum]


  export const StudentsScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    admission_number: 'admission_number',
    class: 'class',
    section: 'section',
    parent_name: 'parent_name',
    parent_phone: 'parent_phone',
    parent_email: 'parent_email',
    parent_work: 'parent_work',
    parent_photo1: 'parent_photo1',
    parent_photo2: 'parent_photo2',
    guardian_photo: 'guardian_photo',
    guardian_phone: 'guardian_phone',
    roll_number: 'roll_number'
  };

  export type StudentsScalarFieldEnum = (typeof StudentsScalarFieldEnum)[keyof typeof StudentsScalarFieldEnum]


  export const Teacher_routineScalarFieldEnum: {
    id: 'id',
    teacher_id: 'teacher_id',
    day: 'day',
    time_slot: 'time_slot',
    class: 'class',
    section: 'section'
  };

  export type Teacher_routineScalarFieldEnum = (typeof Teacher_routineScalarFieldEnum)[keyof typeof Teacher_routineScalarFieldEnum]


  export const TeachersScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    specialised_subject: 'specialised_subject',
    assigned_class: 'assigned_class',
    assigned_section: 'assigned_section'
  };

  export type TeachersScalarFieldEnum = (typeof TeachersScalarFieldEnum)[keyof typeof TeachersScalarFieldEnum]


  export const Upcoming_eventsScalarFieldEnum: {
    id: 'id',
    calendar_id: 'calendar_id',
    event_date: 'event_date',
    event_name: 'event_name',
    holiday: 'holiday'
  };

  export type Upcoming_eventsScalarFieldEnum = (typeof Upcoming_eventsScalarFieldEnum)[keyof typeof Upcoming_eventsScalarFieldEnum]


  export const UsersScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    password: 'password',
    role: 'role',
    phone: 'phone',
    address: 'address',
    photo: 'photo'
  };

  export type UsersScalarFieldEnum = (typeof UsersScalarFieldEnum)[keyof typeof UsersScalarFieldEnum]


  export const Workroom_messagesScalarFieldEnum: {
    id: 'id',
    sender_id: 'sender_id',
    receiver_id: 'receiver_id',
    message: 'message',
    sent_at: 'sent_at'
  };

  export type Workroom_messagesScalarFieldEnum = (typeof Workroom_messagesScalarFieldEnum)[keyof typeof Workroom_messagesScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type assignmentsWhereInput = {
    AND?: assignmentsWhereInput | assignmentsWhereInput[]
    OR?: assignmentsWhereInput[]
    NOT?: assignmentsWhereInput | assignmentsWhereInput[]
    id?: IntFilter<"assignments"> | number
    title?: StringFilter<"assignments"> | string
    description?: StringFilter<"assignments"> | string
    subject?: StringFilter<"assignments"> | string
    class?: StringFilter<"assignments"> | string
    section?: StringFilter<"assignments"> | string
    assigned_by?: IntNullableFilter<"assignments"> | number | null
    due_date?: DateTimeFilter<"assignments"> | Date | string
    file?: StringNullableFilter<"assignments"> | string | null
    teachers?: XOR<TeachersNullableScalarRelationFilter, teachersWhereInput> | null
  }

  export type assignmentsOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    subject?: SortOrder
    class?: SortOrder
    section?: SortOrder
    assigned_by?: SortOrderInput | SortOrder
    due_date?: SortOrder
    file?: SortOrderInput | SortOrder
    teachers?: teachersOrderByWithRelationInput
  }

  export type assignmentsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: assignmentsWhereInput | assignmentsWhereInput[]
    OR?: assignmentsWhereInput[]
    NOT?: assignmentsWhereInput | assignmentsWhereInput[]
    title?: StringFilter<"assignments"> | string
    description?: StringFilter<"assignments"> | string
    subject?: StringFilter<"assignments"> | string
    class?: StringFilter<"assignments"> | string
    section?: StringFilter<"assignments"> | string
    assigned_by?: IntNullableFilter<"assignments"> | number | null
    due_date?: DateTimeFilter<"assignments"> | Date | string
    file?: StringNullableFilter<"assignments"> | string | null
    teachers?: XOR<TeachersNullableScalarRelationFilter, teachersWhereInput> | null
  }, "id">

  export type assignmentsOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    subject?: SortOrder
    class?: SortOrder
    section?: SortOrder
    assigned_by?: SortOrderInput | SortOrder
    due_date?: SortOrder
    file?: SortOrderInput | SortOrder
    _count?: assignmentsCountOrderByAggregateInput
    _avg?: assignmentsAvgOrderByAggregateInput
    _max?: assignmentsMaxOrderByAggregateInput
    _min?: assignmentsMinOrderByAggregateInput
    _sum?: assignmentsSumOrderByAggregateInput
  }

  export type assignmentsScalarWhereWithAggregatesInput = {
    AND?: assignmentsScalarWhereWithAggregatesInput | assignmentsScalarWhereWithAggregatesInput[]
    OR?: assignmentsScalarWhereWithAggregatesInput[]
    NOT?: assignmentsScalarWhereWithAggregatesInput | assignmentsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"assignments"> | number
    title?: StringWithAggregatesFilter<"assignments"> | string
    description?: StringWithAggregatesFilter<"assignments"> | string
    subject?: StringWithAggregatesFilter<"assignments"> | string
    class?: StringWithAggregatesFilter<"assignments"> | string
    section?: StringWithAggregatesFilter<"assignments"> | string
    assigned_by?: IntNullableWithAggregatesFilter<"assignments"> | number | null
    due_date?: DateTimeWithAggregatesFilter<"assignments"> | Date | string
    file?: StringNullableWithAggregatesFilter<"assignments"> | string | null
  }

  export type attendanceWhereInput = {
    AND?: attendanceWhereInput | attendanceWhereInput[]
    OR?: attendanceWhereInput[]
    NOT?: attendanceWhereInput | attendanceWhereInput[]
    id?: IntFilter<"attendance"> | number
    student_id?: IntFilter<"attendance"> | number
    teacher_id?: IntFilter<"attendance"> | number
    class?: IntFilter<"attendance"> | number
    section?: StringFilter<"attendance"> | string
    date?: DateTimeFilter<"attendance"> | Date | string
    status?: StringFilter<"attendance"> | string
    created_at?: DateTimeNullableFilter<"attendance"> | Date | string | null
    students?: XOR<StudentsScalarRelationFilter, studentsWhereInput>
    teachers?: XOR<TeachersScalarRelationFilter, teachersWhereInput>
  }

  export type attendanceOrderByWithRelationInput = {
    id?: SortOrder
    student_id?: SortOrder
    teacher_id?: SortOrder
    class?: SortOrder
    section?: SortOrder
    date?: SortOrder
    status?: SortOrder
    created_at?: SortOrderInput | SortOrder
    students?: studentsOrderByWithRelationInput
    teachers?: teachersOrderByWithRelationInput
  }

  export type attendanceWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    student_id_date?: attendanceStudent_idDateCompoundUniqueInput
    AND?: attendanceWhereInput | attendanceWhereInput[]
    OR?: attendanceWhereInput[]
    NOT?: attendanceWhereInput | attendanceWhereInput[]
    student_id?: IntFilter<"attendance"> | number
    teacher_id?: IntFilter<"attendance"> | number
    class?: IntFilter<"attendance"> | number
    section?: StringFilter<"attendance"> | string
    date?: DateTimeFilter<"attendance"> | Date | string
    status?: StringFilter<"attendance"> | string
    created_at?: DateTimeNullableFilter<"attendance"> | Date | string | null
    students?: XOR<StudentsScalarRelationFilter, studentsWhereInput>
    teachers?: XOR<TeachersScalarRelationFilter, teachersWhereInput>
  }, "id" | "student_id_date">

  export type attendanceOrderByWithAggregationInput = {
    id?: SortOrder
    student_id?: SortOrder
    teacher_id?: SortOrder
    class?: SortOrder
    section?: SortOrder
    date?: SortOrder
    status?: SortOrder
    created_at?: SortOrderInput | SortOrder
    _count?: attendanceCountOrderByAggregateInput
    _avg?: attendanceAvgOrderByAggregateInput
    _max?: attendanceMaxOrderByAggregateInput
    _min?: attendanceMinOrderByAggregateInput
    _sum?: attendanceSumOrderByAggregateInput
  }

  export type attendanceScalarWhereWithAggregatesInput = {
    AND?: attendanceScalarWhereWithAggregatesInput | attendanceScalarWhereWithAggregatesInput[]
    OR?: attendanceScalarWhereWithAggregatesInput[]
    NOT?: attendanceScalarWhereWithAggregatesInput | attendanceScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"attendance"> | number
    student_id?: IntWithAggregatesFilter<"attendance"> | number
    teacher_id?: IntWithAggregatesFilter<"attendance"> | number
    class?: IntWithAggregatesFilter<"attendance"> | number
    section?: StringWithAggregatesFilter<"attendance"> | string
    date?: DateTimeWithAggregatesFilter<"attendance"> | Date | string
    status?: StringWithAggregatesFilter<"attendance"> | string
    created_at?: DateTimeNullableWithAggregatesFilter<"attendance"> | Date | string | null
  }

  export type calendarWhereInput = {
    AND?: calendarWhereInput | calendarWhereInput[]
    OR?: calendarWhereInput[]
    NOT?: calendarWhereInput | calendarWhereInput[]
    id?: IntFilter<"calendar"> | number
    month?: StringFilter<"calendar"> | string
    calendar?: StringFilter<"calendar"> | string
    year?: IntNullableFilter<"calendar"> | number | null
    upcoming_events?: Upcoming_eventsListRelationFilter
  }

  export type calendarOrderByWithRelationInput = {
    id?: SortOrder
    month?: SortOrder
    calendar?: SortOrder
    year?: SortOrderInput | SortOrder
    upcoming_events?: upcoming_eventsOrderByRelationAggregateInput
  }

  export type calendarWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: calendarWhereInput | calendarWhereInput[]
    OR?: calendarWhereInput[]
    NOT?: calendarWhereInput | calendarWhereInput[]
    month?: StringFilter<"calendar"> | string
    calendar?: StringFilter<"calendar"> | string
    year?: IntNullableFilter<"calendar"> | number | null
    upcoming_events?: Upcoming_eventsListRelationFilter
  }, "id">

  export type calendarOrderByWithAggregationInput = {
    id?: SortOrder
    month?: SortOrder
    calendar?: SortOrder
    year?: SortOrderInput | SortOrder
    _count?: calendarCountOrderByAggregateInput
    _avg?: calendarAvgOrderByAggregateInput
    _max?: calendarMaxOrderByAggregateInput
    _min?: calendarMinOrderByAggregateInput
    _sum?: calendarSumOrderByAggregateInput
  }

  export type calendarScalarWhereWithAggregatesInput = {
    AND?: calendarScalarWhereWithAggregatesInput | calendarScalarWhereWithAggregatesInput[]
    OR?: calendarScalarWhereWithAggregatesInput[]
    NOT?: calendarScalarWhereWithAggregatesInput | calendarScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"calendar"> | number
    month?: StringWithAggregatesFilter<"calendar"> | string
    calendar?: StringWithAggregatesFilter<"calendar"> | string
    year?: IntNullableWithAggregatesFilter<"calendar"> | number | null
  }

  export type class_representativesWhereInput = {
    AND?: class_representativesWhereInput | class_representativesWhereInput[]
    OR?: class_representativesWhereInput[]
    NOT?: class_representativesWhereInput | class_representativesWhereInput[]
    id?: IntFilter<"class_representatives"> | number
    student_id?: IntNullableFilter<"class_representatives"> | number | null
    class?: StringFilter<"class_representatives"> | string
    section?: StringFilter<"class_representatives"> | string
    students?: XOR<StudentsNullableScalarRelationFilter, studentsWhereInput> | null
  }

  export type class_representativesOrderByWithRelationInput = {
    id?: SortOrder
    student_id?: SortOrderInput | SortOrder
    class?: SortOrder
    section?: SortOrder
    students?: studentsOrderByWithRelationInput
  }

  export type class_representativesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: class_representativesWhereInput | class_representativesWhereInput[]
    OR?: class_representativesWhereInput[]
    NOT?: class_representativesWhereInput | class_representativesWhereInput[]
    student_id?: IntNullableFilter<"class_representatives"> | number | null
    class?: StringFilter<"class_representatives"> | string
    section?: StringFilter<"class_representatives"> | string
    students?: XOR<StudentsNullableScalarRelationFilter, studentsWhereInput> | null
  }, "id">

  export type class_representativesOrderByWithAggregationInput = {
    id?: SortOrder
    student_id?: SortOrderInput | SortOrder
    class?: SortOrder
    section?: SortOrder
    _count?: class_representativesCountOrderByAggregateInput
    _avg?: class_representativesAvgOrderByAggregateInput
    _max?: class_representativesMaxOrderByAggregateInput
    _min?: class_representativesMinOrderByAggregateInput
    _sum?: class_representativesSumOrderByAggregateInput
  }

  export type class_representativesScalarWhereWithAggregatesInput = {
    AND?: class_representativesScalarWhereWithAggregatesInput | class_representativesScalarWhereWithAggregatesInput[]
    OR?: class_representativesScalarWhereWithAggregatesInput[]
    NOT?: class_representativesScalarWhereWithAggregatesInput | class_representativesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"class_representatives"> | number
    student_id?: IntNullableWithAggregatesFilter<"class_representatives"> | number | null
    class?: StringWithAggregatesFilter<"class_representatives"> | string
    section?: StringWithAggregatesFilter<"class_representatives"> | string
  }

  export type class_routineWhereInput = {
    AND?: class_routineWhereInput | class_routineWhereInput[]
    OR?: class_routineWhereInput[]
    NOT?: class_routineWhereInput | class_routineWhereInput[]
    id?: IntFilter<"class_routine"> | number
    class?: StringFilter<"class_routine"> | string
    section?: StringFilter<"class_routine"> | string
    day?: StringFilter<"class_routine"> | string
    period?: IntFilter<"class_routine"> | number
    subject?: StringFilter<"class_routine"> | string
    teacher_id?: IntNullableFilter<"class_routine"> | number | null
    teachers?: XOR<TeachersNullableScalarRelationFilter, teachersWhereInput> | null
  }

  export type class_routineOrderByWithRelationInput = {
    id?: SortOrder
    class?: SortOrder
    section?: SortOrder
    day?: SortOrder
    period?: SortOrder
    subject?: SortOrder
    teacher_id?: SortOrderInput | SortOrder
    teachers?: teachersOrderByWithRelationInput
  }

  export type class_routineWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: class_routineWhereInput | class_routineWhereInput[]
    OR?: class_routineWhereInput[]
    NOT?: class_routineWhereInput | class_routineWhereInput[]
    class?: StringFilter<"class_routine"> | string
    section?: StringFilter<"class_routine"> | string
    day?: StringFilter<"class_routine"> | string
    period?: IntFilter<"class_routine"> | number
    subject?: StringFilter<"class_routine"> | string
    teacher_id?: IntNullableFilter<"class_routine"> | number | null
    teachers?: XOR<TeachersNullableScalarRelationFilter, teachersWhereInput> | null
  }, "id">

  export type class_routineOrderByWithAggregationInput = {
    id?: SortOrder
    class?: SortOrder
    section?: SortOrder
    day?: SortOrder
    period?: SortOrder
    subject?: SortOrder
    teacher_id?: SortOrderInput | SortOrder
    _count?: class_routineCountOrderByAggregateInput
    _avg?: class_routineAvgOrderByAggregateInput
    _max?: class_routineMaxOrderByAggregateInput
    _min?: class_routineMinOrderByAggregateInput
    _sum?: class_routineSumOrderByAggregateInput
  }

  export type class_routineScalarWhereWithAggregatesInput = {
    AND?: class_routineScalarWhereWithAggregatesInput | class_routineScalarWhereWithAggregatesInput[]
    OR?: class_routineScalarWhereWithAggregatesInput[]
    NOT?: class_routineScalarWhereWithAggregatesInput | class_routineScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"class_routine"> | number
    class?: StringWithAggregatesFilter<"class_routine"> | string
    section?: StringWithAggregatesFilter<"class_routine"> | string
    day?: StringWithAggregatesFilter<"class_routine"> | string
    period?: IntWithAggregatesFilter<"class_routine"> | number
    subject?: StringWithAggregatesFilter<"class_routine"> | string
    teacher_id?: IntNullableWithAggregatesFilter<"class_routine"> | number | null
  }

  export type class_teachersWhereInput = {
    AND?: class_teachersWhereInput | class_teachersWhereInput[]
    OR?: class_teachersWhereInput[]
    NOT?: class_teachersWhereInput | class_teachersWhereInput[]
    id?: IntFilter<"class_teachers"> | number
    class?: StringFilter<"class_teachers"> | string
    section?: StringFilter<"class_teachers"> | string
    teacher_id?: IntFilter<"class_teachers"> | number
    class_representative_student_id?: IntNullableFilter<"class_teachers"> | number | null
    second_class_representative_student_id?: IntNullableFilter<"class_teachers"> | number | null
    students?: XOR<StudentsNullableScalarRelationFilter, studentsWhereInput> | null
    teachers?: XOR<TeachersScalarRelationFilter, teachersWhereInput>
  }

  export type class_teachersOrderByWithRelationInput = {
    id?: SortOrder
    class?: SortOrder
    section?: SortOrder
    teacher_id?: SortOrder
    class_representative_student_id?: SortOrderInput | SortOrder
    second_class_representative_student_id?: SortOrderInput | SortOrder
    students?: studentsOrderByWithRelationInput
    teachers?: teachersOrderByWithRelationInput
  }

  export type class_teachersWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: class_teachersWhereInput | class_teachersWhereInput[]
    OR?: class_teachersWhereInput[]
    NOT?: class_teachersWhereInput | class_teachersWhereInput[]
    class?: StringFilter<"class_teachers"> | string
    section?: StringFilter<"class_teachers"> | string
    teacher_id?: IntFilter<"class_teachers"> | number
    class_representative_student_id?: IntNullableFilter<"class_teachers"> | number | null
    second_class_representative_student_id?: IntNullableFilter<"class_teachers"> | number | null
    students?: XOR<StudentsNullableScalarRelationFilter, studentsWhereInput> | null
    teachers?: XOR<TeachersScalarRelationFilter, teachersWhereInput>
  }, "id">

  export type class_teachersOrderByWithAggregationInput = {
    id?: SortOrder
    class?: SortOrder
    section?: SortOrder
    teacher_id?: SortOrder
    class_representative_student_id?: SortOrderInput | SortOrder
    second_class_representative_student_id?: SortOrderInput | SortOrder
    _count?: class_teachersCountOrderByAggregateInput
    _avg?: class_teachersAvgOrderByAggregateInput
    _max?: class_teachersMaxOrderByAggregateInput
    _min?: class_teachersMinOrderByAggregateInput
    _sum?: class_teachersSumOrderByAggregateInput
  }

  export type class_teachersScalarWhereWithAggregatesInput = {
    AND?: class_teachersScalarWhereWithAggregatesInput | class_teachersScalarWhereWithAggregatesInput[]
    OR?: class_teachersScalarWhereWithAggregatesInput[]
    NOT?: class_teachersScalarWhereWithAggregatesInput | class_teachersScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"class_teachers"> | number
    class?: StringWithAggregatesFilter<"class_teachers"> | string
    section?: StringWithAggregatesFilter<"class_teachers"> | string
    teacher_id?: IntWithAggregatesFilter<"class_teachers"> | number
    class_representative_student_id?: IntNullableWithAggregatesFilter<"class_teachers"> | number | null
    second_class_representative_student_id?: IntNullableWithAggregatesFilter<"class_teachers"> | number | null
  }

  export type examsWhereInput = {
    AND?: examsWhereInput | examsWhereInput[]
    OR?: examsWhereInput[]
    NOT?: examsWhereInput | examsWhereInput[]
    id?: IntFilter<"exams"> | number
    class?: StringFilter<"exams"> | string
    section?: StringFilter<"exams"> | string
    subject?: StringFilter<"exams"> | string
    exam_date?: DateTimeFilter<"exams"> | Date | string
    exam_duration?: StringNullableFilter<"exams"> | string | null
    exam_type?: StringNullableFilter<"exams"> | string | null
    created_by?: IntNullableFilter<"exams"> | number | null
    teachers?: XOR<TeachersNullableScalarRelationFilter, teachersWhereInput> | null
    performance?: PerformanceListRelationFilter
    student_performance?: Student_performanceListRelationFilter
  }

  export type examsOrderByWithRelationInput = {
    id?: SortOrder
    class?: SortOrder
    section?: SortOrder
    subject?: SortOrder
    exam_date?: SortOrder
    exam_duration?: SortOrderInput | SortOrder
    exam_type?: SortOrderInput | SortOrder
    created_by?: SortOrderInput | SortOrder
    teachers?: teachersOrderByWithRelationInput
    performance?: performanceOrderByRelationAggregateInput
    student_performance?: student_performanceOrderByRelationAggregateInput
  }

  export type examsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: examsWhereInput | examsWhereInput[]
    OR?: examsWhereInput[]
    NOT?: examsWhereInput | examsWhereInput[]
    class?: StringFilter<"exams"> | string
    section?: StringFilter<"exams"> | string
    subject?: StringFilter<"exams"> | string
    exam_date?: DateTimeFilter<"exams"> | Date | string
    exam_duration?: StringNullableFilter<"exams"> | string | null
    exam_type?: StringNullableFilter<"exams"> | string | null
    created_by?: IntNullableFilter<"exams"> | number | null
    teachers?: XOR<TeachersNullableScalarRelationFilter, teachersWhereInput> | null
    performance?: PerformanceListRelationFilter
    student_performance?: Student_performanceListRelationFilter
  }, "id">

  export type examsOrderByWithAggregationInput = {
    id?: SortOrder
    class?: SortOrder
    section?: SortOrder
    subject?: SortOrder
    exam_date?: SortOrder
    exam_duration?: SortOrderInput | SortOrder
    exam_type?: SortOrderInput | SortOrder
    created_by?: SortOrderInput | SortOrder
    _count?: examsCountOrderByAggregateInput
    _avg?: examsAvgOrderByAggregateInput
    _max?: examsMaxOrderByAggregateInput
    _min?: examsMinOrderByAggregateInput
    _sum?: examsSumOrderByAggregateInput
  }

  export type examsScalarWhereWithAggregatesInput = {
    AND?: examsScalarWhereWithAggregatesInput | examsScalarWhereWithAggregatesInput[]
    OR?: examsScalarWhereWithAggregatesInput[]
    NOT?: examsScalarWhereWithAggregatesInput | examsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"exams"> | number
    class?: StringWithAggregatesFilter<"exams"> | string
    section?: StringWithAggregatesFilter<"exams"> | string
    subject?: StringWithAggregatesFilter<"exams"> | string
    exam_date?: DateTimeWithAggregatesFilter<"exams"> | Date | string
    exam_duration?: StringNullableWithAggregatesFilter<"exams"> | string | null
    exam_type?: StringNullableWithAggregatesFilter<"exams"> | string | null
    created_by?: IntNullableWithAggregatesFilter<"exams"> | number | null
  }

  export type financecheckbookWhereInput = {
    AND?: financecheckbookWhereInput | financecheckbookWhereInput[]
    OR?: financecheckbookWhereInput[]
    NOT?: financecheckbookWhereInput | financecheckbookWhereInput[]
    id?: IntFilter<"financecheckbook"> | number
    month?: StringFilter<"financecheckbook"> | string
    income?: DecimalFilter<"financecheckbook"> | Decimal | DecimalJsLike | number | string
    expenses?: DecimalFilter<"financecheckbook"> | Decimal | DecimalJsLike | number | string
    total_due_amount?: DecimalNullableFilter<"financecheckbook"> | Decimal | DecimalJsLike | number | string | null
  }

  export type financecheckbookOrderByWithRelationInput = {
    id?: SortOrder
    month?: SortOrder
    income?: SortOrder
    expenses?: SortOrder
    total_due_amount?: SortOrderInput | SortOrder
  }

  export type financecheckbookWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: financecheckbookWhereInput | financecheckbookWhereInput[]
    OR?: financecheckbookWhereInput[]
    NOT?: financecheckbookWhereInput | financecheckbookWhereInput[]
    month?: StringFilter<"financecheckbook"> | string
    income?: DecimalFilter<"financecheckbook"> | Decimal | DecimalJsLike | number | string
    expenses?: DecimalFilter<"financecheckbook"> | Decimal | DecimalJsLike | number | string
    total_due_amount?: DecimalNullableFilter<"financecheckbook"> | Decimal | DecimalJsLike | number | string | null
  }, "id">

  export type financecheckbookOrderByWithAggregationInput = {
    id?: SortOrder
    month?: SortOrder
    income?: SortOrder
    expenses?: SortOrder
    total_due_amount?: SortOrderInput | SortOrder
    _count?: financecheckbookCountOrderByAggregateInput
    _avg?: financecheckbookAvgOrderByAggregateInput
    _max?: financecheckbookMaxOrderByAggregateInput
    _min?: financecheckbookMinOrderByAggregateInput
    _sum?: financecheckbookSumOrderByAggregateInput
  }

  export type financecheckbookScalarWhereWithAggregatesInput = {
    AND?: financecheckbookScalarWhereWithAggregatesInput | financecheckbookScalarWhereWithAggregatesInput[]
    OR?: financecheckbookScalarWhereWithAggregatesInput[]
    NOT?: financecheckbookScalarWhereWithAggregatesInput | financecheckbookScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"financecheckbook"> | number
    month?: StringWithAggregatesFilter<"financecheckbook"> | string
    income?: DecimalWithAggregatesFilter<"financecheckbook"> | Decimal | DecimalJsLike | number | string
    expenses?: DecimalWithAggregatesFilter<"financecheckbook"> | Decimal | DecimalJsLike | number | string
    total_due_amount?: DecimalNullableWithAggregatesFilter<"financecheckbook"> | Decimal | DecimalJsLike | number | string | null
  }

  export type financesWhereInput = {
    AND?: financesWhereInput | financesWhereInput[]
    OR?: financesWhereInput[]
    NOT?: financesWhereInput | financesWhereInput[]
    id?: IntFilter<"finances"> | number
    student_id?: IntNullableFilter<"finances"> | number | null
    total_fee?: DecimalFilter<"finances"> | Decimal | DecimalJsLike | number | string
    paid_amount?: DecimalNullableFilter<"finances"> | Decimal | DecimalJsLike | number | string | null
    due_amount?: DecimalNullableFilter<"finances"> | Decimal | DecimalJsLike | number | string | null
    month?: StringFilter<"finances"> | string
    payment_status?: StringNullableFilter<"finances"> | string | null
    penalty?: DecimalNullableFilter<"finances"> | Decimal | DecimalJsLike | number | string | null
    expenses?: DecimalNullableFilter<"finances"> | Decimal | DecimalJsLike | number | string | null
    students?: XOR<StudentsNullableScalarRelationFilter, studentsWhereInput> | null
  }

  export type financesOrderByWithRelationInput = {
    id?: SortOrder
    student_id?: SortOrderInput | SortOrder
    total_fee?: SortOrder
    paid_amount?: SortOrderInput | SortOrder
    due_amount?: SortOrderInput | SortOrder
    month?: SortOrder
    payment_status?: SortOrderInput | SortOrder
    penalty?: SortOrderInput | SortOrder
    expenses?: SortOrderInput | SortOrder
    students?: studentsOrderByWithRelationInput
  }

  export type financesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: financesWhereInput | financesWhereInput[]
    OR?: financesWhereInput[]
    NOT?: financesWhereInput | financesWhereInput[]
    student_id?: IntNullableFilter<"finances"> | number | null
    total_fee?: DecimalFilter<"finances"> | Decimal | DecimalJsLike | number | string
    paid_amount?: DecimalNullableFilter<"finances"> | Decimal | DecimalJsLike | number | string | null
    due_amount?: DecimalNullableFilter<"finances"> | Decimal | DecimalJsLike | number | string | null
    month?: StringFilter<"finances"> | string
    payment_status?: StringNullableFilter<"finances"> | string | null
    penalty?: DecimalNullableFilter<"finances"> | Decimal | DecimalJsLike | number | string | null
    expenses?: DecimalNullableFilter<"finances"> | Decimal | DecimalJsLike | number | string | null
    students?: XOR<StudentsNullableScalarRelationFilter, studentsWhereInput> | null
  }, "id">

  export type financesOrderByWithAggregationInput = {
    id?: SortOrder
    student_id?: SortOrderInput | SortOrder
    total_fee?: SortOrder
    paid_amount?: SortOrderInput | SortOrder
    due_amount?: SortOrderInput | SortOrder
    month?: SortOrder
    payment_status?: SortOrderInput | SortOrder
    penalty?: SortOrderInput | SortOrder
    expenses?: SortOrderInput | SortOrder
    _count?: financesCountOrderByAggregateInput
    _avg?: financesAvgOrderByAggregateInput
    _max?: financesMaxOrderByAggregateInput
    _min?: financesMinOrderByAggregateInput
    _sum?: financesSumOrderByAggregateInput
  }

  export type financesScalarWhereWithAggregatesInput = {
    AND?: financesScalarWhereWithAggregatesInput | financesScalarWhereWithAggregatesInput[]
    OR?: financesScalarWhereWithAggregatesInput[]
    NOT?: financesScalarWhereWithAggregatesInput | financesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"finances"> | number
    student_id?: IntNullableWithAggregatesFilter<"finances"> | number | null
    total_fee?: DecimalWithAggregatesFilter<"finances"> | Decimal | DecimalJsLike | number | string
    paid_amount?: DecimalNullableWithAggregatesFilter<"finances"> | Decimal | DecimalJsLike | number | string | null
    due_amount?: DecimalNullableWithAggregatesFilter<"finances"> | Decimal | DecimalJsLike | number | string | null
    month?: StringWithAggregatesFilter<"finances"> | string
    payment_status?: StringNullableWithAggregatesFilter<"finances"> | string | null
    penalty?: DecimalNullableWithAggregatesFilter<"finances"> | Decimal | DecimalJsLike | number | string | null
    expenses?: DecimalNullableWithAggregatesFilter<"finances"> | Decimal | DecimalJsLike | number | string | null
  }

  export type notesWhereInput = {
    AND?: notesWhereInput | notesWhereInput[]
    OR?: notesWhereInput[]
    NOT?: notesWhereInput | notesWhereInput[]
    id?: IntFilter<"notes"> | number
    title?: StringFilter<"notes"> | string
    content?: StringFilter<"notes"> | string
    subject?: StringFilter<"notes"> | string
    class?: StringFilter<"notes"> | string
    section?: StringFilter<"notes"> | string
    created_by?: IntNullableFilter<"notes"> | number | null
    files?: StringNullableFilter<"notes"> | string | null
    created_at?: DateTimeNullableFilter<"notes"> | Date | string | null
    users?: XOR<UsersNullableScalarRelationFilter, usersWhereInput> | null
  }

  export type notesOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    subject?: SortOrder
    class?: SortOrder
    section?: SortOrder
    created_by?: SortOrderInput | SortOrder
    files?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    users?: usersOrderByWithRelationInput
  }

  export type notesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: notesWhereInput | notesWhereInput[]
    OR?: notesWhereInput[]
    NOT?: notesWhereInput | notesWhereInput[]
    title?: StringFilter<"notes"> | string
    content?: StringFilter<"notes"> | string
    subject?: StringFilter<"notes"> | string
    class?: StringFilter<"notes"> | string
    section?: StringFilter<"notes"> | string
    created_by?: IntNullableFilter<"notes"> | number | null
    files?: StringNullableFilter<"notes"> | string | null
    created_at?: DateTimeNullableFilter<"notes"> | Date | string | null
    users?: XOR<UsersNullableScalarRelationFilter, usersWhereInput> | null
  }, "id">

  export type notesOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    subject?: SortOrder
    class?: SortOrder
    section?: SortOrder
    created_by?: SortOrderInput | SortOrder
    files?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    _count?: notesCountOrderByAggregateInput
    _avg?: notesAvgOrderByAggregateInput
    _max?: notesMaxOrderByAggregateInput
    _min?: notesMinOrderByAggregateInput
    _sum?: notesSumOrderByAggregateInput
  }

  export type notesScalarWhereWithAggregatesInput = {
    AND?: notesScalarWhereWithAggregatesInput | notesScalarWhereWithAggregatesInput[]
    OR?: notesScalarWhereWithAggregatesInput[]
    NOT?: notesScalarWhereWithAggregatesInput | notesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"notes"> | number
    title?: StringWithAggregatesFilter<"notes"> | string
    content?: StringWithAggregatesFilter<"notes"> | string
    subject?: StringWithAggregatesFilter<"notes"> | string
    class?: StringWithAggregatesFilter<"notes"> | string
    section?: StringWithAggregatesFilter<"notes"> | string
    created_by?: IntNullableWithAggregatesFilter<"notes"> | number | null
    files?: StringNullableWithAggregatesFilter<"notes"> | string | null
    created_at?: DateTimeNullableWithAggregatesFilter<"notes"> | Date | string | null
  }

  export type noticesWhereInput = {
    AND?: noticesWhereInput | noticesWhereInput[]
    OR?: noticesWhereInput[]
    NOT?: noticesWhereInput | noticesWhereInput[]
    id?: IntFilter<"notices"> | number
    title?: StringFilter<"notices"> | string
    content?: StringFilter<"notices"> | string
    created_at?: DateTimeNullableFilter<"notices"> | Date | string | null
    created_by?: IntNullableFilter<"notices"> | number | null
    target_role?: StringFilter<"notices"> | string
    users?: XOR<UsersNullableScalarRelationFilter, usersWhereInput> | null
  }

  export type noticesOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    created_at?: SortOrderInput | SortOrder
    created_by?: SortOrderInput | SortOrder
    target_role?: SortOrder
    users?: usersOrderByWithRelationInput
  }

  export type noticesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: noticesWhereInput | noticesWhereInput[]
    OR?: noticesWhereInput[]
    NOT?: noticesWhereInput | noticesWhereInput[]
    title?: StringFilter<"notices"> | string
    content?: StringFilter<"notices"> | string
    created_at?: DateTimeNullableFilter<"notices"> | Date | string | null
    created_by?: IntNullableFilter<"notices"> | number | null
    target_role?: StringFilter<"notices"> | string
    users?: XOR<UsersNullableScalarRelationFilter, usersWhereInput> | null
  }, "id">

  export type noticesOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    created_at?: SortOrderInput | SortOrder
    created_by?: SortOrderInput | SortOrder
    target_role?: SortOrder
    _count?: noticesCountOrderByAggregateInput
    _avg?: noticesAvgOrderByAggregateInput
    _max?: noticesMaxOrderByAggregateInput
    _min?: noticesMinOrderByAggregateInput
    _sum?: noticesSumOrderByAggregateInput
  }

  export type noticesScalarWhereWithAggregatesInput = {
    AND?: noticesScalarWhereWithAggregatesInput | noticesScalarWhereWithAggregatesInput[]
    OR?: noticesScalarWhereWithAggregatesInput[]
    NOT?: noticesScalarWhereWithAggregatesInput | noticesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"notices"> | number
    title?: StringWithAggregatesFilter<"notices"> | string
    content?: StringWithAggregatesFilter<"notices"> | string
    created_at?: DateTimeNullableWithAggregatesFilter<"notices"> | Date | string | null
    created_by?: IntNullableWithAggregatesFilter<"notices"> | number | null
    target_role?: StringWithAggregatesFilter<"notices"> | string
  }

  export type performanceWhereInput = {
    AND?: performanceWhereInput | performanceWhereInput[]
    OR?: performanceWhereInput[]
    NOT?: performanceWhereInput | performanceWhereInput[]
    id?: IntFilter<"performance"> | number
    class?: StringFilter<"performance"> | string
    section?: StringFilter<"performance"> | string
    class_teacher?: IntNullableFilter<"performance"> | number | null
    class_performance?: IntNullableFilter<"performance"> | number | null
    exam_id?: IntNullableFilter<"performance"> | number | null
    exams?: XOR<ExamsNullableScalarRelationFilter, examsWhereInput> | null
    student_performance?: XOR<Student_performanceNullableScalarRelationFilter, student_performanceWhereInput> | null
    teachers?: XOR<TeachersNullableScalarRelationFilter, teachersWhereInput> | null
  }

  export type performanceOrderByWithRelationInput = {
    id?: SortOrder
    class?: SortOrder
    section?: SortOrder
    class_teacher?: SortOrderInput | SortOrder
    class_performance?: SortOrderInput | SortOrder
    exam_id?: SortOrderInput | SortOrder
    exams?: examsOrderByWithRelationInput
    student_performance?: student_performanceOrderByWithRelationInput
    teachers?: teachersOrderByWithRelationInput
  }

  export type performanceWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: performanceWhereInput | performanceWhereInput[]
    OR?: performanceWhereInput[]
    NOT?: performanceWhereInput | performanceWhereInput[]
    class?: StringFilter<"performance"> | string
    section?: StringFilter<"performance"> | string
    class_teacher?: IntNullableFilter<"performance"> | number | null
    class_performance?: IntNullableFilter<"performance"> | number | null
    exam_id?: IntNullableFilter<"performance"> | number | null
    exams?: XOR<ExamsNullableScalarRelationFilter, examsWhereInput> | null
    student_performance?: XOR<Student_performanceNullableScalarRelationFilter, student_performanceWhereInput> | null
    teachers?: XOR<TeachersNullableScalarRelationFilter, teachersWhereInput> | null
  }, "id">

  export type performanceOrderByWithAggregationInput = {
    id?: SortOrder
    class?: SortOrder
    section?: SortOrder
    class_teacher?: SortOrderInput | SortOrder
    class_performance?: SortOrderInput | SortOrder
    exam_id?: SortOrderInput | SortOrder
    _count?: performanceCountOrderByAggregateInput
    _avg?: performanceAvgOrderByAggregateInput
    _max?: performanceMaxOrderByAggregateInput
    _min?: performanceMinOrderByAggregateInput
    _sum?: performanceSumOrderByAggregateInput
  }

  export type performanceScalarWhereWithAggregatesInput = {
    AND?: performanceScalarWhereWithAggregatesInput | performanceScalarWhereWithAggregatesInput[]
    OR?: performanceScalarWhereWithAggregatesInput[]
    NOT?: performanceScalarWhereWithAggregatesInput | performanceScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"performance"> | number
    class?: StringWithAggregatesFilter<"performance"> | string
    section?: StringWithAggregatesFilter<"performance"> | string
    class_teacher?: IntNullableWithAggregatesFilter<"performance"> | number | null
    class_performance?: IntNullableWithAggregatesFilter<"performance"> | number | null
    exam_id?: IntNullableWithAggregatesFilter<"performance"> | number | null
  }

  export type student_performanceWhereInput = {
    AND?: student_performanceWhereInput | student_performanceWhereInput[]
    OR?: student_performanceWhereInput[]
    NOT?: student_performanceWhereInput | student_performanceWhereInput[]
    id?: IntFilter<"student_performance"> | number
    student_id?: IntNullableFilter<"student_performance"> | number | null
    exam_id?: IntNullableFilter<"student_performance"> | number | null
    marks_obtained?: DecimalFilter<"student_performance"> | Decimal | DecimalJsLike | number | string
    total_marks?: DecimalFilter<"student_performance"> | Decimal | DecimalJsLike | number | string
    performance?: PerformanceListRelationFilter
    exams?: XOR<ExamsNullableScalarRelationFilter, examsWhereInput> | null
    students?: XOR<StudentsNullableScalarRelationFilter, studentsWhereInput> | null
  }

  export type student_performanceOrderByWithRelationInput = {
    id?: SortOrder
    student_id?: SortOrderInput | SortOrder
    exam_id?: SortOrderInput | SortOrder
    marks_obtained?: SortOrder
    total_marks?: SortOrder
    performance?: performanceOrderByRelationAggregateInput
    exams?: examsOrderByWithRelationInput
    students?: studentsOrderByWithRelationInput
  }

  export type student_performanceWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: student_performanceWhereInput | student_performanceWhereInput[]
    OR?: student_performanceWhereInput[]
    NOT?: student_performanceWhereInput | student_performanceWhereInput[]
    student_id?: IntNullableFilter<"student_performance"> | number | null
    exam_id?: IntNullableFilter<"student_performance"> | number | null
    marks_obtained?: DecimalFilter<"student_performance"> | Decimal | DecimalJsLike | number | string
    total_marks?: DecimalFilter<"student_performance"> | Decimal | DecimalJsLike | number | string
    performance?: PerformanceListRelationFilter
    exams?: XOR<ExamsNullableScalarRelationFilter, examsWhereInput> | null
    students?: XOR<StudentsNullableScalarRelationFilter, studentsWhereInput> | null
  }, "id">

  export type student_performanceOrderByWithAggregationInput = {
    id?: SortOrder
    student_id?: SortOrderInput | SortOrder
    exam_id?: SortOrderInput | SortOrder
    marks_obtained?: SortOrder
    total_marks?: SortOrder
    _count?: student_performanceCountOrderByAggregateInput
    _avg?: student_performanceAvgOrderByAggregateInput
    _max?: student_performanceMaxOrderByAggregateInput
    _min?: student_performanceMinOrderByAggregateInput
    _sum?: student_performanceSumOrderByAggregateInput
  }

  export type student_performanceScalarWhereWithAggregatesInput = {
    AND?: student_performanceScalarWhereWithAggregatesInput | student_performanceScalarWhereWithAggregatesInput[]
    OR?: student_performanceScalarWhereWithAggregatesInput[]
    NOT?: student_performanceScalarWhereWithAggregatesInput | student_performanceScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"student_performance"> | number
    student_id?: IntNullableWithAggregatesFilter<"student_performance"> | number | null
    exam_id?: IntNullableWithAggregatesFilter<"student_performance"> | number | null
    marks_obtained?: DecimalWithAggregatesFilter<"student_performance"> | Decimal | DecimalJsLike | number | string
    total_marks?: DecimalWithAggregatesFilter<"student_performance"> | Decimal | DecimalJsLike | number | string
  }

  export type student_routineWhereInput = {
    AND?: student_routineWhereInput | student_routineWhereInput[]
    OR?: student_routineWhereInput[]
    NOT?: student_routineWhereInput | student_routineWhereInput[]
    id?: IntFilter<"student_routine"> | number
    class?: StringFilter<"student_routine"> | string
    section?: StringFilter<"student_routine"> | string
    day?: StringFilter<"student_routine"> | string
    teacher_id?: IntFilter<"student_routine"> | number
    teacher_name?: StringFilter<"student_routine"> | string
    teacher_subject?: StringNullableFilter<"student_routine"> | string | null
    time_slot?: StringFilter<"student_routine"> | string
    teachers?: XOR<TeachersScalarRelationFilter, teachersWhereInput>
  }

  export type student_routineOrderByWithRelationInput = {
    id?: SortOrder
    class?: SortOrder
    section?: SortOrder
    day?: SortOrder
    teacher_id?: SortOrder
    teacher_name?: SortOrder
    teacher_subject?: SortOrderInput | SortOrder
    time_slot?: SortOrder
    teachers?: teachersOrderByWithRelationInput
  }

  export type student_routineWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: student_routineWhereInput | student_routineWhereInput[]
    OR?: student_routineWhereInput[]
    NOT?: student_routineWhereInput | student_routineWhereInput[]
    class?: StringFilter<"student_routine"> | string
    section?: StringFilter<"student_routine"> | string
    day?: StringFilter<"student_routine"> | string
    teacher_id?: IntFilter<"student_routine"> | number
    teacher_name?: StringFilter<"student_routine"> | string
    teacher_subject?: StringNullableFilter<"student_routine"> | string | null
    time_slot?: StringFilter<"student_routine"> | string
    teachers?: XOR<TeachersScalarRelationFilter, teachersWhereInput>
  }, "id">

  export type student_routineOrderByWithAggregationInput = {
    id?: SortOrder
    class?: SortOrder
    section?: SortOrder
    day?: SortOrder
    teacher_id?: SortOrder
    teacher_name?: SortOrder
    teacher_subject?: SortOrderInput | SortOrder
    time_slot?: SortOrder
    _count?: student_routineCountOrderByAggregateInput
    _avg?: student_routineAvgOrderByAggregateInput
    _max?: student_routineMaxOrderByAggregateInput
    _min?: student_routineMinOrderByAggregateInput
    _sum?: student_routineSumOrderByAggregateInput
  }

  export type student_routineScalarWhereWithAggregatesInput = {
    AND?: student_routineScalarWhereWithAggregatesInput | student_routineScalarWhereWithAggregatesInput[]
    OR?: student_routineScalarWhereWithAggregatesInput[]
    NOT?: student_routineScalarWhereWithAggregatesInput | student_routineScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"student_routine"> | number
    class?: StringWithAggregatesFilter<"student_routine"> | string
    section?: StringWithAggregatesFilter<"student_routine"> | string
    day?: StringWithAggregatesFilter<"student_routine"> | string
    teacher_id?: IntWithAggregatesFilter<"student_routine"> | number
    teacher_name?: StringWithAggregatesFilter<"student_routine"> | string
    teacher_subject?: StringNullableWithAggregatesFilter<"student_routine"> | string | null
    time_slot?: StringWithAggregatesFilter<"student_routine"> | string
  }

  export type studentsWhereInput = {
    AND?: studentsWhereInput | studentsWhereInput[]
    OR?: studentsWhereInput[]
    NOT?: studentsWhereInput | studentsWhereInput[]
    id?: IntFilter<"students"> | number
    user_id?: IntNullableFilter<"students"> | number | null
    admission_number?: StringFilter<"students"> | string
    class?: StringFilter<"students"> | string
    section?: StringFilter<"students"> | string
    parent_name?: StringNullableFilter<"students"> | string | null
    parent_phone?: StringNullableFilter<"students"> | string | null
    parent_email?: StringNullableFilter<"students"> | string | null
    parent_work?: StringNullableFilter<"students"> | string | null
    parent_photo1?: StringNullableFilter<"students"> | string | null
    parent_photo2?: StringNullableFilter<"students"> | string | null
    guardian_photo?: StringNullableFilter<"students"> | string | null
    guardian_phone?: StringNullableFilter<"students"> | string | null
    roll_number?: IntNullableFilter<"students"> | number | null
    attendance?: AttendanceListRelationFilter
    class_representatives?: Class_representativesListRelationFilter
    class_teachers?: Class_teachersListRelationFilter
    finances?: FinancesListRelationFilter
    student_performance?: Student_performanceListRelationFilter
    users?: XOR<UsersNullableScalarRelationFilter, usersWhereInput> | null
  }

  export type studentsOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrderInput | SortOrder
    admission_number?: SortOrder
    class?: SortOrder
    section?: SortOrder
    parent_name?: SortOrderInput | SortOrder
    parent_phone?: SortOrderInput | SortOrder
    parent_email?: SortOrderInput | SortOrder
    parent_work?: SortOrderInput | SortOrder
    parent_photo1?: SortOrderInput | SortOrder
    parent_photo2?: SortOrderInput | SortOrder
    guardian_photo?: SortOrderInput | SortOrder
    guardian_phone?: SortOrderInput | SortOrder
    roll_number?: SortOrderInput | SortOrder
    attendance?: attendanceOrderByRelationAggregateInput
    class_representatives?: class_representativesOrderByRelationAggregateInput
    class_teachers?: class_teachersOrderByRelationAggregateInput
    finances?: financesOrderByRelationAggregateInput
    student_performance?: student_performanceOrderByRelationAggregateInput
    users?: usersOrderByWithRelationInput
  }

  export type studentsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    admission_number?: string
    AND?: studentsWhereInput | studentsWhereInput[]
    OR?: studentsWhereInput[]
    NOT?: studentsWhereInput | studentsWhereInput[]
    user_id?: IntNullableFilter<"students"> | number | null
    class?: StringFilter<"students"> | string
    section?: StringFilter<"students"> | string
    parent_name?: StringNullableFilter<"students"> | string | null
    parent_phone?: StringNullableFilter<"students"> | string | null
    parent_email?: StringNullableFilter<"students"> | string | null
    parent_work?: StringNullableFilter<"students"> | string | null
    parent_photo1?: StringNullableFilter<"students"> | string | null
    parent_photo2?: StringNullableFilter<"students"> | string | null
    guardian_photo?: StringNullableFilter<"students"> | string | null
    guardian_phone?: StringNullableFilter<"students"> | string | null
    roll_number?: IntNullableFilter<"students"> | number | null
    attendance?: AttendanceListRelationFilter
    class_representatives?: Class_representativesListRelationFilter
    class_teachers?: Class_teachersListRelationFilter
    finances?: FinancesListRelationFilter
    student_performance?: Student_performanceListRelationFilter
    users?: XOR<UsersNullableScalarRelationFilter, usersWhereInput> | null
  }, "id" | "admission_number">

  export type studentsOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrderInput | SortOrder
    admission_number?: SortOrder
    class?: SortOrder
    section?: SortOrder
    parent_name?: SortOrderInput | SortOrder
    parent_phone?: SortOrderInput | SortOrder
    parent_email?: SortOrderInput | SortOrder
    parent_work?: SortOrderInput | SortOrder
    parent_photo1?: SortOrderInput | SortOrder
    parent_photo2?: SortOrderInput | SortOrder
    guardian_photo?: SortOrderInput | SortOrder
    guardian_phone?: SortOrderInput | SortOrder
    roll_number?: SortOrderInput | SortOrder
    _count?: studentsCountOrderByAggregateInput
    _avg?: studentsAvgOrderByAggregateInput
    _max?: studentsMaxOrderByAggregateInput
    _min?: studentsMinOrderByAggregateInput
    _sum?: studentsSumOrderByAggregateInput
  }

  export type studentsScalarWhereWithAggregatesInput = {
    AND?: studentsScalarWhereWithAggregatesInput | studentsScalarWhereWithAggregatesInput[]
    OR?: studentsScalarWhereWithAggregatesInput[]
    NOT?: studentsScalarWhereWithAggregatesInput | studentsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"students"> | number
    user_id?: IntNullableWithAggregatesFilter<"students"> | number | null
    admission_number?: StringWithAggregatesFilter<"students"> | string
    class?: StringWithAggregatesFilter<"students"> | string
    section?: StringWithAggregatesFilter<"students"> | string
    parent_name?: StringNullableWithAggregatesFilter<"students"> | string | null
    parent_phone?: StringNullableWithAggregatesFilter<"students"> | string | null
    parent_email?: StringNullableWithAggregatesFilter<"students"> | string | null
    parent_work?: StringNullableWithAggregatesFilter<"students"> | string | null
    parent_photo1?: StringNullableWithAggregatesFilter<"students"> | string | null
    parent_photo2?: StringNullableWithAggregatesFilter<"students"> | string | null
    guardian_photo?: StringNullableWithAggregatesFilter<"students"> | string | null
    guardian_phone?: StringNullableWithAggregatesFilter<"students"> | string | null
    roll_number?: IntNullableWithAggregatesFilter<"students"> | number | null
  }

  export type teacher_routineWhereInput = {
    AND?: teacher_routineWhereInput | teacher_routineWhereInput[]
    OR?: teacher_routineWhereInput[]
    NOT?: teacher_routineWhereInput | teacher_routineWhereInput[]
    id?: IntFilter<"teacher_routine"> | number
    teacher_id?: IntFilter<"teacher_routine"> | number
    day?: StringFilter<"teacher_routine"> | string
    time_slot?: StringFilter<"teacher_routine"> | string
    class?: StringFilter<"teacher_routine"> | string
    section?: StringFilter<"teacher_routine"> | string
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }

  export type teacher_routineOrderByWithRelationInput = {
    id?: SortOrder
    teacher_id?: SortOrder
    day?: SortOrder
    time_slot?: SortOrder
    class?: SortOrder
    section?: SortOrder
    users?: usersOrderByWithRelationInput
  }

  export type teacher_routineWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: teacher_routineWhereInput | teacher_routineWhereInput[]
    OR?: teacher_routineWhereInput[]
    NOT?: teacher_routineWhereInput | teacher_routineWhereInput[]
    teacher_id?: IntFilter<"teacher_routine"> | number
    day?: StringFilter<"teacher_routine"> | string
    time_slot?: StringFilter<"teacher_routine"> | string
    class?: StringFilter<"teacher_routine"> | string
    section?: StringFilter<"teacher_routine"> | string
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }, "id">

  export type teacher_routineOrderByWithAggregationInput = {
    id?: SortOrder
    teacher_id?: SortOrder
    day?: SortOrder
    time_slot?: SortOrder
    class?: SortOrder
    section?: SortOrder
    _count?: teacher_routineCountOrderByAggregateInput
    _avg?: teacher_routineAvgOrderByAggregateInput
    _max?: teacher_routineMaxOrderByAggregateInput
    _min?: teacher_routineMinOrderByAggregateInput
    _sum?: teacher_routineSumOrderByAggregateInput
  }

  export type teacher_routineScalarWhereWithAggregatesInput = {
    AND?: teacher_routineScalarWhereWithAggregatesInput | teacher_routineScalarWhereWithAggregatesInput[]
    OR?: teacher_routineScalarWhereWithAggregatesInput[]
    NOT?: teacher_routineScalarWhereWithAggregatesInput | teacher_routineScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"teacher_routine"> | number
    teacher_id?: IntWithAggregatesFilter<"teacher_routine"> | number
    day?: StringWithAggregatesFilter<"teacher_routine"> | string
    time_slot?: StringWithAggregatesFilter<"teacher_routine"> | string
    class?: StringWithAggregatesFilter<"teacher_routine"> | string
    section?: StringWithAggregatesFilter<"teacher_routine"> | string
  }

  export type teachersWhereInput = {
    AND?: teachersWhereInput | teachersWhereInput[]
    OR?: teachersWhereInput[]
    NOT?: teachersWhereInput | teachersWhereInput[]
    id?: IntFilter<"teachers"> | number
    user_id?: IntNullableFilter<"teachers"> | number | null
    specialised_subject?: StringFilter<"teachers"> | string
    assigned_class?: StringNullableFilter<"teachers"> | string | null
    assigned_section?: StringNullableFilter<"teachers"> | string | null
    assignments?: AssignmentsListRelationFilter
    attendance?: AttendanceListRelationFilter
    class_routine?: Class_routineListRelationFilter
    class_teachers?: Class_teachersListRelationFilter
    exams?: ExamsListRelationFilter
    performance?: PerformanceListRelationFilter
    student_routine?: Student_routineListRelationFilter
    users?: XOR<UsersNullableScalarRelationFilter, usersWhereInput> | null
  }

  export type teachersOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrderInput | SortOrder
    specialised_subject?: SortOrder
    assigned_class?: SortOrderInput | SortOrder
    assigned_section?: SortOrderInput | SortOrder
    assignments?: assignmentsOrderByRelationAggregateInput
    attendance?: attendanceOrderByRelationAggregateInput
    class_routine?: class_routineOrderByRelationAggregateInput
    class_teachers?: class_teachersOrderByRelationAggregateInput
    exams?: examsOrderByRelationAggregateInput
    performance?: performanceOrderByRelationAggregateInput
    student_routine?: student_routineOrderByRelationAggregateInput
    users?: usersOrderByWithRelationInput
  }

  export type teachersWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: teachersWhereInput | teachersWhereInput[]
    OR?: teachersWhereInput[]
    NOT?: teachersWhereInput | teachersWhereInput[]
    user_id?: IntNullableFilter<"teachers"> | number | null
    specialised_subject?: StringFilter<"teachers"> | string
    assigned_class?: StringNullableFilter<"teachers"> | string | null
    assigned_section?: StringNullableFilter<"teachers"> | string | null
    assignments?: AssignmentsListRelationFilter
    attendance?: AttendanceListRelationFilter
    class_routine?: Class_routineListRelationFilter
    class_teachers?: Class_teachersListRelationFilter
    exams?: ExamsListRelationFilter
    performance?: PerformanceListRelationFilter
    student_routine?: Student_routineListRelationFilter
    users?: XOR<UsersNullableScalarRelationFilter, usersWhereInput> | null
  }, "id">

  export type teachersOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrderInput | SortOrder
    specialised_subject?: SortOrder
    assigned_class?: SortOrderInput | SortOrder
    assigned_section?: SortOrderInput | SortOrder
    _count?: teachersCountOrderByAggregateInput
    _avg?: teachersAvgOrderByAggregateInput
    _max?: teachersMaxOrderByAggregateInput
    _min?: teachersMinOrderByAggregateInput
    _sum?: teachersSumOrderByAggregateInput
  }

  export type teachersScalarWhereWithAggregatesInput = {
    AND?: teachersScalarWhereWithAggregatesInput | teachersScalarWhereWithAggregatesInput[]
    OR?: teachersScalarWhereWithAggregatesInput[]
    NOT?: teachersScalarWhereWithAggregatesInput | teachersScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"teachers"> | number
    user_id?: IntNullableWithAggregatesFilter<"teachers"> | number | null
    specialised_subject?: StringWithAggregatesFilter<"teachers"> | string
    assigned_class?: StringNullableWithAggregatesFilter<"teachers"> | string | null
    assigned_section?: StringNullableWithAggregatesFilter<"teachers"> | string | null
  }

  export type upcoming_eventsWhereInput = {
    AND?: upcoming_eventsWhereInput | upcoming_eventsWhereInput[]
    OR?: upcoming_eventsWhereInput[]
    NOT?: upcoming_eventsWhereInput | upcoming_eventsWhereInput[]
    id?: IntFilter<"upcoming_events"> | number
    calendar_id?: IntNullableFilter<"upcoming_events"> | number | null
    event_date?: DateTimeFilter<"upcoming_events"> | Date | string
    event_name?: StringFilter<"upcoming_events"> | string
    holiday?: BoolFilter<"upcoming_events"> | boolean
    calendar?: XOR<CalendarNullableScalarRelationFilter, calendarWhereInput> | null
  }

  export type upcoming_eventsOrderByWithRelationInput = {
    id?: SortOrder
    calendar_id?: SortOrderInput | SortOrder
    event_date?: SortOrder
    event_name?: SortOrder
    holiday?: SortOrder
    calendar?: calendarOrderByWithRelationInput
  }

  export type upcoming_eventsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: upcoming_eventsWhereInput | upcoming_eventsWhereInput[]
    OR?: upcoming_eventsWhereInput[]
    NOT?: upcoming_eventsWhereInput | upcoming_eventsWhereInput[]
    calendar_id?: IntNullableFilter<"upcoming_events"> | number | null
    event_date?: DateTimeFilter<"upcoming_events"> | Date | string
    event_name?: StringFilter<"upcoming_events"> | string
    holiday?: BoolFilter<"upcoming_events"> | boolean
    calendar?: XOR<CalendarNullableScalarRelationFilter, calendarWhereInput> | null
  }, "id">

  export type upcoming_eventsOrderByWithAggregationInput = {
    id?: SortOrder
    calendar_id?: SortOrderInput | SortOrder
    event_date?: SortOrder
    event_name?: SortOrder
    holiday?: SortOrder
    _count?: upcoming_eventsCountOrderByAggregateInput
    _avg?: upcoming_eventsAvgOrderByAggregateInput
    _max?: upcoming_eventsMaxOrderByAggregateInput
    _min?: upcoming_eventsMinOrderByAggregateInput
    _sum?: upcoming_eventsSumOrderByAggregateInput
  }

  export type upcoming_eventsScalarWhereWithAggregatesInput = {
    AND?: upcoming_eventsScalarWhereWithAggregatesInput | upcoming_eventsScalarWhereWithAggregatesInput[]
    OR?: upcoming_eventsScalarWhereWithAggregatesInput[]
    NOT?: upcoming_eventsScalarWhereWithAggregatesInput | upcoming_eventsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"upcoming_events"> | number
    calendar_id?: IntNullableWithAggregatesFilter<"upcoming_events"> | number | null
    event_date?: DateTimeWithAggregatesFilter<"upcoming_events"> | Date | string
    event_name?: StringWithAggregatesFilter<"upcoming_events"> | string
    holiday?: BoolWithAggregatesFilter<"upcoming_events"> | boolean
  }

  export type usersWhereInput = {
    AND?: usersWhereInput | usersWhereInput[]
    OR?: usersWhereInput[]
    NOT?: usersWhereInput | usersWhereInput[]
    id?: IntFilter<"users"> | number
    name?: StringFilter<"users"> | string
    email?: StringFilter<"users"> | string
    password?: StringFilter<"users"> | string
    role?: StringFilter<"users"> | string
    phone?: StringNullableFilter<"users"> | string | null
    address?: StringNullableFilter<"users"> | string | null
    photo?: StringNullableFilter<"users"> | string | null
    notes?: NotesListRelationFilter
    notices?: NoticesListRelationFilter
    students?: StudentsListRelationFilter
    teacher_routine?: Teacher_routineListRelationFilter
    teachers?: TeachersListRelationFilter
    workroom_messages_workroom_messages_receiver_idTousers?: Workroom_messagesListRelationFilter
    workroom_messages_workroom_messages_sender_idTousers?: Workroom_messagesListRelationFilter
  }

  export type usersOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    phone?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    photo?: SortOrderInput | SortOrder
    notes?: notesOrderByRelationAggregateInput
    notices?: noticesOrderByRelationAggregateInput
    students?: studentsOrderByRelationAggregateInput
    teacher_routine?: teacher_routineOrderByRelationAggregateInput
    teachers?: teachersOrderByRelationAggregateInput
    workroom_messages_workroom_messages_receiver_idTousers?: workroom_messagesOrderByRelationAggregateInput
    workroom_messages_workroom_messages_sender_idTousers?: workroom_messagesOrderByRelationAggregateInput
  }

  export type usersWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    email?: string
    AND?: usersWhereInput | usersWhereInput[]
    OR?: usersWhereInput[]
    NOT?: usersWhereInput | usersWhereInput[]
    name?: StringFilter<"users"> | string
    password?: StringFilter<"users"> | string
    role?: StringFilter<"users"> | string
    phone?: StringNullableFilter<"users"> | string | null
    address?: StringNullableFilter<"users"> | string | null
    photo?: StringNullableFilter<"users"> | string | null
    notes?: NotesListRelationFilter
    notices?: NoticesListRelationFilter
    students?: StudentsListRelationFilter
    teacher_routine?: Teacher_routineListRelationFilter
    teachers?: TeachersListRelationFilter
    workroom_messages_workroom_messages_receiver_idTousers?: Workroom_messagesListRelationFilter
    workroom_messages_workroom_messages_sender_idTousers?: Workroom_messagesListRelationFilter
  }, "id" | "email">

  export type usersOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    phone?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    photo?: SortOrderInput | SortOrder
    _count?: usersCountOrderByAggregateInput
    _avg?: usersAvgOrderByAggregateInput
    _max?: usersMaxOrderByAggregateInput
    _min?: usersMinOrderByAggregateInput
    _sum?: usersSumOrderByAggregateInput
  }

  export type usersScalarWhereWithAggregatesInput = {
    AND?: usersScalarWhereWithAggregatesInput | usersScalarWhereWithAggregatesInput[]
    OR?: usersScalarWhereWithAggregatesInput[]
    NOT?: usersScalarWhereWithAggregatesInput | usersScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"users"> | number
    name?: StringWithAggregatesFilter<"users"> | string
    email?: StringWithAggregatesFilter<"users"> | string
    password?: StringWithAggregatesFilter<"users"> | string
    role?: StringWithAggregatesFilter<"users"> | string
    phone?: StringNullableWithAggregatesFilter<"users"> | string | null
    address?: StringNullableWithAggregatesFilter<"users"> | string | null
    photo?: StringNullableWithAggregatesFilter<"users"> | string | null
  }

  export type workroom_messagesWhereInput = {
    AND?: workroom_messagesWhereInput | workroom_messagesWhereInput[]
    OR?: workroom_messagesWhereInput[]
    NOT?: workroom_messagesWhereInput | workroom_messagesWhereInput[]
    id?: IntFilter<"workroom_messages"> | number
    sender_id?: IntNullableFilter<"workroom_messages"> | number | null
    receiver_id?: IntNullableFilter<"workroom_messages"> | number | null
    message?: StringFilter<"workroom_messages"> | string
    sent_at?: DateTimeNullableFilter<"workroom_messages"> | Date | string | null
    users_workroom_messages_receiver_idTousers?: XOR<UsersNullableScalarRelationFilter, usersWhereInput> | null
    users_workroom_messages_sender_idTousers?: XOR<UsersNullableScalarRelationFilter, usersWhereInput> | null
  }

  export type workroom_messagesOrderByWithRelationInput = {
    id?: SortOrder
    sender_id?: SortOrderInput | SortOrder
    receiver_id?: SortOrderInput | SortOrder
    message?: SortOrder
    sent_at?: SortOrderInput | SortOrder
    users_workroom_messages_receiver_idTousers?: usersOrderByWithRelationInput
    users_workroom_messages_sender_idTousers?: usersOrderByWithRelationInput
  }

  export type workroom_messagesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: workroom_messagesWhereInput | workroom_messagesWhereInput[]
    OR?: workroom_messagesWhereInput[]
    NOT?: workroom_messagesWhereInput | workroom_messagesWhereInput[]
    sender_id?: IntNullableFilter<"workroom_messages"> | number | null
    receiver_id?: IntNullableFilter<"workroom_messages"> | number | null
    message?: StringFilter<"workroom_messages"> | string
    sent_at?: DateTimeNullableFilter<"workroom_messages"> | Date | string | null
    users_workroom_messages_receiver_idTousers?: XOR<UsersNullableScalarRelationFilter, usersWhereInput> | null
    users_workroom_messages_sender_idTousers?: XOR<UsersNullableScalarRelationFilter, usersWhereInput> | null
  }, "id">

  export type workroom_messagesOrderByWithAggregationInput = {
    id?: SortOrder
    sender_id?: SortOrderInput | SortOrder
    receiver_id?: SortOrderInput | SortOrder
    message?: SortOrder
    sent_at?: SortOrderInput | SortOrder
    _count?: workroom_messagesCountOrderByAggregateInput
    _avg?: workroom_messagesAvgOrderByAggregateInput
    _max?: workroom_messagesMaxOrderByAggregateInput
    _min?: workroom_messagesMinOrderByAggregateInput
    _sum?: workroom_messagesSumOrderByAggregateInput
  }

  export type workroom_messagesScalarWhereWithAggregatesInput = {
    AND?: workroom_messagesScalarWhereWithAggregatesInput | workroom_messagesScalarWhereWithAggregatesInput[]
    OR?: workroom_messagesScalarWhereWithAggregatesInput[]
    NOT?: workroom_messagesScalarWhereWithAggregatesInput | workroom_messagesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"workroom_messages"> | number
    sender_id?: IntNullableWithAggregatesFilter<"workroom_messages"> | number | null
    receiver_id?: IntNullableWithAggregatesFilter<"workroom_messages"> | number | null
    message?: StringWithAggregatesFilter<"workroom_messages"> | string
    sent_at?: DateTimeNullableWithAggregatesFilter<"workroom_messages"> | Date | string | null
  }

  export type assignmentsCreateInput = {
    title: string
    description: string
    subject: string
    class: string
    section: string
    due_date: Date | string
    file?: string | null
    teachers?: teachersCreateNestedOneWithoutAssignmentsInput
  }

  export type assignmentsUncheckedCreateInput = {
    id?: number
    title: string
    description: string
    subject: string
    class: string
    section: string
    assigned_by?: number | null
    due_date: Date | string
    file?: string | null
  }

  export type assignmentsUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    class?: StringFieldUpdateOperationsInput | string
    section?: StringFieldUpdateOperationsInput | string
    due_date?: DateTimeFieldUpdateOperationsInput | Date | string
    file?: NullableStringFieldUpdateOperationsInput | string | null
    teachers?: teachersUpdateOneWithoutAssignmentsNestedInput
  }

  export type assignmentsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    class?: StringFieldUpdateOperationsInput | string
    section?: StringFieldUpdateOperationsInput | string
    assigned_by?: NullableIntFieldUpdateOperationsInput | number | null
    due_date?: DateTimeFieldUpdateOperationsInput | Date | string
    file?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type assignmentsCreateManyInput = {
    id?: number
    title: string
    description: string
    subject: string
    class: string
    section: string
    assigned_by?: number | null
    due_date: Date | string
    file?: string | null
  }

  export type assignmentsUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    class?: StringFieldUpdateOperationsInput | string
    section?: StringFieldUpdateOperationsInput | string
    due_date?: DateTimeFieldUpdateOperationsInput | Date | string
    file?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type assignmentsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    class?: StringFieldUpdateOperationsInput | string
    section?: StringFieldUpdateOperationsInput | string
    assigned_by?: NullableIntFieldUpdateOperationsInput | number | null
    due_date?: DateTimeFieldUpdateOperationsInput | Date | string
    file?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type attendanceCreateInput = {
    class: number
    section: string
    date: Date | string
    status: string
    created_at?: Date | string | null
    students: studentsCreateNestedOneWithoutAttendanceInput
    teachers: teachersCreateNestedOneWithoutAttendanceInput
  }

  export type attendanceUncheckedCreateInput = {
    id?: number
    student_id: number
    teacher_id: number
    class: number
    section: string
    date: Date | string
    status: string
    created_at?: Date | string | null
  }

  export type attendanceUpdateInput = {
    class?: IntFieldUpdateOperationsInput | number
    section?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    students?: studentsUpdateOneRequiredWithoutAttendanceNestedInput
    teachers?: teachersUpdateOneRequiredWithoutAttendanceNestedInput
  }

  export type attendanceUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    student_id?: IntFieldUpdateOperationsInput | number
    teacher_id?: IntFieldUpdateOperationsInput | number
    class?: IntFieldUpdateOperationsInput | number
    section?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type attendanceCreateManyInput = {
    id?: number
    student_id: number
    teacher_id: number
    class: number
    section: string
    date: Date | string
    status: string
    created_at?: Date | string | null
  }

  export type attendanceUpdateManyMutationInput = {
    class?: IntFieldUpdateOperationsInput | number
    section?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type attendanceUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    student_id?: IntFieldUpdateOperationsInput | number
    teacher_id?: IntFieldUpdateOperationsInput | number
    class?: IntFieldUpdateOperationsInput | number
    section?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type calendarCreateInput = {
    month: string
    calendar: string
    year?: number | null
    upcoming_events?: upcoming_eventsCreateNestedManyWithoutCalendarInput
  }

  export type calendarUncheckedCreateInput = {
    id?: number
    month: string
    calendar: string
    year?: number | null
    upcoming_events?: upcoming_eventsUncheckedCreateNestedManyWithoutCalendarInput
  }

  export type calendarUpdateInput = {
    month?: StringFieldUpdateOperationsInput | string
    calendar?: StringFieldUpdateOperationsInput | string
    year?: NullableIntFieldUpdateOperationsInput | number | null
    upcoming_events?: upcoming_eventsUpdateManyWithoutCalendarNestedInput
  }

  export type calendarUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    month?: StringFieldUpdateOperationsInput | string
    calendar?: StringFieldUpdateOperationsInput | string
    year?: NullableIntFieldUpdateOperationsInput | number | null
    upcoming_events?: upcoming_eventsUncheckedUpdateManyWithoutCalendarNestedInput
  }

  export type calendarCreateManyInput = {
    id?: number
    month: string
    calendar: string
    year?: number | null
  }

  export type calendarUpdateManyMutationInput = {
    month?: StringFieldUpdateOperationsInput | string
    calendar?: StringFieldUpdateOperationsInput | string
    year?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type calendarUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    month?: StringFieldUpdateOperationsInput | string
    calendar?: StringFieldUpdateOperationsInput | string
    year?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type class_representativesCreateInput = {
    class: string
    section: string
    students?: studentsCreateNestedOneWithoutClass_representativesInput
  }

  export type class_representativesUncheckedCreateInput = {
    id?: number
    student_id?: number | null
    class: string
    section: string
  }

  export type class_representativesUpdateInput = {
    class?: StringFieldUpdateOperationsInput | string
    section?: StringFieldUpdateOperationsInput | string
    students?: studentsUpdateOneWithoutClass_representativesNestedInput
  }

  export type class_representativesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    student_id?: NullableIntFieldUpdateOperationsInput | number | null
    class?: StringFieldUpdateOperationsInput | string
    section?: StringFieldUpdateOperationsInput | string
  }

  export type class_representativesCreateManyInput = {
    id?: number
    student_id?: number | null
    class: string
    section: string
  }

  export type class_representativesUpdateManyMutationInput = {
    class?: StringFieldUpdateOperationsInput | string
    section?: StringFieldUpdateOperationsInput | string
  }

  export type class_representativesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    student_id?: NullableIntFieldUpdateOperationsInput | number | null
    class?: StringFieldUpdateOperationsInput | string
    section?: StringFieldUpdateOperationsInput | string
  }

  export type class_routineCreateInput = {
    class: string
    section: string
    day: string
    period: number
    subject: string
    teachers?: teachersCreateNestedOneWithoutClass_routineInput
  }

  export type class_routineUncheckedCreateInput = {
    id?: number
    class: string
    section: string
    day: string
    period: number
    subject: string
    teacher_id?: number | null
  }

  export type class_routineUpdateInput = {
    class?: StringFieldUpdateOperationsInput | string
    section?: StringFieldUpdateOperationsInput | string
    day?: StringFieldUpdateOperationsInput | string
    period?: IntFieldUpdateOperationsInput | number
    subject?: StringFieldUpdateOperationsInput | string
    teachers?: teachersUpdateOneWithoutClass_routineNestedInput
  }

  export type class_routineUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    class?: StringFieldUpdateOperationsInput | string
    section?: StringFieldUpdateOperationsInput | string
    day?: StringFieldUpdateOperationsInput | string
    period?: IntFieldUpdateOperationsInput | number
    subject?: StringFieldUpdateOperationsInput | string
    teacher_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type class_routineCreateManyInput = {
    id?: number
    class: string
    section: string
    day: string
    period: number
    subject: string
    teacher_id?: number | null
  }

  export type class_routineUpdateManyMutationInput = {
    class?: StringFieldUpdateOperationsInput | string
    section?: StringFieldUpdateOperationsInput | string
    day?: StringFieldUpdateOperationsInput | string
    period?: IntFieldUpdateOperationsInput | number
    subject?: StringFieldUpdateOperationsInput | string
  }

  export type class_routineUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    class?: StringFieldUpdateOperationsInput | string
    section?: StringFieldUpdateOperationsInput | string
    day?: StringFieldUpdateOperationsInput | string
    period?: IntFieldUpdateOperationsInput | number
    subject?: StringFieldUpdateOperationsInput | string
    teacher_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type class_teachersCreateInput = {
    class: string
    section: string
    second_class_representative_student_id?: number | null
    students?: studentsCreateNestedOneWithoutClass_teachersInput
    teachers: teachersCreateNestedOneWithoutClass_teachersInput
  }

  export type class_teachersUncheckedCreateInput = {
    id?: number
    class: string
    section: string
    teacher_id: number
    class_representative_student_id?: number | null
    second_class_representative_student_id?: number | null
  }

  export type class_teachersUpdateInput = {
    class?: StringFieldUpdateOperationsInput | string
    section?: StringFieldUpdateOperationsInput | string
    second_class_representative_student_id?: NullableIntFieldUpdateOperationsInput | number | null
    students?: studentsUpdateOneWithoutClass_teachersNestedInput
    teachers?: teachersUpdateOneRequiredWithoutClass_teachersNestedInput
  }

  export type class_teachersUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    class?: StringFieldUpdateOperationsInput | string
    section?: StringFieldUpdateOperationsInput | string
    teacher_id?: IntFieldUpdateOperationsInput | number
    class_representative_student_id?: NullableIntFieldUpdateOperationsInput | number | null
    second_class_representative_student_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type class_teachersCreateManyInput = {
    id?: number
    class: string
    section: string
    teacher_id: number
    class_representative_student_id?: number | null
    second_class_representative_student_id?: number | null
  }

  export type class_teachersUpdateManyMutationInput = {
    class?: StringFieldUpdateOperationsInput | string
    section?: StringFieldUpdateOperationsInput | string
    second_class_representative_student_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type class_teachersUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    class?: StringFieldUpdateOperationsInput | string
    section?: StringFieldUpdateOperationsInput | string
    teacher_id?: IntFieldUpdateOperationsInput | number
    class_representative_student_id?: NullableIntFieldUpdateOperationsInput | number | null
    second_class_representative_student_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type examsCreateInput = {
    class: string
    section: string
    subject: string
    exam_date: Date | string
    exam_duration?: string | null
    exam_type?: string | null
    teachers?: teachersCreateNestedOneWithoutExamsInput
    performance?: performanceCreateNestedManyWithoutExamsInput
    student_performance?: student_performanceCreateNestedManyWithoutExamsInput
  }

  export type examsUncheckedCreateInput = {
    id?: number
    class: string
    section: string
    subject: string
    exam_date: Date | string
    exam_duration?: string | null
    exam_type?: string | null
    created_by?: number | null
    performance?: performanceUncheckedCreateNestedManyWithoutExamsInput
    student_performance?: student_performanceUncheckedCreateNestedManyWithoutExamsInput
  }

  export type examsUpdateInput = {
    class?: StringFieldUpdateOperationsInput | string
    section?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    exam_date?: DateTimeFieldUpdateOperationsInput | Date | string
    exam_duration?: NullableStringFieldUpdateOperationsInput | string | null
    exam_type?: NullableStringFieldUpdateOperationsInput | string | null
    teachers?: teachersUpdateOneWithoutExamsNestedInput
    performance?: performanceUpdateManyWithoutExamsNestedInput
    student_performance?: student_performanceUpdateManyWithoutExamsNestedInput
  }

  export type examsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    class?: StringFieldUpdateOperationsInput | string
    section?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    exam_date?: DateTimeFieldUpdateOperationsInput | Date | string
    exam_duration?: NullableStringFieldUpdateOperationsInput | string | null
    exam_type?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    performance?: performanceUncheckedUpdateManyWithoutExamsNestedInput
    student_performance?: student_performanceUncheckedUpdateManyWithoutExamsNestedInput
  }

  export type examsCreateManyInput = {
    id?: number
    class: string
    section: string
    subject: string
    exam_date: Date | string
    exam_duration?: string | null
    exam_type?: string | null
    created_by?: number | null
  }

  export type examsUpdateManyMutationInput = {
    class?: StringFieldUpdateOperationsInput | string
    section?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    exam_date?: DateTimeFieldUpdateOperationsInput | Date | string
    exam_duration?: NullableStringFieldUpdateOperationsInput | string | null
    exam_type?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type examsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    class?: StringFieldUpdateOperationsInput | string
    section?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    exam_date?: DateTimeFieldUpdateOperationsInput | Date | string
    exam_duration?: NullableStringFieldUpdateOperationsInput | string | null
    exam_type?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type financecheckbookCreateInput = {
    month: string
    income: Decimal | DecimalJsLike | number | string
    expenses: Decimal | DecimalJsLike | number | string
    total_due_amount?: Decimal | DecimalJsLike | number | string | null
  }

  export type financecheckbookUncheckedCreateInput = {
    id?: number
    month: string
    income: Decimal | DecimalJsLike | number | string
    expenses: Decimal | DecimalJsLike | number | string
    total_due_amount?: Decimal | DecimalJsLike | number | string | null
  }

  export type financecheckbookUpdateInput = {
    month?: StringFieldUpdateOperationsInput | string
    income?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    expenses?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total_due_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type financecheckbookUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    month?: StringFieldUpdateOperationsInput | string
    income?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    expenses?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total_due_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type financecheckbookCreateManyInput = {
    id?: number
    month: string
    income: Decimal | DecimalJsLike | number | string
    expenses: Decimal | DecimalJsLike | number | string
    total_due_amount?: Decimal | DecimalJsLike | number | string | null
  }

  export type financecheckbookUpdateManyMutationInput = {
    month?: StringFieldUpdateOperationsInput | string
    income?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    expenses?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total_due_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type financecheckbookUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    month?: StringFieldUpdateOperationsInput | string
    income?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    expenses?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total_due_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type financesCreateInput = {
    total_fee: Decimal | DecimalJsLike | number | string
    paid_amount?: Decimal | DecimalJsLike | number | string | null
    due_amount?: Decimal | DecimalJsLike | number | string | null
    month: string
    payment_status?: string | null
    penalty?: Decimal | DecimalJsLike | number | string | null
    expenses?: Decimal | DecimalJsLike | number | string | null
    students?: studentsCreateNestedOneWithoutFinancesInput
  }

  export type financesUncheckedCreateInput = {
    id?: number
    student_id?: number | null
    total_fee: Decimal | DecimalJsLike | number | string
    paid_amount?: Decimal | DecimalJsLike | number | string | null
    due_amount?: Decimal | DecimalJsLike | number | string | null
    month: string
    payment_status?: string | null
    penalty?: Decimal | DecimalJsLike | number | string | null
    expenses?: Decimal | DecimalJsLike | number | string | null
  }

  export type financesUpdateInput = {
    total_fee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paid_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    due_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    month?: StringFieldUpdateOperationsInput | string
    payment_status?: NullableStringFieldUpdateOperationsInput | string | null
    penalty?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    expenses?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    students?: studentsUpdateOneWithoutFinancesNestedInput
  }

  export type financesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    student_id?: NullableIntFieldUpdateOperationsInput | number | null
    total_fee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paid_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    due_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    month?: StringFieldUpdateOperationsInput | string
    payment_status?: NullableStringFieldUpdateOperationsInput | string | null
    penalty?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    expenses?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type financesCreateManyInput = {
    id?: number
    student_id?: number | null
    total_fee: Decimal | DecimalJsLike | number | string
    paid_amount?: Decimal | DecimalJsLike | number | string | null
    due_amount?: Decimal | DecimalJsLike | number | string | null
    month: string
    payment_status?: string | null
    penalty?: Decimal | DecimalJsLike | number | string | null
    expenses?: Decimal | DecimalJsLike | number | string | null
  }

  export type financesUpdateManyMutationInput = {
    total_fee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paid_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    due_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    month?: StringFieldUpdateOperationsInput | string
    payment_status?: NullableStringFieldUpdateOperationsInput | string | null
    penalty?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    expenses?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type financesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    student_id?: NullableIntFieldUpdateOperationsInput | number | null
    total_fee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paid_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    due_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    month?: StringFieldUpdateOperationsInput | string
    payment_status?: NullableStringFieldUpdateOperationsInput | string | null
    penalty?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    expenses?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type notesCreateInput = {
    title: string
    content: string
    subject: string
    class: string
    section: string
    files?: string | null
    created_at?: Date | string | null
    users?: usersCreateNestedOneWithoutNotesInput
  }

  export type notesUncheckedCreateInput = {
    id?: number
    title: string
    content: string
    subject: string
    class: string
    section: string
    created_by?: number | null
    files?: string | null
    created_at?: Date | string | null
  }

  export type notesUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    class?: StringFieldUpdateOperationsInput | string
    section?: StringFieldUpdateOperationsInput | string
    files?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    users?: usersUpdateOneWithoutNotesNestedInput
  }

  export type notesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    class?: StringFieldUpdateOperationsInput | string
    section?: StringFieldUpdateOperationsInput | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    files?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type notesCreateManyInput = {
    id?: number
    title: string
    content: string
    subject: string
    class: string
    section: string
    created_by?: number | null
    files?: string | null
    created_at?: Date | string | null
  }

  export type notesUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    class?: StringFieldUpdateOperationsInput | string
    section?: StringFieldUpdateOperationsInput | string
    files?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type notesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    class?: StringFieldUpdateOperationsInput | string
    section?: StringFieldUpdateOperationsInput | string
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    files?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type noticesCreateInput = {
    title: string
    content: string
    created_at?: Date | string | null
    target_role: string
    users?: usersCreateNestedOneWithoutNoticesInput
  }

  export type noticesUncheckedCreateInput = {
    id?: number
    title: string
    content: string
    created_at?: Date | string | null
    created_by?: number | null
    target_role: string
  }

  export type noticesUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    target_role?: StringFieldUpdateOperationsInput | string
    users?: usersUpdateOneWithoutNoticesNestedInput
  }

  export type noticesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    target_role?: StringFieldUpdateOperationsInput | string
  }

  export type noticesCreateManyInput = {
    id?: number
    title: string
    content: string
    created_at?: Date | string | null
    created_by?: number | null
    target_role: string
  }

  export type noticesUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    target_role?: StringFieldUpdateOperationsInput | string
  }

  export type noticesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    target_role?: StringFieldUpdateOperationsInput | string
  }

  export type performanceCreateInput = {
    class: string
    section: string
    exams?: examsCreateNestedOneWithoutPerformanceInput
    student_performance?: student_performanceCreateNestedOneWithoutPerformanceInput
    teachers?: teachersCreateNestedOneWithoutPerformanceInput
  }

  export type performanceUncheckedCreateInput = {
    id?: number
    class: string
    section: string
    class_teacher?: number | null
    class_performance?: number | null
    exam_id?: number | null
  }

  export type performanceUpdateInput = {
    class?: StringFieldUpdateOperationsInput | string
    section?: StringFieldUpdateOperationsInput | string
    exams?: examsUpdateOneWithoutPerformanceNestedInput
    student_performance?: student_performanceUpdateOneWithoutPerformanceNestedInput
    teachers?: teachersUpdateOneWithoutPerformanceNestedInput
  }

  export type performanceUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    class?: StringFieldUpdateOperationsInput | string
    section?: StringFieldUpdateOperationsInput | string
    class_teacher?: NullableIntFieldUpdateOperationsInput | number | null
    class_performance?: NullableIntFieldUpdateOperationsInput | number | null
    exam_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type performanceCreateManyInput = {
    id?: number
    class: string
    section: string
    class_teacher?: number | null
    class_performance?: number | null
    exam_id?: number | null
  }

  export type performanceUpdateManyMutationInput = {
    class?: StringFieldUpdateOperationsInput | string
    section?: StringFieldUpdateOperationsInput | string
  }

  export type performanceUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    class?: StringFieldUpdateOperationsInput | string
    section?: StringFieldUpdateOperationsInput | string
    class_teacher?: NullableIntFieldUpdateOperationsInput | number | null
    class_performance?: NullableIntFieldUpdateOperationsInput | number | null
    exam_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type student_performanceCreateInput = {
    marks_obtained: Decimal | DecimalJsLike | number | string
    total_marks: Decimal | DecimalJsLike | number | string
    performance?: performanceCreateNestedManyWithoutStudent_performanceInput
    exams?: examsCreateNestedOneWithoutStudent_performanceInput
    students?: studentsCreateNestedOneWithoutStudent_performanceInput
  }

  export type student_performanceUncheckedCreateInput = {
    id?: number
    student_id?: number | null
    exam_id?: number | null
    marks_obtained: Decimal | DecimalJsLike | number | string
    total_marks: Decimal | DecimalJsLike | number | string
    performance?: performanceUncheckedCreateNestedManyWithoutStudent_performanceInput
  }

  export type student_performanceUpdateInput = {
    marks_obtained?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total_marks?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    performance?: performanceUpdateManyWithoutStudent_performanceNestedInput
    exams?: examsUpdateOneWithoutStudent_performanceNestedInput
    students?: studentsUpdateOneWithoutStudent_performanceNestedInput
  }

  export type student_performanceUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    student_id?: NullableIntFieldUpdateOperationsInput | number | null
    exam_id?: NullableIntFieldUpdateOperationsInput | number | null
    marks_obtained?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total_marks?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    performance?: performanceUncheckedUpdateManyWithoutStudent_performanceNestedInput
  }

  export type student_performanceCreateManyInput = {
    id?: number
    student_id?: number | null
    exam_id?: number | null
    marks_obtained: Decimal | DecimalJsLike | number | string
    total_marks: Decimal | DecimalJsLike | number | string
  }

  export type student_performanceUpdateManyMutationInput = {
    marks_obtained?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total_marks?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type student_performanceUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    student_id?: NullableIntFieldUpdateOperationsInput | number | null
    exam_id?: NullableIntFieldUpdateOperationsInput | number | null
    marks_obtained?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total_marks?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type student_routineCreateInput = {
    class: string
    section: string
    day: string
    teacher_name: string
    teacher_subject?: string | null
    time_slot: string
    teachers: teachersCreateNestedOneWithoutStudent_routineInput
  }

  export type student_routineUncheckedCreateInput = {
    id?: number
    class: string
    section: string
    day: string
    teacher_id: number
    teacher_name: string
    teacher_subject?: string | null
    time_slot: string
  }

  export type student_routineUpdateInput = {
    class?: StringFieldUpdateOperationsInput | string
    section?: StringFieldUpdateOperationsInput | string
    day?: StringFieldUpdateOperationsInput | string
    teacher_name?: StringFieldUpdateOperationsInput | string
    teacher_subject?: NullableStringFieldUpdateOperationsInput | string | null
    time_slot?: StringFieldUpdateOperationsInput | string
    teachers?: teachersUpdateOneRequiredWithoutStudent_routineNestedInput
  }

  export type student_routineUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    class?: StringFieldUpdateOperationsInput | string
    section?: StringFieldUpdateOperationsInput | string
    day?: StringFieldUpdateOperationsInput | string
    teacher_id?: IntFieldUpdateOperationsInput | number
    teacher_name?: StringFieldUpdateOperationsInput | string
    teacher_subject?: NullableStringFieldUpdateOperationsInput | string | null
    time_slot?: StringFieldUpdateOperationsInput | string
  }

  export type student_routineCreateManyInput = {
    id?: number
    class: string
    section: string
    day: string
    teacher_id: number
    teacher_name: string
    teacher_subject?: string | null
    time_slot: string
  }

  export type student_routineUpdateManyMutationInput = {
    class?: StringFieldUpdateOperationsInput | string
    section?: StringFieldUpdateOperationsInput | string
    day?: StringFieldUpdateOperationsInput | string
    teacher_name?: StringFieldUpdateOperationsInput | string
    teacher_subject?: NullableStringFieldUpdateOperationsInput | string | null
    time_slot?: StringFieldUpdateOperationsInput | string
  }

  export type student_routineUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    class?: StringFieldUpdateOperationsInput | string
    section?: StringFieldUpdateOperationsInput | string
    day?: StringFieldUpdateOperationsInput | string
    teacher_id?: IntFieldUpdateOperationsInput | number
    teacher_name?: StringFieldUpdateOperationsInput | string
    teacher_subject?: NullableStringFieldUpdateOperationsInput | string | null
    time_slot?: StringFieldUpdateOperationsInput | string
  }

  export type studentsCreateInput = {
    admission_number: string
    class: string
    section: string
    parent_name?: string | null
    parent_phone?: string | null
    parent_email?: string | null
    parent_work?: string | null
    parent_photo1?: string | null
    parent_photo2?: string | null
    guardian_photo?: string | null
    guardian_phone?: string | null
    roll_number?: number | null
    attendance?: attendanceCreateNestedManyWithoutStudentsInput
    class_representatives?: class_representativesCreateNestedManyWithoutStudentsInput
    class_teachers?: class_teachersCreateNestedManyWithoutStudentsInput
    finances?: financesCreateNestedManyWithoutStudentsInput
    student_performance?: student_performanceCreateNestedManyWithoutStudentsInput
    users?: usersCreateNestedOneWithoutStudentsInput
  }

  export type studentsUncheckedCreateInput = {
    id?: number
    user_id?: number | null
    admission_number: string
    class: string
    section: string
    parent_name?: string | null
    parent_phone?: string | null
    parent_email?: string | null
    parent_work?: string | null
    parent_photo1?: string | null
    parent_photo2?: string | null
    guardian_photo?: string | null
    guardian_phone?: string | null
    roll_number?: number | null
    attendance?: attendanceUncheckedCreateNestedManyWithoutStudentsInput
    class_representatives?: class_representativesUncheckedCreateNestedManyWithoutStudentsInput
    class_teachers?: class_teachersUncheckedCreateNestedManyWithoutStudentsInput
    finances?: financesUncheckedCreateNestedManyWithoutStudentsInput
    student_performance?: student_performanceUncheckedCreateNestedManyWithoutStudentsInput
  }

  export type studentsUpdateInput = {
    admission_number?: StringFieldUpdateOperationsInput | string
    class?: StringFieldUpdateOperationsInput | string
    section?: StringFieldUpdateOperationsInput | string
    parent_name?: NullableStringFieldUpdateOperationsInput | string | null
    parent_phone?: NullableStringFieldUpdateOperationsInput | string | null
    parent_email?: NullableStringFieldUpdateOperationsInput | string | null
    parent_work?: NullableStringFieldUpdateOperationsInput | string | null
    parent_photo1?: NullableStringFieldUpdateOperationsInput | string | null
    parent_photo2?: NullableStringFieldUpdateOperationsInput | string | null
    guardian_photo?: NullableStringFieldUpdateOperationsInput | string | null
    guardian_phone?: NullableStringFieldUpdateOperationsInput | string | null
    roll_number?: NullableIntFieldUpdateOperationsInput | number | null
    attendance?: attendanceUpdateManyWithoutStudentsNestedInput
    class_representatives?: class_representativesUpdateManyWithoutStudentsNestedInput
    class_teachers?: class_teachersUpdateManyWithoutStudentsNestedInput
    finances?: financesUpdateManyWithoutStudentsNestedInput
    student_performance?: student_performanceUpdateManyWithoutStudentsNestedInput
    users?: usersUpdateOneWithoutStudentsNestedInput
  }

  export type studentsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    admission_number?: StringFieldUpdateOperationsInput | string
    class?: StringFieldUpdateOperationsInput | string
    section?: StringFieldUpdateOperationsInput | string
    parent_name?: NullableStringFieldUpdateOperationsInput | string | null
    parent_phone?: NullableStringFieldUpdateOperationsInput | string | null
    parent_email?: NullableStringFieldUpdateOperationsInput | string | null
    parent_work?: NullableStringFieldUpdateOperationsInput | string | null
    parent_photo1?: NullableStringFieldUpdateOperationsInput | string | null
    parent_photo2?: NullableStringFieldUpdateOperationsInput | string | null
    guardian_photo?: NullableStringFieldUpdateOperationsInput | string | null
    guardian_phone?: NullableStringFieldUpdateOperationsInput | string | null
    roll_number?: NullableIntFieldUpdateOperationsInput | number | null
    attendance?: attendanceUncheckedUpdateManyWithoutStudentsNestedInput
    class_representatives?: class_representativesUncheckedUpdateManyWithoutStudentsNestedInput
    class_teachers?: class_teachersUncheckedUpdateManyWithoutStudentsNestedInput
    finances?: financesUncheckedUpdateManyWithoutStudentsNestedInput
    student_performance?: student_performanceUncheckedUpdateManyWithoutStudentsNestedInput
  }

  export type studentsCreateManyInput = {
    id?: number
    user_id?: number | null
    admission_number: string
    class: string
    section: string
    parent_name?: string | null
    parent_phone?: string | null
    parent_email?: string | null
    parent_work?: string | null
    parent_photo1?: string | null
    parent_photo2?: string | null
    guardian_photo?: string | null
    guardian_phone?: string | null
    roll_number?: number | null
  }

  export type studentsUpdateManyMutationInput = {
    admission_number?: StringFieldUpdateOperationsInput | string
    class?: StringFieldUpdateOperationsInput | string
    section?: StringFieldUpdateOperationsInput | string
    parent_name?: NullableStringFieldUpdateOperationsInput | string | null
    parent_phone?: NullableStringFieldUpdateOperationsInput | string | null
    parent_email?: NullableStringFieldUpdateOperationsInput | string | null
    parent_work?: NullableStringFieldUpdateOperationsInput | string | null
    parent_photo1?: NullableStringFieldUpdateOperationsInput | string | null
    parent_photo2?: NullableStringFieldUpdateOperationsInput | string | null
    guardian_photo?: NullableStringFieldUpdateOperationsInput | string | null
    guardian_phone?: NullableStringFieldUpdateOperationsInput | string | null
    roll_number?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type studentsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    admission_number?: StringFieldUpdateOperationsInput | string
    class?: StringFieldUpdateOperationsInput | string
    section?: StringFieldUpdateOperationsInput | string
    parent_name?: NullableStringFieldUpdateOperationsInput | string | null
    parent_phone?: NullableStringFieldUpdateOperationsInput | string | null
    parent_email?: NullableStringFieldUpdateOperationsInput | string | null
    parent_work?: NullableStringFieldUpdateOperationsInput | string | null
    parent_photo1?: NullableStringFieldUpdateOperationsInput | string | null
    parent_photo2?: NullableStringFieldUpdateOperationsInput | string | null
    guardian_photo?: NullableStringFieldUpdateOperationsInput | string | null
    guardian_phone?: NullableStringFieldUpdateOperationsInput | string | null
    roll_number?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type teacher_routineCreateInput = {
    day: string
    time_slot: string
    class: string
    section: string
    users: usersCreateNestedOneWithoutTeacher_routineInput
  }

  export type teacher_routineUncheckedCreateInput = {
    id?: number
    teacher_id: number
    day: string
    time_slot: string
    class: string
    section: string
  }

  export type teacher_routineUpdateInput = {
    day?: StringFieldUpdateOperationsInput | string
    time_slot?: StringFieldUpdateOperationsInput | string
    class?: StringFieldUpdateOperationsInput | string
    section?: StringFieldUpdateOperationsInput | string
    users?: usersUpdateOneRequiredWithoutTeacher_routineNestedInput
  }

  export type teacher_routineUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    teacher_id?: IntFieldUpdateOperationsInput | number
    day?: StringFieldUpdateOperationsInput | string
    time_slot?: StringFieldUpdateOperationsInput | string
    class?: StringFieldUpdateOperationsInput | string
    section?: StringFieldUpdateOperationsInput | string
  }

  export type teacher_routineCreateManyInput = {
    id?: number
    teacher_id: number
    day: string
    time_slot: string
    class: string
    section: string
  }

  export type teacher_routineUpdateManyMutationInput = {
    day?: StringFieldUpdateOperationsInput | string
    time_slot?: StringFieldUpdateOperationsInput | string
    class?: StringFieldUpdateOperationsInput | string
    section?: StringFieldUpdateOperationsInput | string
  }

  export type teacher_routineUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    teacher_id?: IntFieldUpdateOperationsInput | number
    day?: StringFieldUpdateOperationsInput | string
    time_slot?: StringFieldUpdateOperationsInput | string
    class?: StringFieldUpdateOperationsInput | string
    section?: StringFieldUpdateOperationsInput | string
  }

  export type teachersCreateInput = {
    specialised_subject: string
    assigned_class?: string | null
    assigned_section?: string | null
    assignments?: assignmentsCreateNestedManyWithoutTeachersInput
    attendance?: attendanceCreateNestedManyWithoutTeachersInput
    class_routine?: class_routineCreateNestedManyWithoutTeachersInput
    class_teachers?: class_teachersCreateNestedManyWithoutTeachersInput
    exams?: examsCreateNestedManyWithoutTeachersInput
    performance?: performanceCreateNestedManyWithoutTeachersInput
    student_routine?: student_routineCreateNestedManyWithoutTeachersInput
    users?: usersCreateNestedOneWithoutTeachersInput
  }

  export type teachersUncheckedCreateInput = {
    id?: number
    user_id?: number | null
    specialised_subject: string
    assigned_class?: string | null
    assigned_section?: string | null
    assignments?: assignmentsUncheckedCreateNestedManyWithoutTeachersInput
    attendance?: attendanceUncheckedCreateNestedManyWithoutTeachersInput
    class_routine?: class_routineUncheckedCreateNestedManyWithoutTeachersInput
    class_teachers?: class_teachersUncheckedCreateNestedManyWithoutTeachersInput
    exams?: examsUncheckedCreateNestedManyWithoutTeachersInput
    performance?: performanceUncheckedCreateNestedManyWithoutTeachersInput
    student_routine?: student_routineUncheckedCreateNestedManyWithoutTeachersInput
  }

  export type teachersUpdateInput = {
    specialised_subject?: StringFieldUpdateOperationsInput | string
    assigned_class?: NullableStringFieldUpdateOperationsInput | string | null
    assigned_section?: NullableStringFieldUpdateOperationsInput | string | null
    assignments?: assignmentsUpdateManyWithoutTeachersNestedInput
    attendance?: attendanceUpdateManyWithoutTeachersNestedInput
    class_routine?: class_routineUpdateManyWithoutTeachersNestedInput
    class_teachers?: class_teachersUpdateManyWithoutTeachersNestedInput
    exams?: examsUpdateManyWithoutTeachersNestedInput
    performance?: performanceUpdateManyWithoutTeachersNestedInput
    student_routine?: student_routineUpdateManyWithoutTeachersNestedInput
    users?: usersUpdateOneWithoutTeachersNestedInput
  }

  export type teachersUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    specialised_subject?: StringFieldUpdateOperationsInput | string
    assigned_class?: NullableStringFieldUpdateOperationsInput | string | null
    assigned_section?: NullableStringFieldUpdateOperationsInput | string | null
    assignments?: assignmentsUncheckedUpdateManyWithoutTeachersNestedInput
    attendance?: attendanceUncheckedUpdateManyWithoutTeachersNestedInput
    class_routine?: class_routineUncheckedUpdateManyWithoutTeachersNestedInput
    class_teachers?: class_teachersUncheckedUpdateManyWithoutTeachersNestedInput
    exams?: examsUncheckedUpdateManyWithoutTeachersNestedInput
    performance?: performanceUncheckedUpdateManyWithoutTeachersNestedInput
    student_routine?: student_routineUncheckedUpdateManyWithoutTeachersNestedInput
  }

  export type teachersCreateManyInput = {
    id?: number
    user_id?: number | null
    specialised_subject: string
    assigned_class?: string | null
    assigned_section?: string | null
  }

  export type teachersUpdateManyMutationInput = {
    specialised_subject?: StringFieldUpdateOperationsInput | string
    assigned_class?: NullableStringFieldUpdateOperationsInput | string | null
    assigned_section?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type teachersUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    specialised_subject?: StringFieldUpdateOperationsInput | string
    assigned_class?: NullableStringFieldUpdateOperationsInput | string | null
    assigned_section?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type upcoming_eventsCreateInput = {
    event_date: Date | string
    event_name: string
    holiday: boolean
    calendar?: calendarCreateNestedOneWithoutUpcoming_eventsInput
  }

  export type upcoming_eventsUncheckedCreateInput = {
    id?: number
    calendar_id?: number | null
    event_date: Date | string
    event_name: string
    holiday: boolean
  }

  export type upcoming_eventsUpdateInput = {
    event_date?: DateTimeFieldUpdateOperationsInput | Date | string
    event_name?: StringFieldUpdateOperationsInput | string
    holiday?: BoolFieldUpdateOperationsInput | boolean
    calendar?: calendarUpdateOneWithoutUpcoming_eventsNestedInput
  }

  export type upcoming_eventsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    calendar_id?: NullableIntFieldUpdateOperationsInput | number | null
    event_date?: DateTimeFieldUpdateOperationsInput | Date | string
    event_name?: StringFieldUpdateOperationsInput | string
    holiday?: BoolFieldUpdateOperationsInput | boolean
  }

  export type upcoming_eventsCreateManyInput = {
    id?: number
    calendar_id?: number | null
    event_date: Date | string
    event_name: string
    holiday: boolean
  }

  export type upcoming_eventsUpdateManyMutationInput = {
    event_date?: DateTimeFieldUpdateOperationsInput | Date | string
    event_name?: StringFieldUpdateOperationsInput | string
    holiday?: BoolFieldUpdateOperationsInput | boolean
  }

  export type upcoming_eventsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    calendar_id?: NullableIntFieldUpdateOperationsInput | number | null
    event_date?: DateTimeFieldUpdateOperationsInput | Date | string
    event_name?: StringFieldUpdateOperationsInput | string
    holiday?: BoolFieldUpdateOperationsInput | boolean
  }

  export type usersCreateInput = {
    name: string
    email: string
    password: string
    role: string
    phone?: string | null
    address?: string | null
    photo?: string | null
    notes?: notesCreateNestedManyWithoutUsersInput
    notices?: noticesCreateNestedManyWithoutUsersInput
    students?: studentsCreateNestedManyWithoutUsersInput
    teacher_routine?: teacher_routineCreateNestedManyWithoutUsersInput
    teachers?: teachersCreateNestedManyWithoutUsersInput
    workroom_messages_workroom_messages_receiver_idTousers?: workroom_messagesCreateNestedManyWithoutUsers_workroom_messages_receiver_idTousersInput
    workroom_messages_workroom_messages_sender_idTousers?: workroom_messagesCreateNestedManyWithoutUsers_workroom_messages_sender_idTousersInput
  }

  export type usersUncheckedCreateInput = {
    id?: number
    name: string
    email: string
    password: string
    role: string
    phone?: string | null
    address?: string | null
    photo?: string | null
    notes?: notesUncheckedCreateNestedManyWithoutUsersInput
    notices?: noticesUncheckedCreateNestedManyWithoutUsersInput
    students?: studentsUncheckedCreateNestedManyWithoutUsersInput
    teacher_routine?: teacher_routineUncheckedCreateNestedManyWithoutUsersInput
    teachers?: teachersUncheckedCreateNestedManyWithoutUsersInput
    workroom_messages_workroom_messages_receiver_idTousers?: workroom_messagesUncheckedCreateNestedManyWithoutUsers_workroom_messages_receiver_idTousersInput
    workroom_messages_workroom_messages_sender_idTousers?: workroom_messagesUncheckedCreateNestedManyWithoutUsers_workroom_messages_sender_idTousersInput
  }

  export type usersUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: notesUpdateManyWithoutUsersNestedInput
    notices?: noticesUpdateManyWithoutUsersNestedInput
    students?: studentsUpdateManyWithoutUsersNestedInput
    teacher_routine?: teacher_routineUpdateManyWithoutUsersNestedInput
    teachers?: teachersUpdateManyWithoutUsersNestedInput
    workroom_messages_workroom_messages_receiver_idTousers?: workroom_messagesUpdateManyWithoutUsers_workroom_messages_receiver_idTousersNestedInput
    workroom_messages_workroom_messages_sender_idTousers?: workroom_messagesUpdateManyWithoutUsers_workroom_messages_sender_idTousersNestedInput
  }

  export type usersUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: notesUncheckedUpdateManyWithoutUsersNestedInput
    notices?: noticesUncheckedUpdateManyWithoutUsersNestedInput
    students?: studentsUncheckedUpdateManyWithoutUsersNestedInput
    teacher_routine?: teacher_routineUncheckedUpdateManyWithoutUsersNestedInput
    teachers?: teachersUncheckedUpdateManyWithoutUsersNestedInput
    workroom_messages_workroom_messages_receiver_idTousers?: workroom_messagesUncheckedUpdateManyWithoutUsers_workroom_messages_receiver_idTousersNestedInput
    workroom_messages_workroom_messages_sender_idTousers?: workroom_messagesUncheckedUpdateManyWithoutUsers_workroom_messages_sender_idTousersNestedInput
  }

  export type usersCreateManyInput = {
    id?: number
    name: string
    email: string
    password: string
    role: string
    phone?: string | null
    address?: string | null
    photo?: string | null
  }

  export type usersUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type usersUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type workroom_messagesCreateInput = {
    message: string
    sent_at?: Date | string | null
    users_workroom_messages_receiver_idTousers?: usersCreateNestedOneWithoutWorkroom_messages_workroom_messages_receiver_idTousersInput
    users_workroom_messages_sender_idTousers?: usersCreateNestedOneWithoutWorkroom_messages_workroom_messages_sender_idTousersInput
  }

  export type workroom_messagesUncheckedCreateInput = {
    id?: number
    sender_id?: number | null
    receiver_id?: number | null
    message: string
    sent_at?: Date | string | null
  }

  export type workroom_messagesUpdateInput = {
    message?: StringFieldUpdateOperationsInput | string
    sent_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    users_workroom_messages_receiver_idTousers?: usersUpdateOneWithoutWorkroom_messages_workroom_messages_receiver_idTousersNestedInput
    users_workroom_messages_sender_idTousers?: usersUpdateOneWithoutWorkroom_messages_workroom_messages_sender_idTousersNestedInput
  }

  export type workroom_messagesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    sender_id?: NullableIntFieldUpdateOperationsInput | number | null
    receiver_id?: NullableIntFieldUpdateOperationsInput | number | null
    message?: StringFieldUpdateOperationsInput | string
    sent_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type workroom_messagesCreateManyInput = {
    id?: number
    sender_id?: number | null
    receiver_id?: number | null
    message: string
    sent_at?: Date | string | null
  }

  export type workroom_messagesUpdateManyMutationInput = {
    message?: StringFieldUpdateOperationsInput | string
    sent_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type workroom_messagesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    sender_id?: NullableIntFieldUpdateOperationsInput | number | null
    receiver_id?: NullableIntFieldUpdateOperationsInput | number | null
    message?: StringFieldUpdateOperationsInput | string
    sent_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type TeachersNullableScalarRelationFilter = {
    is?: teachersWhereInput | null
    isNot?: teachersWhereInput | null
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type assignmentsCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    subject?: SortOrder
    class?: SortOrder
    section?: SortOrder
    assigned_by?: SortOrder
    due_date?: SortOrder
    file?: SortOrder
  }

  export type assignmentsAvgOrderByAggregateInput = {
    id?: SortOrder
    assigned_by?: SortOrder
  }

  export type assignmentsMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    subject?: SortOrder
    class?: SortOrder
    section?: SortOrder
    assigned_by?: SortOrder
    due_date?: SortOrder
    file?: SortOrder
  }

  export type assignmentsMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    subject?: SortOrder
    class?: SortOrder
    section?: SortOrder
    assigned_by?: SortOrder
    due_date?: SortOrder
    file?: SortOrder
  }

  export type assignmentsSumOrderByAggregateInput = {
    id?: SortOrder
    assigned_by?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type StudentsScalarRelationFilter = {
    is?: studentsWhereInput
    isNot?: studentsWhereInput
  }

  export type TeachersScalarRelationFilter = {
    is?: teachersWhereInput
    isNot?: teachersWhereInput
  }

  export type attendanceStudent_idDateCompoundUniqueInput = {
    student_id: number
    date: Date | string
  }

  export type attendanceCountOrderByAggregateInput = {
    id?: SortOrder
    student_id?: SortOrder
    teacher_id?: SortOrder
    class?: SortOrder
    section?: SortOrder
    date?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
  }

  export type attendanceAvgOrderByAggregateInput = {
    id?: SortOrder
    student_id?: SortOrder
    teacher_id?: SortOrder
    class?: SortOrder
  }

  export type attendanceMaxOrderByAggregateInput = {
    id?: SortOrder
    student_id?: SortOrder
    teacher_id?: SortOrder
    class?: SortOrder
    section?: SortOrder
    date?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
  }

  export type attendanceMinOrderByAggregateInput = {
    id?: SortOrder
    student_id?: SortOrder
    teacher_id?: SortOrder
    class?: SortOrder
    section?: SortOrder
    date?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
  }

  export type attendanceSumOrderByAggregateInput = {
    id?: SortOrder
    student_id?: SortOrder
    teacher_id?: SortOrder
    class?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type Upcoming_eventsListRelationFilter = {
    every?: upcoming_eventsWhereInput
    some?: upcoming_eventsWhereInput
    none?: upcoming_eventsWhereInput
  }

  export type upcoming_eventsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type calendarCountOrderByAggregateInput = {
    id?: SortOrder
    month?: SortOrder
    calendar?: SortOrder
    year?: SortOrder
  }

  export type calendarAvgOrderByAggregateInput = {
    id?: SortOrder
    year?: SortOrder
  }

  export type calendarMaxOrderByAggregateInput = {
    id?: SortOrder
    month?: SortOrder
    calendar?: SortOrder
    year?: SortOrder
  }

  export type calendarMinOrderByAggregateInput = {
    id?: SortOrder
    month?: SortOrder
    calendar?: SortOrder
    year?: SortOrder
  }

  export type calendarSumOrderByAggregateInput = {
    id?: SortOrder
    year?: SortOrder
  }

  export type StudentsNullableScalarRelationFilter = {
    is?: studentsWhereInput | null
    isNot?: studentsWhereInput | null
  }

  export type class_representativesCountOrderByAggregateInput = {
    id?: SortOrder
    student_id?: SortOrder
    class?: SortOrder
    section?: SortOrder
  }

  export type class_representativesAvgOrderByAggregateInput = {
    id?: SortOrder
    student_id?: SortOrder
  }

  export type class_representativesMaxOrderByAggregateInput = {
    id?: SortOrder
    student_id?: SortOrder
    class?: SortOrder
    section?: SortOrder
  }

  export type class_representativesMinOrderByAggregateInput = {
    id?: SortOrder
    student_id?: SortOrder
    class?: SortOrder
    section?: SortOrder
  }

  export type class_representativesSumOrderByAggregateInput = {
    id?: SortOrder
    student_id?: SortOrder
  }

  export type class_routineCountOrderByAggregateInput = {
    id?: SortOrder
    class?: SortOrder
    section?: SortOrder
    day?: SortOrder
    period?: SortOrder
    subject?: SortOrder
    teacher_id?: SortOrder
  }

  export type class_routineAvgOrderByAggregateInput = {
    id?: SortOrder
    period?: SortOrder
    teacher_id?: SortOrder
  }

  export type class_routineMaxOrderByAggregateInput = {
    id?: SortOrder
    class?: SortOrder
    section?: SortOrder
    day?: SortOrder
    period?: SortOrder
    subject?: SortOrder
    teacher_id?: SortOrder
  }

  export type class_routineMinOrderByAggregateInput = {
    id?: SortOrder
    class?: SortOrder
    section?: SortOrder
    day?: SortOrder
    period?: SortOrder
    subject?: SortOrder
    teacher_id?: SortOrder
  }

  export type class_routineSumOrderByAggregateInput = {
    id?: SortOrder
    period?: SortOrder
    teacher_id?: SortOrder
  }

  export type class_teachersCountOrderByAggregateInput = {
    id?: SortOrder
    class?: SortOrder
    section?: SortOrder
    teacher_id?: SortOrder
    class_representative_student_id?: SortOrder
    second_class_representative_student_id?: SortOrder
  }

  export type class_teachersAvgOrderByAggregateInput = {
    id?: SortOrder
    teacher_id?: SortOrder
    class_representative_student_id?: SortOrder
    second_class_representative_student_id?: SortOrder
  }

  export type class_teachersMaxOrderByAggregateInput = {
    id?: SortOrder
    class?: SortOrder
    section?: SortOrder
    teacher_id?: SortOrder
    class_representative_student_id?: SortOrder
    second_class_representative_student_id?: SortOrder
  }

  export type class_teachersMinOrderByAggregateInput = {
    id?: SortOrder
    class?: SortOrder
    section?: SortOrder
    teacher_id?: SortOrder
    class_representative_student_id?: SortOrder
    second_class_representative_student_id?: SortOrder
  }

  export type class_teachersSumOrderByAggregateInput = {
    id?: SortOrder
    teacher_id?: SortOrder
    class_representative_student_id?: SortOrder
    second_class_representative_student_id?: SortOrder
  }

  export type PerformanceListRelationFilter = {
    every?: performanceWhereInput
    some?: performanceWhereInput
    none?: performanceWhereInput
  }

  export type Student_performanceListRelationFilter = {
    every?: student_performanceWhereInput
    some?: student_performanceWhereInput
    none?: student_performanceWhereInput
  }

  export type performanceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type student_performanceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type examsCountOrderByAggregateInput = {
    id?: SortOrder
    class?: SortOrder
    section?: SortOrder
    subject?: SortOrder
    exam_date?: SortOrder
    exam_duration?: SortOrder
    exam_type?: SortOrder
    created_by?: SortOrder
  }

  export type examsAvgOrderByAggregateInput = {
    id?: SortOrder
    created_by?: SortOrder
  }

  export type examsMaxOrderByAggregateInput = {
    id?: SortOrder
    class?: SortOrder
    section?: SortOrder
    subject?: SortOrder
    exam_date?: SortOrder
    exam_duration?: SortOrder
    exam_type?: SortOrder
    created_by?: SortOrder
  }

  export type examsMinOrderByAggregateInput = {
    id?: SortOrder
    class?: SortOrder
    section?: SortOrder
    subject?: SortOrder
    exam_date?: SortOrder
    exam_duration?: SortOrder
    exam_type?: SortOrder
    created_by?: SortOrder
  }

  export type examsSumOrderByAggregateInput = {
    id?: SortOrder
    created_by?: SortOrder
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type financecheckbookCountOrderByAggregateInput = {
    id?: SortOrder
    month?: SortOrder
    income?: SortOrder
    expenses?: SortOrder
    total_due_amount?: SortOrder
  }

  export type financecheckbookAvgOrderByAggregateInput = {
    id?: SortOrder
    income?: SortOrder
    expenses?: SortOrder
    total_due_amount?: SortOrder
  }

  export type financecheckbookMaxOrderByAggregateInput = {
    id?: SortOrder
    month?: SortOrder
    income?: SortOrder
    expenses?: SortOrder
    total_due_amount?: SortOrder
  }

  export type financecheckbookMinOrderByAggregateInput = {
    id?: SortOrder
    month?: SortOrder
    income?: SortOrder
    expenses?: SortOrder
    total_due_amount?: SortOrder
  }

  export type financecheckbookSumOrderByAggregateInput = {
    id?: SortOrder
    income?: SortOrder
    expenses?: SortOrder
    total_due_amount?: SortOrder
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type financesCountOrderByAggregateInput = {
    id?: SortOrder
    student_id?: SortOrder
    total_fee?: SortOrder
    paid_amount?: SortOrder
    due_amount?: SortOrder
    month?: SortOrder
    payment_status?: SortOrder
    penalty?: SortOrder
    expenses?: SortOrder
  }

  export type financesAvgOrderByAggregateInput = {
    id?: SortOrder
    student_id?: SortOrder
    total_fee?: SortOrder
    paid_amount?: SortOrder
    due_amount?: SortOrder
    penalty?: SortOrder
    expenses?: SortOrder
  }

  export type financesMaxOrderByAggregateInput = {
    id?: SortOrder
    student_id?: SortOrder
    total_fee?: SortOrder
    paid_amount?: SortOrder
    due_amount?: SortOrder
    month?: SortOrder
    payment_status?: SortOrder
    penalty?: SortOrder
    expenses?: SortOrder
  }

  export type financesMinOrderByAggregateInput = {
    id?: SortOrder
    student_id?: SortOrder
    total_fee?: SortOrder
    paid_amount?: SortOrder
    due_amount?: SortOrder
    month?: SortOrder
    payment_status?: SortOrder
    penalty?: SortOrder
    expenses?: SortOrder
  }

  export type financesSumOrderByAggregateInput = {
    id?: SortOrder
    student_id?: SortOrder
    total_fee?: SortOrder
    paid_amount?: SortOrder
    due_amount?: SortOrder
    penalty?: SortOrder
    expenses?: SortOrder
  }

  export type UsersNullableScalarRelationFilter = {
    is?: usersWhereInput | null
    isNot?: usersWhereInput | null
  }

  export type notesCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    subject?: SortOrder
    class?: SortOrder
    section?: SortOrder
    created_by?: SortOrder
    files?: SortOrder
    created_at?: SortOrder
  }

  export type notesAvgOrderByAggregateInput = {
    id?: SortOrder
    created_by?: SortOrder
  }

  export type notesMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    subject?: SortOrder
    class?: SortOrder
    section?: SortOrder
    created_by?: SortOrder
    files?: SortOrder
    created_at?: SortOrder
  }

  export type notesMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    subject?: SortOrder
    class?: SortOrder
    section?: SortOrder
    created_by?: SortOrder
    files?: SortOrder
    created_at?: SortOrder
  }

  export type notesSumOrderByAggregateInput = {
    id?: SortOrder
    created_by?: SortOrder
  }

  export type noticesCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    created_at?: SortOrder
    created_by?: SortOrder
    target_role?: SortOrder
  }

  export type noticesAvgOrderByAggregateInput = {
    id?: SortOrder
    created_by?: SortOrder
  }

  export type noticesMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    created_at?: SortOrder
    created_by?: SortOrder
    target_role?: SortOrder
  }

  export type noticesMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    created_at?: SortOrder
    created_by?: SortOrder
    target_role?: SortOrder
  }

  export type noticesSumOrderByAggregateInput = {
    id?: SortOrder
    created_by?: SortOrder
  }

  export type ExamsNullableScalarRelationFilter = {
    is?: examsWhereInput | null
    isNot?: examsWhereInput | null
  }

  export type Student_performanceNullableScalarRelationFilter = {
    is?: student_performanceWhereInput | null
    isNot?: student_performanceWhereInput | null
  }

  export type performanceCountOrderByAggregateInput = {
    id?: SortOrder
    class?: SortOrder
    section?: SortOrder
    class_teacher?: SortOrder
    class_performance?: SortOrder
    exam_id?: SortOrder
  }

  export type performanceAvgOrderByAggregateInput = {
    id?: SortOrder
    class_teacher?: SortOrder
    class_performance?: SortOrder
    exam_id?: SortOrder
  }

  export type performanceMaxOrderByAggregateInput = {
    id?: SortOrder
    class?: SortOrder
    section?: SortOrder
    class_teacher?: SortOrder
    class_performance?: SortOrder
    exam_id?: SortOrder
  }

  export type performanceMinOrderByAggregateInput = {
    id?: SortOrder
    class?: SortOrder
    section?: SortOrder
    class_teacher?: SortOrder
    class_performance?: SortOrder
    exam_id?: SortOrder
  }

  export type performanceSumOrderByAggregateInput = {
    id?: SortOrder
    class_teacher?: SortOrder
    class_performance?: SortOrder
    exam_id?: SortOrder
  }

  export type student_performanceCountOrderByAggregateInput = {
    id?: SortOrder
    student_id?: SortOrder
    exam_id?: SortOrder
    marks_obtained?: SortOrder
    total_marks?: SortOrder
  }

  export type student_performanceAvgOrderByAggregateInput = {
    id?: SortOrder
    student_id?: SortOrder
    exam_id?: SortOrder
    marks_obtained?: SortOrder
    total_marks?: SortOrder
  }

  export type student_performanceMaxOrderByAggregateInput = {
    id?: SortOrder
    student_id?: SortOrder
    exam_id?: SortOrder
    marks_obtained?: SortOrder
    total_marks?: SortOrder
  }

  export type student_performanceMinOrderByAggregateInput = {
    id?: SortOrder
    student_id?: SortOrder
    exam_id?: SortOrder
    marks_obtained?: SortOrder
    total_marks?: SortOrder
  }

  export type student_performanceSumOrderByAggregateInput = {
    id?: SortOrder
    student_id?: SortOrder
    exam_id?: SortOrder
    marks_obtained?: SortOrder
    total_marks?: SortOrder
  }

  export type student_routineCountOrderByAggregateInput = {
    id?: SortOrder
    class?: SortOrder
    section?: SortOrder
    day?: SortOrder
    teacher_id?: SortOrder
    teacher_name?: SortOrder
    teacher_subject?: SortOrder
    time_slot?: SortOrder
  }

  export type student_routineAvgOrderByAggregateInput = {
    id?: SortOrder
    teacher_id?: SortOrder
  }

  export type student_routineMaxOrderByAggregateInput = {
    id?: SortOrder
    class?: SortOrder
    section?: SortOrder
    day?: SortOrder
    teacher_id?: SortOrder
    teacher_name?: SortOrder
    teacher_subject?: SortOrder
    time_slot?: SortOrder
  }

  export type student_routineMinOrderByAggregateInput = {
    id?: SortOrder
    class?: SortOrder
    section?: SortOrder
    day?: SortOrder
    teacher_id?: SortOrder
    teacher_name?: SortOrder
    teacher_subject?: SortOrder
    time_slot?: SortOrder
  }

  export type student_routineSumOrderByAggregateInput = {
    id?: SortOrder
    teacher_id?: SortOrder
  }

  export type AttendanceListRelationFilter = {
    every?: attendanceWhereInput
    some?: attendanceWhereInput
    none?: attendanceWhereInput
  }

  export type Class_representativesListRelationFilter = {
    every?: class_representativesWhereInput
    some?: class_representativesWhereInput
    none?: class_representativesWhereInput
  }

  export type Class_teachersListRelationFilter = {
    every?: class_teachersWhereInput
    some?: class_teachersWhereInput
    none?: class_teachersWhereInput
  }

  export type FinancesListRelationFilter = {
    every?: financesWhereInput
    some?: financesWhereInput
    none?: financesWhereInput
  }

  export type attendanceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type class_representativesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type class_teachersOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type financesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type studentsCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    admission_number?: SortOrder
    class?: SortOrder
    section?: SortOrder
    parent_name?: SortOrder
    parent_phone?: SortOrder
    parent_email?: SortOrder
    parent_work?: SortOrder
    parent_photo1?: SortOrder
    parent_photo2?: SortOrder
    guardian_photo?: SortOrder
    guardian_phone?: SortOrder
    roll_number?: SortOrder
  }

  export type studentsAvgOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    roll_number?: SortOrder
  }

  export type studentsMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    admission_number?: SortOrder
    class?: SortOrder
    section?: SortOrder
    parent_name?: SortOrder
    parent_phone?: SortOrder
    parent_email?: SortOrder
    parent_work?: SortOrder
    parent_photo1?: SortOrder
    parent_photo2?: SortOrder
    guardian_photo?: SortOrder
    guardian_phone?: SortOrder
    roll_number?: SortOrder
  }

  export type studentsMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    admission_number?: SortOrder
    class?: SortOrder
    section?: SortOrder
    parent_name?: SortOrder
    parent_phone?: SortOrder
    parent_email?: SortOrder
    parent_work?: SortOrder
    parent_photo1?: SortOrder
    parent_photo2?: SortOrder
    guardian_photo?: SortOrder
    guardian_phone?: SortOrder
    roll_number?: SortOrder
  }

  export type studentsSumOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    roll_number?: SortOrder
  }

  export type UsersScalarRelationFilter = {
    is?: usersWhereInput
    isNot?: usersWhereInput
  }

  export type teacher_routineCountOrderByAggregateInput = {
    id?: SortOrder
    teacher_id?: SortOrder
    day?: SortOrder
    time_slot?: SortOrder
    class?: SortOrder
    section?: SortOrder
  }

  export type teacher_routineAvgOrderByAggregateInput = {
    id?: SortOrder
    teacher_id?: SortOrder
  }

  export type teacher_routineMaxOrderByAggregateInput = {
    id?: SortOrder
    teacher_id?: SortOrder
    day?: SortOrder
    time_slot?: SortOrder
    class?: SortOrder
    section?: SortOrder
  }

  export type teacher_routineMinOrderByAggregateInput = {
    id?: SortOrder
    teacher_id?: SortOrder
    day?: SortOrder
    time_slot?: SortOrder
    class?: SortOrder
    section?: SortOrder
  }

  export type teacher_routineSumOrderByAggregateInput = {
    id?: SortOrder
    teacher_id?: SortOrder
  }

  export type AssignmentsListRelationFilter = {
    every?: assignmentsWhereInput
    some?: assignmentsWhereInput
    none?: assignmentsWhereInput
  }

  export type Class_routineListRelationFilter = {
    every?: class_routineWhereInput
    some?: class_routineWhereInput
    none?: class_routineWhereInput
  }

  export type ExamsListRelationFilter = {
    every?: examsWhereInput
    some?: examsWhereInput
    none?: examsWhereInput
  }

  export type Student_routineListRelationFilter = {
    every?: student_routineWhereInput
    some?: student_routineWhereInput
    none?: student_routineWhereInput
  }

  export type assignmentsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type class_routineOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type examsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type student_routineOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type teachersCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    specialised_subject?: SortOrder
    assigned_class?: SortOrder
    assigned_section?: SortOrder
  }

  export type teachersAvgOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
  }

  export type teachersMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    specialised_subject?: SortOrder
    assigned_class?: SortOrder
    assigned_section?: SortOrder
  }

  export type teachersMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    specialised_subject?: SortOrder
    assigned_class?: SortOrder
    assigned_section?: SortOrder
  }

  export type teachersSumOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type CalendarNullableScalarRelationFilter = {
    is?: calendarWhereInput | null
    isNot?: calendarWhereInput | null
  }

  export type upcoming_eventsCountOrderByAggregateInput = {
    id?: SortOrder
    calendar_id?: SortOrder
    event_date?: SortOrder
    event_name?: SortOrder
    holiday?: SortOrder
  }

  export type upcoming_eventsAvgOrderByAggregateInput = {
    id?: SortOrder
    calendar_id?: SortOrder
  }

  export type upcoming_eventsMaxOrderByAggregateInput = {
    id?: SortOrder
    calendar_id?: SortOrder
    event_date?: SortOrder
    event_name?: SortOrder
    holiday?: SortOrder
  }

  export type upcoming_eventsMinOrderByAggregateInput = {
    id?: SortOrder
    calendar_id?: SortOrder
    event_date?: SortOrder
    event_name?: SortOrder
    holiday?: SortOrder
  }

  export type upcoming_eventsSumOrderByAggregateInput = {
    id?: SortOrder
    calendar_id?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NotesListRelationFilter = {
    every?: notesWhereInput
    some?: notesWhereInput
    none?: notesWhereInput
  }

  export type NoticesListRelationFilter = {
    every?: noticesWhereInput
    some?: noticesWhereInput
    none?: noticesWhereInput
  }

  export type StudentsListRelationFilter = {
    every?: studentsWhereInput
    some?: studentsWhereInput
    none?: studentsWhereInput
  }

  export type Teacher_routineListRelationFilter = {
    every?: teacher_routineWhereInput
    some?: teacher_routineWhereInput
    none?: teacher_routineWhereInput
  }

  export type TeachersListRelationFilter = {
    every?: teachersWhereInput
    some?: teachersWhereInput
    none?: teachersWhereInput
  }

  export type Workroom_messagesListRelationFilter = {
    every?: workroom_messagesWhereInput
    some?: workroom_messagesWhereInput
    none?: workroom_messagesWhereInput
  }

  export type notesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type noticesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type studentsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type teacher_routineOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type teachersOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type workroom_messagesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type usersCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    photo?: SortOrder
  }

  export type usersAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type usersMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    photo?: SortOrder
  }

  export type usersMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    photo?: SortOrder
  }

  export type usersSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type workroom_messagesCountOrderByAggregateInput = {
    id?: SortOrder
    sender_id?: SortOrder
    receiver_id?: SortOrder
    message?: SortOrder
    sent_at?: SortOrder
  }

  export type workroom_messagesAvgOrderByAggregateInput = {
    id?: SortOrder
    sender_id?: SortOrder
    receiver_id?: SortOrder
  }

  export type workroom_messagesMaxOrderByAggregateInput = {
    id?: SortOrder
    sender_id?: SortOrder
    receiver_id?: SortOrder
    message?: SortOrder
    sent_at?: SortOrder
  }

  export type workroom_messagesMinOrderByAggregateInput = {
    id?: SortOrder
    sender_id?: SortOrder
    receiver_id?: SortOrder
    message?: SortOrder
    sent_at?: SortOrder
  }

  export type workroom_messagesSumOrderByAggregateInput = {
    id?: SortOrder
    sender_id?: SortOrder
    receiver_id?: SortOrder
  }

  export type teachersCreateNestedOneWithoutAssignmentsInput = {
    create?: XOR<teachersCreateWithoutAssignmentsInput, teachersUncheckedCreateWithoutAssignmentsInput>
    connectOrCreate?: teachersCreateOrConnectWithoutAssignmentsInput
    connect?: teachersWhereUniqueInput
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type teachersUpdateOneWithoutAssignmentsNestedInput = {
    create?: XOR<teachersCreateWithoutAssignmentsInput, teachersUncheckedCreateWithoutAssignmentsInput>
    connectOrCreate?: teachersCreateOrConnectWithoutAssignmentsInput
    upsert?: teachersUpsertWithoutAssignmentsInput
    disconnect?: teachersWhereInput | boolean
    delete?: teachersWhereInput | boolean
    connect?: teachersWhereUniqueInput
    update?: XOR<XOR<teachersUpdateToOneWithWhereWithoutAssignmentsInput, teachersUpdateWithoutAssignmentsInput>, teachersUncheckedUpdateWithoutAssignmentsInput>
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type studentsCreateNestedOneWithoutAttendanceInput = {
    create?: XOR<studentsCreateWithoutAttendanceInput, studentsUncheckedCreateWithoutAttendanceInput>
    connectOrCreate?: studentsCreateOrConnectWithoutAttendanceInput
    connect?: studentsWhereUniqueInput
  }

  export type teachersCreateNestedOneWithoutAttendanceInput = {
    create?: XOR<teachersCreateWithoutAttendanceInput, teachersUncheckedCreateWithoutAttendanceInput>
    connectOrCreate?: teachersCreateOrConnectWithoutAttendanceInput
    connect?: teachersWhereUniqueInput
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type studentsUpdateOneRequiredWithoutAttendanceNestedInput = {
    create?: XOR<studentsCreateWithoutAttendanceInput, studentsUncheckedCreateWithoutAttendanceInput>
    connectOrCreate?: studentsCreateOrConnectWithoutAttendanceInput
    upsert?: studentsUpsertWithoutAttendanceInput
    connect?: studentsWhereUniqueInput
    update?: XOR<XOR<studentsUpdateToOneWithWhereWithoutAttendanceInput, studentsUpdateWithoutAttendanceInput>, studentsUncheckedUpdateWithoutAttendanceInput>
  }

  export type teachersUpdateOneRequiredWithoutAttendanceNestedInput = {
    create?: XOR<teachersCreateWithoutAttendanceInput, teachersUncheckedCreateWithoutAttendanceInput>
    connectOrCreate?: teachersCreateOrConnectWithoutAttendanceInput
    upsert?: teachersUpsertWithoutAttendanceInput
    connect?: teachersWhereUniqueInput
    update?: XOR<XOR<teachersUpdateToOneWithWhereWithoutAttendanceInput, teachersUpdateWithoutAttendanceInput>, teachersUncheckedUpdateWithoutAttendanceInput>
  }

  export type upcoming_eventsCreateNestedManyWithoutCalendarInput = {
    create?: XOR<upcoming_eventsCreateWithoutCalendarInput, upcoming_eventsUncheckedCreateWithoutCalendarInput> | upcoming_eventsCreateWithoutCalendarInput[] | upcoming_eventsUncheckedCreateWithoutCalendarInput[]
    connectOrCreate?: upcoming_eventsCreateOrConnectWithoutCalendarInput | upcoming_eventsCreateOrConnectWithoutCalendarInput[]
    createMany?: upcoming_eventsCreateManyCalendarInputEnvelope
    connect?: upcoming_eventsWhereUniqueInput | upcoming_eventsWhereUniqueInput[]
  }

  export type upcoming_eventsUncheckedCreateNestedManyWithoutCalendarInput = {
    create?: XOR<upcoming_eventsCreateWithoutCalendarInput, upcoming_eventsUncheckedCreateWithoutCalendarInput> | upcoming_eventsCreateWithoutCalendarInput[] | upcoming_eventsUncheckedCreateWithoutCalendarInput[]
    connectOrCreate?: upcoming_eventsCreateOrConnectWithoutCalendarInput | upcoming_eventsCreateOrConnectWithoutCalendarInput[]
    createMany?: upcoming_eventsCreateManyCalendarInputEnvelope
    connect?: upcoming_eventsWhereUniqueInput | upcoming_eventsWhereUniqueInput[]
  }

  export type upcoming_eventsUpdateManyWithoutCalendarNestedInput = {
    create?: XOR<upcoming_eventsCreateWithoutCalendarInput, upcoming_eventsUncheckedCreateWithoutCalendarInput> | upcoming_eventsCreateWithoutCalendarInput[] | upcoming_eventsUncheckedCreateWithoutCalendarInput[]
    connectOrCreate?: upcoming_eventsCreateOrConnectWithoutCalendarInput | upcoming_eventsCreateOrConnectWithoutCalendarInput[]
    upsert?: upcoming_eventsUpsertWithWhereUniqueWithoutCalendarInput | upcoming_eventsUpsertWithWhereUniqueWithoutCalendarInput[]
    createMany?: upcoming_eventsCreateManyCalendarInputEnvelope
    set?: upcoming_eventsWhereUniqueInput | upcoming_eventsWhereUniqueInput[]
    disconnect?: upcoming_eventsWhereUniqueInput | upcoming_eventsWhereUniqueInput[]
    delete?: upcoming_eventsWhereUniqueInput | upcoming_eventsWhereUniqueInput[]
    connect?: upcoming_eventsWhereUniqueInput | upcoming_eventsWhereUniqueInput[]
    update?: upcoming_eventsUpdateWithWhereUniqueWithoutCalendarInput | upcoming_eventsUpdateWithWhereUniqueWithoutCalendarInput[]
    updateMany?: upcoming_eventsUpdateManyWithWhereWithoutCalendarInput | upcoming_eventsUpdateManyWithWhereWithoutCalendarInput[]
    deleteMany?: upcoming_eventsScalarWhereInput | upcoming_eventsScalarWhereInput[]
  }

  export type upcoming_eventsUncheckedUpdateManyWithoutCalendarNestedInput = {
    create?: XOR<upcoming_eventsCreateWithoutCalendarInput, upcoming_eventsUncheckedCreateWithoutCalendarInput> | upcoming_eventsCreateWithoutCalendarInput[] | upcoming_eventsUncheckedCreateWithoutCalendarInput[]
    connectOrCreate?: upcoming_eventsCreateOrConnectWithoutCalendarInput | upcoming_eventsCreateOrConnectWithoutCalendarInput[]
    upsert?: upcoming_eventsUpsertWithWhereUniqueWithoutCalendarInput | upcoming_eventsUpsertWithWhereUniqueWithoutCalendarInput[]
    createMany?: upcoming_eventsCreateManyCalendarInputEnvelope
    set?: upcoming_eventsWhereUniqueInput | upcoming_eventsWhereUniqueInput[]
    disconnect?: upcoming_eventsWhereUniqueInput | upcoming_eventsWhereUniqueInput[]
    delete?: upcoming_eventsWhereUniqueInput | upcoming_eventsWhereUniqueInput[]
    connect?: upcoming_eventsWhereUniqueInput | upcoming_eventsWhereUniqueInput[]
    update?: upcoming_eventsUpdateWithWhereUniqueWithoutCalendarInput | upcoming_eventsUpdateWithWhereUniqueWithoutCalendarInput[]
    updateMany?: upcoming_eventsUpdateManyWithWhereWithoutCalendarInput | upcoming_eventsUpdateManyWithWhereWithoutCalendarInput[]
    deleteMany?: upcoming_eventsScalarWhereInput | upcoming_eventsScalarWhereInput[]
  }

  export type studentsCreateNestedOneWithoutClass_representativesInput = {
    create?: XOR<studentsCreateWithoutClass_representativesInput, studentsUncheckedCreateWithoutClass_representativesInput>
    connectOrCreate?: studentsCreateOrConnectWithoutClass_representativesInput
    connect?: studentsWhereUniqueInput
  }

  export type studentsUpdateOneWithoutClass_representativesNestedInput = {
    create?: XOR<studentsCreateWithoutClass_representativesInput, studentsUncheckedCreateWithoutClass_representativesInput>
    connectOrCreate?: studentsCreateOrConnectWithoutClass_representativesInput
    upsert?: studentsUpsertWithoutClass_representativesInput
    disconnect?: studentsWhereInput | boolean
    delete?: studentsWhereInput | boolean
    connect?: studentsWhereUniqueInput
    update?: XOR<XOR<studentsUpdateToOneWithWhereWithoutClass_representativesInput, studentsUpdateWithoutClass_representativesInput>, studentsUncheckedUpdateWithoutClass_representativesInput>
  }

  export type teachersCreateNestedOneWithoutClass_routineInput = {
    create?: XOR<teachersCreateWithoutClass_routineInput, teachersUncheckedCreateWithoutClass_routineInput>
    connectOrCreate?: teachersCreateOrConnectWithoutClass_routineInput
    connect?: teachersWhereUniqueInput
  }

  export type teachersUpdateOneWithoutClass_routineNestedInput = {
    create?: XOR<teachersCreateWithoutClass_routineInput, teachersUncheckedCreateWithoutClass_routineInput>
    connectOrCreate?: teachersCreateOrConnectWithoutClass_routineInput
    upsert?: teachersUpsertWithoutClass_routineInput
    disconnect?: teachersWhereInput | boolean
    delete?: teachersWhereInput | boolean
    connect?: teachersWhereUniqueInput
    update?: XOR<XOR<teachersUpdateToOneWithWhereWithoutClass_routineInput, teachersUpdateWithoutClass_routineInput>, teachersUncheckedUpdateWithoutClass_routineInput>
  }

  export type studentsCreateNestedOneWithoutClass_teachersInput = {
    create?: XOR<studentsCreateWithoutClass_teachersInput, studentsUncheckedCreateWithoutClass_teachersInput>
    connectOrCreate?: studentsCreateOrConnectWithoutClass_teachersInput
    connect?: studentsWhereUniqueInput
  }

  export type teachersCreateNestedOneWithoutClass_teachersInput = {
    create?: XOR<teachersCreateWithoutClass_teachersInput, teachersUncheckedCreateWithoutClass_teachersInput>
    connectOrCreate?: teachersCreateOrConnectWithoutClass_teachersInput
    connect?: teachersWhereUniqueInput
  }

  export type studentsUpdateOneWithoutClass_teachersNestedInput = {
    create?: XOR<studentsCreateWithoutClass_teachersInput, studentsUncheckedCreateWithoutClass_teachersInput>
    connectOrCreate?: studentsCreateOrConnectWithoutClass_teachersInput
    upsert?: studentsUpsertWithoutClass_teachersInput
    disconnect?: studentsWhereInput | boolean
    delete?: studentsWhereInput | boolean
    connect?: studentsWhereUniqueInput
    update?: XOR<XOR<studentsUpdateToOneWithWhereWithoutClass_teachersInput, studentsUpdateWithoutClass_teachersInput>, studentsUncheckedUpdateWithoutClass_teachersInput>
  }

  export type teachersUpdateOneRequiredWithoutClass_teachersNestedInput = {
    create?: XOR<teachersCreateWithoutClass_teachersInput, teachersUncheckedCreateWithoutClass_teachersInput>
    connectOrCreate?: teachersCreateOrConnectWithoutClass_teachersInput
    upsert?: teachersUpsertWithoutClass_teachersInput
    connect?: teachersWhereUniqueInput
    update?: XOR<XOR<teachersUpdateToOneWithWhereWithoutClass_teachersInput, teachersUpdateWithoutClass_teachersInput>, teachersUncheckedUpdateWithoutClass_teachersInput>
  }

  export type teachersCreateNestedOneWithoutExamsInput = {
    create?: XOR<teachersCreateWithoutExamsInput, teachersUncheckedCreateWithoutExamsInput>
    connectOrCreate?: teachersCreateOrConnectWithoutExamsInput
    connect?: teachersWhereUniqueInput
  }

  export type performanceCreateNestedManyWithoutExamsInput = {
    create?: XOR<performanceCreateWithoutExamsInput, performanceUncheckedCreateWithoutExamsInput> | performanceCreateWithoutExamsInput[] | performanceUncheckedCreateWithoutExamsInput[]
    connectOrCreate?: performanceCreateOrConnectWithoutExamsInput | performanceCreateOrConnectWithoutExamsInput[]
    createMany?: performanceCreateManyExamsInputEnvelope
    connect?: performanceWhereUniqueInput | performanceWhereUniqueInput[]
  }

  export type student_performanceCreateNestedManyWithoutExamsInput = {
    create?: XOR<student_performanceCreateWithoutExamsInput, student_performanceUncheckedCreateWithoutExamsInput> | student_performanceCreateWithoutExamsInput[] | student_performanceUncheckedCreateWithoutExamsInput[]
    connectOrCreate?: student_performanceCreateOrConnectWithoutExamsInput | student_performanceCreateOrConnectWithoutExamsInput[]
    createMany?: student_performanceCreateManyExamsInputEnvelope
    connect?: student_performanceWhereUniqueInput | student_performanceWhereUniqueInput[]
  }

  export type performanceUncheckedCreateNestedManyWithoutExamsInput = {
    create?: XOR<performanceCreateWithoutExamsInput, performanceUncheckedCreateWithoutExamsInput> | performanceCreateWithoutExamsInput[] | performanceUncheckedCreateWithoutExamsInput[]
    connectOrCreate?: performanceCreateOrConnectWithoutExamsInput | performanceCreateOrConnectWithoutExamsInput[]
    createMany?: performanceCreateManyExamsInputEnvelope
    connect?: performanceWhereUniqueInput | performanceWhereUniqueInput[]
  }

  export type student_performanceUncheckedCreateNestedManyWithoutExamsInput = {
    create?: XOR<student_performanceCreateWithoutExamsInput, student_performanceUncheckedCreateWithoutExamsInput> | student_performanceCreateWithoutExamsInput[] | student_performanceUncheckedCreateWithoutExamsInput[]
    connectOrCreate?: student_performanceCreateOrConnectWithoutExamsInput | student_performanceCreateOrConnectWithoutExamsInput[]
    createMany?: student_performanceCreateManyExamsInputEnvelope
    connect?: student_performanceWhereUniqueInput | student_performanceWhereUniqueInput[]
  }

  export type teachersUpdateOneWithoutExamsNestedInput = {
    create?: XOR<teachersCreateWithoutExamsInput, teachersUncheckedCreateWithoutExamsInput>
    connectOrCreate?: teachersCreateOrConnectWithoutExamsInput
    upsert?: teachersUpsertWithoutExamsInput
    disconnect?: teachersWhereInput | boolean
    delete?: teachersWhereInput | boolean
    connect?: teachersWhereUniqueInput
    update?: XOR<XOR<teachersUpdateToOneWithWhereWithoutExamsInput, teachersUpdateWithoutExamsInput>, teachersUncheckedUpdateWithoutExamsInput>
  }

  export type performanceUpdateManyWithoutExamsNestedInput = {
    create?: XOR<performanceCreateWithoutExamsInput, performanceUncheckedCreateWithoutExamsInput> | performanceCreateWithoutExamsInput[] | performanceUncheckedCreateWithoutExamsInput[]
    connectOrCreate?: performanceCreateOrConnectWithoutExamsInput | performanceCreateOrConnectWithoutExamsInput[]
    upsert?: performanceUpsertWithWhereUniqueWithoutExamsInput | performanceUpsertWithWhereUniqueWithoutExamsInput[]
    createMany?: performanceCreateManyExamsInputEnvelope
    set?: performanceWhereUniqueInput | performanceWhereUniqueInput[]
    disconnect?: performanceWhereUniqueInput | performanceWhereUniqueInput[]
    delete?: performanceWhereUniqueInput | performanceWhereUniqueInput[]
    connect?: performanceWhereUniqueInput | performanceWhereUniqueInput[]
    update?: performanceUpdateWithWhereUniqueWithoutExamsInput | performanceUpdateWithWhereUniqueWithoutExamsInput[]
    updateMany?: performanceUpdateManyWithWhereWithoutExamsInput | performanceUpdateManyWithWhereWithoutExamsInput[]
    deleteMany?: performanceScalarWhereInput | performanceScalarWhereInput[]
  }

  export type student_performanceUpdateManyWithoutExamsNestedInput = {
    create?: XOR<student_performanceCreateWithoutExamsInput, student_performanceUncheckedCreateWithoutExamsInput> | student_performanceCreateWithoutExamsInput[] | student_performanceUncheckedCreateWithoutExamsInput[]
    connectOrCreate?: student_performanceCreateOrConnectWithoutExamsInput | student_performanceCreateOrConnectWithoutExamsInput[]
    upsert?: student_performanceUpsertWithWhereUniqueWithoutExamsInput | student_performanceUpsertWithWhereUniqueWithoutExamsInput[]
    createMany?: student_performanceCreateManyExamsInputEnvelope
    set?: student_performanceWhereUniqueInput | student_performanceWhereUniqueInput[]
    disconnect?: student_performanceWhereUniqueInput | student_performanceWhereUniqueInput[]
    delete?: student_performanceWhereUniqueInput | student_performanceWhereUniqueInput[]
    connect?: student_performanceWhereUniqueInput | student_performanceWhereUniqueInput[]
    update?: student_performanceUpdateWithWhereUniqueWithoutExamsInput | student_performanceUpdateWithWhereUniqueWithoutExamsInput[]
    updateMany?: student_performanceUpdateManyWithWhereWithoutExamsInput | student_performanceUpdateManyWithWhereWithoutExamsInput[]
    deleteMany?: student_performanceScalarWhereInput | student_performanceScalarWhereInput[]
  }

  export type performanceUncheckedUpdateManyWithoutExamsNestedInput = {
    create?: XOR<performanceCreateWithoutExamsInput, performanceUncheckedCreateWithoutExamsInput> | performanceCreateWithoutExamsInput[] | performanceUncheckedCreateWithoutExamsInput[]
    connectOrCreate?: performanceCreateOrConnectWithoutExamsInput | performanceCreateOrConnectWithoutExamsInput[]
    upsert?: performanceUpsertWithWhereUniqueWithoutExamsInput | performanceUpsertWithWhereUniqueWithoutExamsInput[]
    createMany?: performanceCreateManyExamsInputEnvelope
    set?: performanceWhereUniqueInput | performanceWhereUniqueInput[]
    disconnect?: performanceWhereUniqueInput | performanceWhereUniqueInput[]
    delete?: performanceWhereUniqueInput | performanceWhereUniqueInput[]
    connect?: performanceWhereUniqueInput | performanceWhereUniqueInput[]
    update?: performanceUpdateWithWhereUniqueWithoutExamsInput | performanceUpdateWithWhereUniqueWithoutExamsInput[]
    updateMany?: performanceUpdateManyWithWhereWithoutExamsInput | performanceUpdateManyWithWhereWithoutExamsInput[]
    deleteMany?: performanceScalarWhereInput | performanceScalarWhereInput[]
  }

  export type student_performanceUncheckedUpdateManyWithoutExamsNestedInput = {
    create?: XOR<student_performanceCreateWithoutExamsInput, student_performanceUncheckedCreateWithoutExamsInput> | student_performanceCreateWithoutExamsInput[] | student_performanceUncheckedCreateWithoutExamsInput[]
    connectOrCreate?: student_performanceCreateOrConnectWithoutExamsInput | student_performanceCreateOrConnectWithoutExamsInput[]
    upsert?: student_performanceUpsertWithWhereUniqueWithoutExamsInput | student_performanceUpsertWithWhereUniqueWithoutExamsInput[]
    createMany?: student_performanceCreateManyExamsInputEnvelope
    set?: student_performanceWhereUniqueInput | student_performanceWhereUniqueInput[]
    disconnect?: student_performanceWhereUniqueInput | student_performanceWhereUniqueInput[]
    delete?: student_performanceWhereUniqueInput | student_performanceWhereUniqueInput[]
    connect?: student_performanceWhereUniqueInput | student_performanceWhereUniqueInput[]
    update?: student_performanceUpdateWithWhereUniqueWithoutExamsInput | student_performanceUpdateWithWhereUniqueWithoutExamsInput[]
    updateMany?: student_performanceUpdateManyWithWhereWithoutExamsInput | student_performanceUpdateManyWithWhereWithoutExamsInput[]
    deleteMany?: student_performanceScalarWhereInput | student_performanceScalarWhereInput[]
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type studentsCreateNestedOneWithoutFinancesInput = {
    create?: XOR<studentsCreateWithoutFinancesInput, studentsUncheckedCreateWithoutFinancesInput>
    connectOrCreate?: studentsCreateOrConnectWithoutFinancesInput
    connect?: studentsWhereUniqueInput
  }

  export type studentsUpdateOneWithoutFinancesNestedInput = {
    create?: XOR<studentsCreateWithoutFinancesInput, studentsUncheckedCreateWithoutFinancesInput>
    connectOrCreate?: studentsCreateOrConnectWithoutFinancesInput
    upsert?: studentsUpsertWithoutFinancesInput
    disconnect?: studentsWhereInput | boolean
    delete?: studentsWhereInput | boolean
    connect?: studentsWhereUniqueInput
    update?: XOR<XOR<studentsUpdateToOneWithWhereWithoutFinancesInput, studentsUpdateWithoutFinancesInput>, studentsUncheckedUpdateWithoutFinancesInput>
  }

  export type usersCreateNestedOneWithoutNotesInput = {
    create?: XOR<usersCreateWithoutNotesInput, usersUncheckedCreateWithoutNotesInput>
    connectOrCreate?: usersCreateOrConnectWithoutNotesInput
    connect?: usersWhereUniqueInput
  }

  export type usersUpdateOneWithoutNotesNestedInput = {
    create?: XOR<usersCreateWithoutNotesInput, usersUncheckedCreateWithoutNotesInput>
    connectOrCreate?: usersCreateOrConnectWithoutNotesInput
    upsert?: usersUpsertWithoutNotesInput
    disconnect?: usersWhereInput | boolean
    delete?: usersWhereInput | boolean
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutNotesInput, usersUpdateWithoutNotesInput>, usersUncheckedUpdateWithoutNotesInput>
  }

  export type usersCreateNestedOneWithoutNoticesInput = {
    create?: XOR<usersCreateWithoutNoticesInput, usersUncheckedCreateWithoutNoticesInput>
    connectOrCreate?: usersCreateOrConnectWithoutNoticesInput
    connect?: usersWhereUniqueInput
  }

  export type usersUpdateOneWithoutNoticesNestedInput = {
    create?: XOR<usersCreateWithoutNoticesInput, usersUncheckedCreateWithoutNoticesInput>
    connectOrCreate?: usersCreateOrConnectWithoutNoticesInput
    upsert?: usersUpsertWithoutNoticesInput
    disconnect?: usersWhereInput | boolean
    delete?: usersWhereInput | boolean
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutNoticesInput, usersUpdateWithoutNoticesInput>, usersUncheckedUpdateWithoutNoticesInput>
  }

  export type examsCreateNestedOneWithoutPerformanceInput = {
    create?: XOR<examsCreateWithoutPerformanceInput, examsUncheckedCreateWithoutPerformanceInput>
    connectOrCreate?: examsCreateOrConnectWithoutPerformanceInput
    connect?: examsWhereUniqueInput
  }

  export type student_performanceCreateNestedOneWithoutPerformanceInput = {
    create?: XOR<student_performanceCreateWithoutPerformanceInput, student_performanceUncheckedCreateWithoutPerformanceInput>
    connectOrCreate?: student_performanceCreateOrConnectWithoutPerformanceInput
    connect?: student_performanceWhereUniqueInput
  }

  export type teachersCreateNestedOneWithoutPerformanceInput = {
    create?: XOR<teachersCreateWithoutPerformanceInput, teachersUncheckedCreateWithoutPerformanceInput>
    connectOrCreate?: teachersCreateOrConnectWithoutPerformanceInput
    connect?: teachersWhereUniqueInput
  }

  export type examsUpdateOneWithoutPerformanceNestedInput = {
    create?: XOR<examsCreateWithoutPerformanceInput, examsUncheckedCreateWithoutPerformanceInput>
    connectOrCreate?: examsCreateOrConnectWithoutPerformanceInput
    upsert?: examsUpsertWithoutPerformanceInput
    disconnect?: examsWhereInput | boolean
    delete?: examsWhereInput | boolean
    connect?: examsWhereUniqueInput
    update?: XOR<XOR<examsUpdateToOneWithWhereWithoutPerformanceInput, examsUpdateWithoutPerformanceInput>, examsUncheckedUpdateWithoutPerformanceInput>
  }

  export type student_performanceUpdateOneWithoutPerformanceNestedInput = {
    create?: XOR<student_performanceCreateWithoutPerformanceInput, student_performanceUncheckedCreateWithoutPerformanceInput>
    connectOrCreate?: student_performanceCreateOrConnectWithoutPerformanceInput
    upsert?: student_performanceUpsertWithoutPerformanceInput
    disconnect?: student_performanceWhereInput | boolean
    delete?: student_performanceWhereInput | boolean
    connect?: student_performanceWhereUniqueInput
    update?: XOR<XOR<student_performanceUpdateToOneWithWhereWithoutPerformanceInput, student_performanceUpdateWithoutPerformanceInput>, student_performanceUncheckedUpdateWithoutPerformanceInput>
  }

  export type teachersUpdateOneWithoutPerformanceNestedInput = {
    create?: XOR<teachersCreateWithoutPerformanceInput, teachersUncheckedCreateWithoutPerformanceInput>
    connectOrCreate?: teachersCreateOrConnectWithoutPerformanceInput
    upsert?: teachersUpsertWithoutPerformanceInput
    disconnect?: teachersWhereInput | boolean
    delete?: teachersWhereInput | boolean
    connect?: teachersWhereUniqueInput
    update?: XOR<XOR<teachersUpdateToOneWithWhereWithoutPerformanceInput, teachersUpdateWithoutPerformanceInput>, teachersUncheckedUpdateWithoutPerformanceInput>
  }

  export type performanceCreateNestedManyWithoutStudent_performanceInput = {
    create?: XOR<performanceCreateWithoutStudent_performanceInput, performanceUncheckedCreateWithoutStudent_performanceInput> | performanceCreateWithoutStudent_performanceInput[] | performanceUncheckedCreateWithoutStudent_performanceInput[]
    connectOrCreate?: performanceCreateOrConnectWithoutStudent_performanceInput | performanceCreateOrConnectWithoutStudent_performanceInput[]
    createMany?: performanceCreateManyStudent_performanceInputEnvelope
    connect?: performanceWhereUniqueInput | performanceWhereUniqueInput[]
  }

  export type examsCreateNestedOneWithoutStudent_performanceInput = {
    create?: XOR<examsCreateWithoutStudent_performanceInput, examsUncheckedCreateWithoutStudent_performanceInput>
    connectOrCreate?: examsCreateOrConnectWithoutStudent_performanceInput
    connect?: examsWhereUniqueInput
  }

  export type studentsCreateNestedOneWithoutStudent_performanceInput = {
    create?: XOR<studentsCreateWithoutStudent_performanceInput, studentsUncheckedCreateWithoutStudent_performanceInput>
    connectOrCreate?: studentsCreateOrConnectWithoutStudent_performanceInput
    connect?: studentsWhereUniqueInput
  }

  export type performanceUncheckedCreateNestedManyWithoutStudent_performanceInput = {
    create?: XOR<performanceCreateWithoutStudent_performanceInput, performanceUncheckedCreateWithoutStudent_performanceInput> | performanceCreateWithoutStudent_performanceInput[] | performanceUncheckedCreateWithoutStudent_performanceInput[]
    connectOrCreate?: performanceCreateOrConnectWithoutStudent_performanceInput | performanceCreateOrConnectWithoutStudent_performanceInput[]
    createMany?: performanceCreateManyStudent_performanceInputEnvelope
    connect?: performanceWhereUniqueInput | performanceWhereUniqueInput[]
  }

  export type performanceUpdateManyWithoutStudent_performanceNestedInput = {
    create?: XOR<performanceCreateWithoutStudent_performanceInput, performanceUncheckedCreateWithoutStudent_performanceInput> | performanceCreateWithoutStudent_performanceInput[] | performanceUncheckedCreateWithoutStudent_performanceInput[]
    connectOrCreate?: performanceCreateOrConnectWithoutStudent_performanceInput | performanceCreateOrConnectWithoutStudent_performanceInput[]
    upsert?: performanceUpsertWithWhereUniqueWithoutStudent_performanceInput | performanceUpsertWithWhereUniqueWithoutStudent_performanceInput[]
    createMany?: performanceCreateManyStudent_performanceInputEnvelope
    set?: performanceWhereUniqueInput | performanceWhereUniqueInput[]
    disconnect?: performanceWhereUniqueInput | performanceWhereUniqueInput[]
    delete?: performanceWhereUniqueInput | performanceWhereUniqueInput[]
    connect?: performanceWhereUniqueInput | performanceWhereUniqueInput[]
    update?: performanceUpdateWithWhereUniqueWithoutStudent_performanceInput | performanceUpdateWithWhereUniqueWithoutStudent_performanceInput[]
    updateMany?: performanceUpdateManyWithWhereWithoutStudent_performanceInput | performanceUpdateManyWithWhereWithoutStudent_performanceInput[]
    deleteMany?: performanceScalarWhereInput | performanceScalarWhereInput[]
  }

  export type examsUpdateOneWithoutStudent_performanceNestedInput = {
    create?: XOR<examsCreateWithoutStudent_performanceInput, examsUncheckedCreateWithoutStudent_performanceInput>
    connectOrCreate?: examsCreateOrConnectWithoutStudent_performanceInput
    upsert?: examsUpsertWithoutStudent_performanceInput
    disconnect?: examsWhereInput | boolean
    delete?: examsWhereInput | boolean
    connect?: examsWhereUniqueInput
    update?: XOR<XOR<examsUpdateToOneWithWhereWithoutStudent_performanceInput, examsUpdateWithoutStudent_performanceInput>, examsUncheckedUpdateWithoutStudent_performanceInput>
  }

  export type studentsUpdateOneWithoutStudent_performanceNestedInput = {
    create?: XOR<studentsCreateWithoutStudent_performanceInput, studentsUncheckedCreateWithoutStudent_performanceInput>
    connectOrCreate?: studentsCreateOrConnectWithoutStudent_performanceInput
    upsert?: studentsUpsertWithoutStudent_performanceInput
    disconnect?: studentsWhereInput | boolean
    delete?: studentsWhereInput | boolean
    connect?: studentsWhereUniqueInput
    update?: XOR<XOR<studentsUpdateToOneWithWhereWithoutStudent_performanceInput, studentsUpdateWithoutStudent_performanceInput>, studentsUncheckedUpdateWithoutStudent_performanceInput>
  }

  export type performanceUncheckedUpdateManyWithoutStudent_performanceNestedInput = {
    create?: XOR<performanceCreateWithoutStudent_performanceInput, performanceUncheckedCreateWithoutStudent_performanceInput> | performanceCreateWithoutStudent_performanceInput[] | performanceUncheckedCreateWithoutStudent_performanceInput[]
    connectOrCreate?: performanceCreateOrConnectWithoutStudent_performanceInput | performanceCreateOrConnectWithoutStudent_performanceInput[]
    upsert?: performanceUpsertWithWhereUniqueWithoutStudent_performanceInput | performanceUpsertWithWhereUniqueWithoutStudent_performanceInput[]
    createMany?: performanceCreateManyStudent_performanceInputEnvelope
    set?: performanceWhereUniqueInput | performanceWhereUniqueInput[]
    disconnect?: performanceWhereUniqueInput | performanceWhereUniqueInput[]
    delete?: performanceWhereUniqueInput | performanceWhereUniqueInput[]
    connect?: performanceWhereUniqueInput | performanceWhereUniqueInput[]
    update?: performanceUpdateWithWhereUniqueWithoutStudent_performanceInput | performanceUpdateWithWhereUniqueWithoutStudent_performanceInput[]
    updateMany?: performanceUpdateManyWithWhereWithoutStudent_performanceInput | performanceUpdateManyWithWhereWithoutStudent_performanceInput[]
    deleteMany?: performanceScalarWhereInput | performanceScalarWhereInput[]
  }

  export type teachersCreateNestedOneWithoutStudent_routineInput = {
    create?: XOR<teachersCreateWithoutStudent_routineInput, teachersUncheckedCreateWithoutStudent_routineInput>
    connectOrCreate?: teachersCreateOrConnectWithoutStudent_routineInput
    connect?: teachersWhereUniqueInput
  }

  export type teachersUpdateOneRequiredWithoutStudent_routineNestedInput = {
    create?: XOR<teachersCreateWithoutStudent_routineInput, teachersUncheckedCreateWithoutStudent_routineInput>
    connectOrCreate?: teachersCreateOrConnectWithoutStudent_routineInput
    upsert?: teachersUpsertWithoutStudent_routineInput
    connect?: teachersWhereUniqueInput
    update?: XOR<XOR<teachersUpdateToOneWithWhereWithoutStudent_routineInput, teachersUpdateWithoutStudent_routineInput>, teachersUncheckedUpdateWithoutStudent_routineInput>
  }

  export type attendanceCreateNestedManyWithoutStudentsInput = {
    create?: XOR<attendanceCreateWithoutStudentsInput, attendanceUncheckedCreateWithoutStudentsInput> | attendanceCreateWithoutStudentsInput[] | attendanceUncheckedCreateWithoutStudentsInput[]
    connectOrCreate?: attendanceCreateOrConnectWithoutStudentsInput | attendanceCreateOrConnectWithoutStudentsInput[]
    createMany?: attendanceCreateManyStudentsInputEnvelope
    connect?: attendanceWhereUniqueInput | attendanceWhereUniqueInput[]
  }

  export type class_representativesCreateNestedManyWithoutStudentsInput = {
    create?: XOR<class_representativesCreateWithoutStudentsInput, class_representativesUncheckedCreateWithoutStudentsInput> | class_representativesCreateWithoutStudentsInput[] | class_representativesUncheckedCreateWithoutStudentsInput[]
    connectOrCreate?: class_representativesCreateOrConnectWithoutStudentsInput | class_representativesCreateOrConnectWithoutStudentsInput[]
    createMany?: class_representativesCreateManyStudentsInputEnvelope
    connect?: class_representativesWhereUniqueInput | class_representativesWhereUniqueInput[]
  }

  export type class_teachersCreateNestedManyWithoutStudentsInput = {
    create?: XOR<class_teachersCreateWithoutStudentsInput, class_teachersUncheckedCreateWithoutStudentsInput> | class_teachersCreateWithoutStudentsInput[] | class_teachersUncheckedCreateWithoutStudentsInput[]
    connectOrCreate?: class_teachersCreateOrConnectWithoutStudentsInput | class_teachersCreateOrConnectWithoutStudentsInput[]
    createMany?: class_teachersCreateManyStudentsInputEnvelope
    connect?: class_teachersWhereUniqueInput | class_teachersWhereUniqueInput[]
  }

  export type financesCreateNestedManyWithoutStudentsInput = {
    create?: XOR<financesCreateWithoutStudentsInput, financesUncheckedCreateWithoutStudentsInput> | financesCreateWithoutStudentsInput[] | financesUncheckedCreateWithoutStudentsInput[]
    connectOrCreate?: financesCreateOrConnectWithoutStudentsInput | financesCreateOrConnectWithoutStudentsInput[]
    createMany?: financesCreateManyStudentsInputEnvelope
    connect?: financesWhereUniqueInput | financesWhereUniqueInput[]
  }

  export type student_performanceCreateNestedManyWithoutStudentsInput = {
    create?: XOR<student_performanceCreateWithoutStudentsInput, student_performanceUncheckedCreateWithoutStudentsInput> | student_performanceCreateWithoutStudentsInput[] | student_performanceUncheckedCreateWithoutStudentsInput[]
    connectOrCreate?: student_performanceCreateOrConnectWithoutStudentsInput | student_performanceCreateOrConnectWithoutStudentsInput[]
    createMany?: student_performanceCreateManyStudentsInputEnvelope
    connect?: student_performanceWhereUniqueInput | student_performanceWhereUniqueInput[]
  }

  export type usersCreateNestedOneWithoutStudentsInput = {
    create?: XOR<usersCreateWithoutStudentsInput, usersUncheckedCreateWithoutStudentsInput>
    connectOrCreate?: usersCreateOrConnectWithoutStudentsInput
    connect?: usersWhereUniqueInput
  }

  export type attendanceUncheckedCreateNestedManyWithoutStudentsInput = {
    create?: XOR<attendanceCreateWithoutStudentsInput, attendanceUncheckedCreateWithoutStudentsInput> | attendanceCreateWithoutStudentsInput[] | attendanceUncheckedCreateWithoutStudentsInput[]
    connectOrCreate?: attendanceCreateOrConnectWithoutStudentsInput | attendanceCreateOrConnectWithoutStudentsInput[]
    createMany?: attendanceCreateManyStudentsInputEnvelope
    connect?: attendanceWhereUniqueInput | attendanceWhereUniqueInput[]
  }

  export type class_representativesUncheckedCreateNestedManyWithoutStudentsInput = {
    create?: XOR<class_representativesCreateWithoutStudentsInput, class_representativesUncheckedCreateWithoutStudentsInput> | class_representativesCreateWithoutStudentsInput[] | class_representativesUncheckedCreateWithoutStudentsInput[]
    connectOrCreate?: class_representativesCreateOrConnectWithoutStudentsInput | class_representativesCreateOrConnectWithoutStudentsInput[]
    createMany?: class_representativesCreateManyStudentsInputEnvelope
    connect?: class_representativesWhereUniqueInput | class_representativesWhereUniqueInput[]
  }

  export type class_teachersUncheckedCreateNestedManyWithoutStudentsInput = {
    create?: XOR<class_teachersCreateWithoutStudentsInput, class_teachersUncheckedCreateWithoutStudentsInput> | class_teachersCreateWithoutStudentsInput[] | class_teachersUncheckedCreateWithoutStudentsInput[]
    connectOrCreate?: class_teachersCreateOrConnectWithoutStudentsInput | class_teachersCreateOrConnectWithoutStudentsInput[]
    createMany?: class_teachersCreateManyStudentsInputEnvelope
    connect?: class_teachersWhereUniqueInput | class_teachersWhereUniqueInput[]
  }

  export type financesUncheckedCreateNestedManyWithoutStudentsInput = {
    create?: XOR<financesCreateWithoutStudentsInput, financesUncheckedCreateWithoutStudentsInput> | financesCreateWithoutStudentsInput[] | financesUncheckedCreateWithoutStudentsInput[]
    connectOrCreate?: financesCreateOrConnectWithoutStudentsInput | financesCreateOrConnectWithoutStudentsInput[]
    createMany?: financesCreateManyStudentsInputEnvelope
    connect?: financesWhereUniqueInput | financesWhereUniqueInput[]
  }

  export type student_performanceUncheckedCreateNestedManyWithoutStudentsInput = {
    create?: XOR<student_performanceCreateWithoutStudentsInput, student_performanceUncheckedCreateWithoutStudentsInput> | student_performanceCreateWithoutStudentsInput[] | student_performanceUncheckedCreateWithoutStudentsInput[]
    connectOrCreate?: student_performanceCreateOrConnectWithoutStudentsInput | student_performanceCreateOrConnectWithoutStudentsInput[]
    createMany?: student_performanceCreateManyStudentsInputEnvelope
    connect?: student_performanceWhereUniqueInput | student_performanceWhereUniqueInput[]
  }

  export type attendanceUpdateManyWithoutStudentsNestedInput = {
    create?: XOR<attendanceCreateWithoutStudentsInput, attendanceUncheckedCreateWithoutStudentsInput> | attendanceCreateWithoutStudentsInput[] | attendanceUncheckedCreateWithoutStudentsInput[]
    connectOrCreate?: attendanceCreateOrConnectWithoutStudentsInput | attendanceCreateOrConnectWithoutStudentsInput[]
    upsert?: attendanceUpsertWithWhereUniqueWithoutStudentsInput | attendanceUpsertWithWhereUniqueWithoutStudentsInput[]
    createMany?: attendanceCreateManyStudentsInputEnvelope
    set?: attendanceWhereUniqueInput | attendanceWhereUniqueInput[]
    disconnect?: attendanceWhereUniqueInput | attendanceWhereUniqueInput[]
    delete?: attendanceWhereUniqueInput | attendanceWhereUniqueInput[]
    connect?: attendanceWhereUniqueInput | attendanceWhereUniqueInput[]
    update?: attendanceUpdateWithWhereUniqueWithoutStudentsInput | attendanceUpdateWithWhereUniqueWithoutStudentsInput[]
    updateMany?: attendanceUpdateManyWithWhereWithoutStudentsInput | attendanceUpdateManyWithWhereWithoutStudentsInput[]
    deleteMany?: attendanceScalarWhereInput | attendanceScalarWhereInput[]
  }

  export type class_representativesUpdateManyWithoutStudentsNestedInput = {
    create?: XOR<class_representativesCreateWithoutStudentsInput, class_representativesUncheckedCreateWithoutStudentsInput> | class_representativesCreateWithoutStudentsInput[] | class_representativesUncheckedCreateWithoutStudentsInput[]
    connectOrCreate?: class_representativesCreateOrConnectWithoutStudentsInput | class_representativesCreateOrConnectWithoutStudentsInput[]
    upsert?: class_representativesUpsertWithWhereUniqueWithoutStudentsInput | class_representativesUpsertWithWhereUniqueWithoutStudentsInput[]
    createMany?: class_representativesCreateManyStudentsInputEnvelope
    set?: class_representativesWhereUniqueInput | class_representativesWhereUniqueInput[]
    disconnect?: class_representativesWhereUniqueInput | class_representativesWhereUniqueInput[]
    delete?: class_representativesWhereUniqueInput | class_representativesWhereUniqueInput[]
    connect?: class_representativesWhereUniqueInput | class_representativesWhereUniqueInput[]
    update?: class_representativesUpdateWithWhereUniqueWithoutStudentsInput | class_representativesUpdateWithWhereUniqueWithoutStudentsInput[]
    updateMany?: class_representativesUpdateManyWithWhereWithoutStudentsInput | class_representativesUpdateManyWithWhereWithoutStudentsInput[]
    deleteMany?: class_representativesScalarWhereInput | class_representativesScalarWhereInput[]
  }

  export type class_teachersUpdateManyWithoutStudentsNestedInput = {
    create?: XOR<class_teachersCreateWithoutStudentsInput, class_teachersUncheckedCreateWithoutStudentsInput> | class_teachersCreateWithoutStudentsInput[] | class_teachersUncheckedCreateWithoutStudentsInput[]
    connectOrCreate?: class_teachersCreateOrConnectWithoutStudentsInput | class_teachersCreateOrConnectWithoutStudentsInput[]
    upsert?: class_teachersUpsertWithWhereUniqueWithoutStudentsInput | class_teachersUpsertWithWhereUniqueWithoutStudentsInput[]
    createMany?: class_teachersCreateManyStudentsInputEnvelope
    set?: class_teachersWhereUniqueInput | class_teachersWhereUniqueInput[]
    disconnect?: class_teachersWhereUniqueInput | class_teachersWhereUniqueInput[]
    delete?: class_teachersWhereUniqueInput | class_teachersWhereUniqueInput[]
    connect?: class_teachersWhereUniqueInput | class_teachersWhereUniqueInput[]
    update?: class_teachersUpdateWithWhereUniqueWithoutStudentsInput | class_teachersUpdateWithWhereUniqueWithoutStudentsInput[]
    updateMany?: class_teachersUpdateManyWithWhereWithoutStudentsInput | class_teachersUpdateManyWithWhereWithoutStudentsInput[]
    deleteMany?: class_teachersScalarWhereInput | class_teachersScalarWhereInput[]
  }

  export type financesUpdateManyWithoutStudentsNestedInput = {
    create?: XOR<financesCreateWithoutStudentsInput, financesUncheckedCreateWithoutStudentsInput> | financesCreateWithoutStudentsInput[] | financesUncheckedCreateWithoutStudentsInput[]
    connectOrCreate?: financesCreateOrConnectWithoutStudentsInput | financesCreateOrConnectWithoutStudentsInput[]
    upsert?: financesUpsertWithWhereUniqueWithoutStudentsInput | financesUpsertWithWhereUniqueWithoutStudentsInput[]
    createMany?: financesCreateManyStudentsInputEnvelope
    set?: financesWhereUniqueInput | financesWhereUniqueInput[]
    disconnect?: financesWhereUniqueInput | financesWhereUniqueInput[]
    delete?: financesWhereUniqueInput | financesWhereUniqueInput[]
    connect?: financesWhereUniqueInput | financesWhereUniqueInput[]
    update?: financesUpdateWithWhereUniqueWithoutStudentsInput | financesUpdateWithWhereUniqueWithoutStudentsInput[]
    updateMany?: financesUpdateManyWithWhereWithoutStudentsInput | financesUpdateManyWithWhereWithoutStudentsInput[]
    deleteMany?: financesScalarWhereInput | financesScalarWhereInput[]
  }

  export type student_performanceUpdateManyWithoutStudentsNestedInput = {
    create?: XOR<student_performanceCreateWithoutStudentsInput, student_performanceUncheckedCreateWithoutStudentsInput> | student_performanceCreateWithoutStudentsInput[] | student_performanceUncheckedCreateWithoutStudentsInput[]
    connectOrCreate?: student_performanceCreateOrConnectWithoutStudentsInput | student_performanceCreateOrConnectWithoutStudentsInput[]
    upsert?: student_performanceUpsertWithWhereUniqueWithoutStudentsInput | student_performanceUpsertWithWhereUniqueWithoutStudentsInput[]
    createMany?: student_performanceCreateManyStudentsInputEnvelope
    set?: student_performanceWhereUniqueInput | student_performanceWhereUniqueInput[]
    disconnect?: student_performanceWhereUniqueInput | student_performanceWhereUniqueInput[]
    delete?: student_performanceWhereUniqueInput | student_performanceWhereUniqueInput[]
    connect?: student_performanceWhereUniqueInput | student_performanceWhereUniqueInput[]
    update?: student_performanceUpdateWithWhereUniqueWithoutStudentsInput | student_performanceUpdateWithWhereUniqueWithoutStudentsInput[]
    updateMany?: student_performanceUpdateManyWithWhereWithoutStudentsInput | student_performanceUpdateManyWithWhereWithoutStudentsInput[]
    deleteMany?: student_performanceScalarWhereInput | student_performanceScalarWhereInput[]
  }

  export type usersUpdateOneWithoutStudentsNestedInput = {
    create?: XOR<usersCreateWithoutStudentsInput, usersUncheckedCreateWithoutStudentsInput>
    connectOrCreate?: usersCreateOrConnectWithoutStudentsInput
    upsert?: usersUpsertWithoutStudentsInput
    disconnect?: usersWhereInput | boolean
    delete?: usersWhereInput | boolean
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutStudentsInput, usersUpdateWithoutStudentsInput>, usersUncheckedUpdateWithoutStudentsInput>
  }

  export type attendanceUncheckedUpdateManyWithoutStudentsNestedInput = {
    create?: XOR<attendanceCreateWithoutStudentsInput, attendanceUncheckedCreateWithoutStudentsInput> | attendanceCreateWithoutStudentsInput[] | attendanceUncheckedCreateWithoutStudentsInput[]
    connectOrCreate?: attendanceCreateOrConnectWithoutStudentsInput | attendanceCreateOrConnectWithoutStudentsInput[]
    upsert?: attendanceUpsertWithWhereUniqueWithoutStudentsInput | attendanceUpsertWithWhereUniqueWithoutStudentsInput[]
    createMany?: attendanceCreateManyStudentsInputEnvelope
    set?: attendanceWhereUniqueInput | attendanceWhereUniqueInput[]
    disconnect?: attendanceWhereUniqueInput | attendanceWhereUniqueInput[]
    delete?: attendanceWhereUniqueInput | attendanceWhereUniqueInput[]
    connect?: attendanceWhereUniqueInput | attendanceWhereUniqueInput[]
    update?: attendanceUpdateWithWhereUniqueWithoutStudentsInput | attendanceUpdateWithWhereUniqueWithoutStudentsInput[]
    updateMany?: attendanceUpdateManyWithWhereWithoutStudentsInput | attendanceUpdateManyWithWhereWithoutStudentsInput[]
    deleteMany?: attendanceScalarWhereInput | attendanceScalarWhereInput[]
  }

  export type class_representativesUncheckedUpdateManyWithoutStudentsNestedInput = {
    create?: XOR<class_representativesCreateWithoutStudentsInput, class_representativesUncheckedCreateWithoutStudentsInput> | class_representativesCreateWithoutStudentsInput[] | class_representativesUncheckedCreateWithoutStudentsInput[]
    connectOrCreate?: class_representativesCreateOrConnectWithoutStudentsInput | class_representativesCreateOrConnectWithoutStudentsInput[]
    upsert?: class_representativesUpsertWithWhereUniqueWithoutStudentsInput | class_representativesUpsertWithWhereUniqueWithoutStudentsInput[]
    createMany?: class_representativesCreateManyStudentsInputEnvelope
    set?: class_representativesWhereUniqueInput | class_representativesWhereUniqueInput[]
    disconnect?: class_representativesWhereUniqueInput | class_representativesWhereUniqueInput[]
    delete?: class_representativesWhereUniqueInput | class_representativesWhereUniqueInput[]
    connect?: class_representativesWhereUniqueInput | class_representativesWhereUniqueInput[]
    update?: class_representativesUpdateWithWhereUniqueWithoutStudentsInput | class_representativesUpdateWithWhereUniqueWithoutStudentsInput[]
    updateMany?: class_representativesUpdateManyWithWhereWithoutStudentsInput | class_representativesUpdateManyWithWhereWithoutStudentsInput[]
    deleteMany?: class_representativesScalarWhereInput | class_representativesScalarWhereInput[]
  }

  export type class_teachersUncheckedUpdateManyWithoutStudentsNestedInput = {
    create?: XOR<class_teachersCreateWithoutStudentsInput, class_teachersUncheckedCreateWithoutStudentsInput> | class_teachersCreateWithoutStudentsInput[] | class_teachersUncheckedCreateWithoutStudentsInput[]
    connectOrCreate?: class_teachersCreateOrConnectWithoutStudentsInput | class_teachersCreateOrConnectWithoutStudentsInput[]
    upsert?: class_teachersUpsertWithWhereUniqueWithoutStudentsInput | class_teachersUpsertWithWhereUniqueWithoutStudentsInput[]
    createMany?: class_teachersCreateManyStudentsInputEnvelope
    set?: class_teachersWhereUniqueInput | class_teachersWhereUniqueInput[]
    disconnect?: class_teachersWhereUniqueInput | class_teachersWhereUniqueInput[]
    delete?: class_teachersWhereUniqueInput | class_teachersWhereUniqueInput[]
    connect?: class_teachersWhereUniqueInput | class_teachersWhereUniqueInput[]
    update?: class_teachersUpdateWithWhereUniqueWithoutStudentsInput | class_teachersUpdateWithWhereUniqueWithoutStudentsInput[]
    updateMany?: class_teachersUpdateManyWithWhereWithoutStudentsInput | class_teachersUpdateManyWithWhereWithoutStudentsInput[]
    deleteMany?: class_teachersScalarWhereInput | class_teachersScalarWhereInput[]
  }

  export type financesUncheckedUpdateManyWithoutStudentsNestedInput = {
    create?: XOR<financesCreateWithoutStudentsInput, financesUncheckedCreateWithoutStudentsInput> | financesCreateWithoutStudentsInput[] | financesUncheckedCreateWithoutStudentsInput[]
    connectOrCreate?: financesCreateOrConnectWithoutStudentsInput | financesCreateOrConnectWithoutStudentsInput[]
    upsert?: financesUpsertWithWhereUniqueWithoutStudentsInput | financesUpsertWithWhereUniqueWithoutStudentsInput[]
    createMany?: financesCreateManyStudentsInputEnvelope
    set?: financesWhereUniqueInput | financesWhereUniqueInput[]
    disconnect?: financesWhereUniqueInput | financesWhereUniqueInput[]
    delete?: financesWhereUniqueInput | financesWhereUniqueInput[]
    connect?: financesWhereUniqueInput | financesWhereUniqueInput[]
    update?: financesUpdateWithWhereUniqueWithoutStudentsInput | financesUpdateWithWhereUniqueWithoutStudentsInput[]
    updateMany?: financesUpdateManyWithWhereWithoutStudentsInput | financesUpdateManyWithWhereWithoutStudentsInput[]
    deleteMany?: financesScalarWhereInput | financesScalarWhereInput[]
  }

  export type student_performanceUncheckedUpdateManyWithoutStudentsNestedInput = {
    create?: XOR<student_performanceCreateWithoutStudentsInput, student_performanceUncheckedCreateWithoutStudentsInput> | student_performanceCreateWithoutStudentsInput[] | student_performanceUncheckedCreateWithoutStudentsInput[]
    connectOrCreate?: student_performanceCreateOrConnectWithoutStudentsInput | student_performanceCreateOrConnectWithoutStudentsInput[]
    upsert?: student_performanceUpsertWithWhereUniqueWithoutStudentsInput | student_performanceUpsertWithWhereUniqueWithoutStudentsInput[]
    createMany?: student_performanceCreateManyStudentsInputEnvelope
    set?: student_performanceWhereUniqueInput | student_performanceWhereUniqueInput[]
    disconnect?: student_performanceWhereUniqueInput | student_performanceWhereUniqueInput[]
    delete?: student_performanceWhereUniqueInput | student_performanceWhereUniqueInput[]
    connect?: student_performanceWhereUniqueInput | student_performanceWhereUniqueInput[]
    update?: student_performanceUpdateWithWhereUniqueWithoutStudentsInput | student_performanceUpdateWithWhereUniqueWithoutStudentsInput[]
    updateMany?: student_performanceUpdateManyWithWhereWithoutStudentsInput | student_performanceUpdateManyWithWhereWithoutStudentsInput[]
    deleteMany?: student_performanceScalarWhereInput | student_performanceScalarWhereInput[]
  }

  export type usersCreateNestedOneWithoutTeacher_routineInput = {
    create?: XOR<usersCreateWithoutTeacher_routineInput, usersUncheckedCreateWithoutTeacher_routineInput>
    connectOrCreate?: usersCreateOrConnectWithoutTeacher_routineInput
    connect?: usersWhereUniqueInput
  }

  export type usersUpdateOneRequiredWithoutTeacher_routineNestedInput = {
    create?: XOR<usersCreateWithoutTeacher_routineInput, usersUncheckedCreateWithoutTeacher_routineInput>
    connectOrCreate?: usersCreateOrConnectWithoutTeacher_routineInput
    upsert?: usersUpsertWithoutTeacher_routineInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutTeacher_routineInput, usersUpdateWithoutTeacher_routineInput>, usersUncheckedUpdateWithoutTeacher_routineInput>
  }

  export type assignmentsCreateNestedManyWithoutTeachersInput = {
    create?: XOR<assignmentsCreateWithoutTeachersInput, assignmentsUncheckedCreateWithoutTeachersInput> | assignmentsCreateWithoutTeachersInput[] | assignmentsUncheckedCreateWithoutTeachersInput[]
    connectOrCreate?: assignmentsCreateOrConnectWithoutTeachersInput | assignmentsCreateOrConnectWithoutTeachersInput[]
    createMany?: assignmentsCreateManyTeachersInputEnvelope
    connect?: assignmentsWhereUniqueInput | assignmentsWhereUniqueInput[]
  }

  export type attendanceCreateNestedManyWithoutTeachersInput = {
    create?: XOR<attendanceCreateWithoutTeachersInput, attendanceUncheckedCreateWithoutTeachersInput> | attendanceCreateWithoutTeachersInput[] | attendanceUncheckedCreateWithoutTeachersInput[]
    connectOrCreate?: attendanceCreateOrConnectWithoutTeachersInput | attendanceCreateOrConnectWithoutTeachersInput[]
    createMany?: attendanceCreateManyTeachersInputEnvelope
    connect?: attendanceWhereUniqueInput | attendanceWhereUniqueInput[]
  }

  export type class_routineCreateNestedManyWithoutTeachersInput = {
    create?: XOR<class_routineCreateWithoutTeachersInput, class_routineUncheckedCreateWithoutTeachersInput> | class_routineCreateWithoutTeachersInput[] | class_routineUncheckedCreateWithoutTeachersInput[]
    connectOrCreate?: class_routineCreateOrConnectWithoutTeachersInput | class_routineCreateOrConnectWithoutTeachersInput[]
    createMany?: class_routineCreateManyTeachersInputEnvelope
    connect?: class_routineWhereUniqueInput | class_routineWhereUniqueInput[]
  }

  export type class_teachersCreateNestedManyWithoutTeachersInput = {
    create?: XOR<class_teachersCreateWithoutTeachersInput, class_teachersUncheckedCreateWithoutTeachersInput> | class_teachersCreateWithoutTeachersInput[] | class_teachersUncheckedCreateWithoutTeachersInput[]
    connectOrCreate?: class_teachersCreateOrConnectWithoutTeachersInput | class_teachersCreateOrConnectWithoutTeachersInput[]
    createMany?: class_teachersCreateManyTeachersInputEnvelope
    connect?: class_teachersWhereUniqueInput | class_teachersWhereUniqueInput[]
  }

  export type examsCreateNestedManyWithoutTeachersInput = {
    create?: XOR<examsCreateWithoutTeachersInput, examsUncheckedCreateWithoutTeachersInput> | examsCreateWithoutTeachersInput[] | examsUncheckedCreateWithoutTeachersInput[]
    connectOrCreate?: examsCreateOrConnectWithoutTeachersInput | examsCreateOrConnectWithoutTeachersInput[]
    createMany?: examsCreateManyTeachersInputEnvelope
    connect?: examsWhereUniqueInput | examsWhereUniqueInput[]
  }

  export type performanceCreateNestedManyWithoutTeachersInput = {
    create?: XOR<performanceCreateWithoutTeachersInput, performanceUncheckedCreateWithoutTeachersInput> | performanceCreateWithoutTeachersInput[] | performanceUncheckedCreateWithoutTeachersInput[]
    connectOrCreate?: performanceCreateOrConnectWithoutTeachersInput | performanceCreateOrConnectWithoutTeachersInput[]
    createMany?: performanceCreateManyTeachersInputEnvelope
    connect?: performanceWhereUniqueInput | performanceWhereUniqueInput[]
  }

  export type student_routineCreateNestedManyWithoutTeachersInput = {
    create?: XOR<student_routineCreateWithoutTeachersInput, student_routineUncheckedCreateWithoutTeachersInput> | student_routineCreateWithoutTeachersInput[] | student_routineUncheckedCreateWithoutTeachersInput[]
    connectOrCreate?: student_routineCreateOrConnectWithoutTeachersInput | student_routineCreateOrConnectWithoutTeachersInput[]
    createMany?: student_routineCreateManyTeachersInputEnvelope
    connect?: student_routineWhereUniqueInput | student_routineWhereUniqueInput[]
  }

  export type usersCreateNestedOneWithoutTeachersInput = {
    create?: XOR<usersCreateWithoutTeachersInput, usersUncheckedCreateWithoutTeachersInput>
    connectOrCreate?: usersCreateOrConnectWithoutTeachersInput
    connect?: usersWhereUniqueInput
  }

  export type assignmentsUncheckedCreateNestedManyWithoutTeachersInput = {
    create?: XOR<assignmentsCreateWithoutTeachersInput, assignmentsUncheckedCreateWithoutTeachersInput> | assignmentsCreateWithoutTeachersInput[] | assignmentsUncheckedCreateWithoutTeachersInput[]
    connectOrCreate?: assignmentsCreateOrConnectWithoutTeachersInput | assignmentsCreateOrConnectWithoutTeachersInput[]
    createMany?: assignmentsCreateManyTeachersInputEnvelope
    connect?: assignmentsWhereUniqueInput | assignmentsWhereUniqueInput[]
  }

  export type attendanceUncheckedCreateNestedManyWithoutTeachersInput = {
    create?: XOR<attendanceCreateWithoutTeachersInput, attendanceUncheckedCreateWithoutTeachersInput> | attendanceCreateWithoutTeachersInput[] | attendanceUncheckedCreateWithoutTeachersInput[]
    connectOrCreate?: attendanceCreateOrConnectWithoutTeachersInput | attendanceCreateOrConnectWithoutTeachersInput[]
    createMany?: attendanceCreateManyTeachersInputEnvelope
    connect?: attendanceWhereUniqueInput | attendanceWhereUniqueInput[]
  }

  export type class_routineUncheckedCreateNestedManyWithoutTeachersInput = {
    create?: XOR<class_routineCreateWithoutTeachersInput, class_routineUncheckedCreateWithoutTeachersInput> | class_routineCreateWithoutTeachersInput[] | class_routineUncheckedCreateWithoutTeachersInput[]
    connectOrCreate?: class_routineCreateOrConnectWithoutTeachersInput | class_routineCreateOrConnectWithoutTeachersInput[]
    createMany?: class_routineCreateManyTeachersInputEnvelope
    connect?: class_routineWhereUniqueInput | class_routineWhereUniqueInput[]
  }

  export type class_teachersUncheckedCreateNestedManyWithoutTeachersInput = {
    create?: XOR<class_teachersCreateWithoutTeachersInput, class_teachersUncheckedCreateWithoutTeachersInput> | class_teachersCreateWithoutTeachersInput[] | class_teachersUncheckedCreateWithoutTeachersInput[]
    connectOrCreate?: class_teachersCreateOrConnectWithoutTeachersInput | class_teachersCreateOrConnectWithoutTeachersInput[]
    createMany?: class_teachersCreateManyTeachersInputEnvelope
    connect?: class_teachersWhereUniqueInput | class_teachersWhereUniqueInput[]
  }

  export type examsUncheckedCreateNestedManyWithoutTeachersInput = {
    create?: XOR<examsCreateWithoutTeachersInput, examsUncheckedCreateWithoutTeachersInput> | examsCreateWithoutTeachersInput[] | examsUncheckedCreateWithoutTeachersInput[]
    connectOrCreate?: examsCreateOrConnectWithoutTeachersInput | examsCreateOrConnectWithoutTeachersInput[]
    createMany?: examsCreateManyTeachersInputEnvelope
    connect?: examsWhereUniqueInput | examsWhereUniqueInput[]
  }

  export type performanceUncheckedCreateNestedManyWithoutTeachersInput = {
    create?: XOR<performanceCreateWithoutTeachersInput, performanceUncheckedCreateWithoutTeachersInput> | performanceCreateWithoutTeachersInput[] | performanceUncheckedCreateWithoutTeachersInput[]
    connectOrCreate?: performanceCreateOrConnectWithoutTeachersInput | performanceCreateOrConnectWithoutTeachersInput[]
    createMany?: performanceCreateManyTeachersInputEnvelope
    connect?: performanceWhereUniqueInput | performanceWhereUniqueInput[]
  }

  export type student_routineUncheckedCreateNestedManyWithoutTeachersInput = {
    create?: XOR<student_routineCreateWithoutTeachersInput, student_routineUncheckedCreateWithoutTeachersInput> | student_routineCreateWithoutTeachersInput[] | student_routineUncheckedCreateWithoutTeachersInput[]
    connectOrCreate?: student_routineCreateOrConnectWithoutTeachersInput | student_routineCreateOrConnectWithoutTeachersInput[]
    createMany?: student_routineCreateManyTeachersInputEnvelope
    connect?: student_routineWhereUniqueInput | student_routineWhereUniqueInput[]
  }

  export type assignmentsUpdateManyWithoutTeachersNestedInput = {
    create?: XOR<assignmentsCreateWithoutTeachersInput, assignmentsUncheckedCreateWithoutTeachersInput> | assignmentsCreateWithoutTeachersInput[] | assignmentsUncheckedCreateWithoutTeachersInput[]
    connectOrCreate?: assignmentsCreateOrConnectWithoutTeachersInput | assignmentsCreateOrConnectWithoutTeachersInput[]
    upsert?: assignmentsUpsertWithWhereUniqueWithoutTeachersInput | assignmentsUpsertWithWhereUniqueWithoutTeachersInput[]
    createMany?: assignmentsCreateManyTeachersInputEnvelope
    set?: assignmentsWhereUniqueInput | assignmentsWhereUniqueInput[]
    disconnect?: assignmentsWhereUniqueInput | assignmentsWhereUniqueInput[]
    delete?: assignmentsWhereUniqueInput | assignmentsWhereUniqueInput[]
    connect?: assignmentsWhereUniqueInput | assignmentsWhereUniqueInput[]
    update?: assignmentsUpdateWithWhereUniqueWithoutTeachersInput | assignmentsUpdateWithWhereUniqueWithoutTeachersInput[]
    updateMany?: assignmentsUpdateManyWithWhereWithoutTeachersInput | assignmentsUpdateManyWithWhereWithoutTeachersInput[]
    deleteMany?: assignmentsScalarWhereInput | assignmentsScalarWhereInput[]
  }

  export type attendanceUpdateManyWithoutTeachersNestedInput = {
    create?: XOR<attendanceCreateWithoutTeachersInput, attendanceUncheckedCreateWithoutTeachersInput> | attendanceCreateWithoutTeachersInput[] | attendanceUncheckedCreateWithoutTeachersInput[]
    connectOrCreate?: attendanceCreateOrConnectWithoutTeachersInput | attendanceCreateOrConnectWithoutTeachersInput[]
    upsert?: attendanceUpsertWithWhereUniqueWithoutTeachersInput | attendanceUpsertWithWhereUniqueWithoutTeachersInput[]
    createMany?: attendanceCreateManyTeachersInputEnvelope
    set?: attendanceWhereUniqueInput | attendanceWhereUniqueInput[]
    disconnect?: attendanceWhereUniqueInput | attendanceWhereUniqueInput[]
    delete?: attendanceWhereUniqueInput | attendanceWhereUniqueInput[]
    connect?: attendanceWhereUniqueInput | attendanceWhereUniqueInput[]
    update?: attendanceUpdateWithWhereUniqueWithoutTeachersInput | attendanceUpdateWithWhereUniqueWithoutTeachersInput[]
    updateMany?: attendanceUpdateManyWithWhereWithoutTeachersInput | attendanceUpdateManyWithWhereWithoutTeachersInput[]
    deleteMany?: attendanceScalarWhereInput | attendanceScalarWhereInput[]
  }

  export type class_routineUpdateManyWithoutTeachersNestedInput = {
    create?: XOR<class_routineCreateWithoutTeachersInput, class_routineUncheckedCreateWithoutTeachersInput> | class_routineCreateWithoutTeachersInput[] | class_routineUncheckedCreateWithoutTeachersInput[]
    connectOrCreate?: class_routineCreateOrConnectWithoutTeachersInput | class_routineCreateOrConnectWithoutTeachersInput[]
    upsert?: class_routineUpsertWithWhereUniqueWithoutTeachersInput | class_routineUpsertWithWhereUniqueWithoutTeachersInput[]
    createMany?: class_routineCreateManyTeachersInputEnvelope
    set?: class_routineWhereUniqueInput | class_routineWhereUniqueInput[]
    disconnect?: class_routineWhereUniqueInput | class_routineWhereUniqueInput[]
    delete?: class_routineWhereUniqueInput | class_routineWhereUniqueInput[]
    connect?: class_routineWhereUniqueInput | class_routineWhereUniqueInput[]
    update?: class_routineUpdateWithWhereUniqueWithoutTeachersInput | class_routineUpdateWithWhereUniqueWithoutTeachersInput[]
    updateMany?: class_routineUpdateManyWithWhereWithoutTeachersInput | class_routineUpdateManyWithWhereWithoutTeachersInput[]
    deleteMany?: class_routineScalarWhereInput | class_routineScalarWhereInput[]
  }

  export type class_teachersUpdateManyWithoutTeachersNestedInput = {
    create?: XOR<class_teachersCreateWithoutTeachersInput, class_teachersUncheckedCreateWithoutTeachersInput> | class_teachersCreateWithoutTeachersInput[] | class_teachersUncheckedCreateWithoutTeachersInput[]
    connectOrCreate?: class_teachersCreateOrConnectWithoutTeachersInput | class_teachersCreateOrConnectWithoutTeachersInput[]
    upsert?: class_teachersUpsertWithWhereUniqueWithoutTeachersInput | class_teachersUpsertWithWhereUniqueWithoutTeachersInput[]
    createMany?: class_teachersCreateManyTeachersInputEnvelope
    set?: class_teachersWhereUniqueInput | class_teachersWhereUniqueInput[]
    disconnect?: class_teachersWhereUniqueInput | class_teachersWhereUniqueInput[]
    delete?: class_teachersWhereUniqueInput | class_teachersWhereUniqueInput[]
    connect?: class_teachersWhereUniqueInput | class_teachersWhereUniqueInput[]
    update?: class_teachersUpdateWithWhereUniqueWithoutTeachersInput | class_teachersUpdateWithWhereUniqueWithoutTeachersInput[]
    updateMany?: class_teachersUpdateManyWithWhereWithoutTeachersInput | class_teachersUpdateManyWithWhereWithoutTeachersInput[]
    deleteMany?: class_teachersScalarWhereInput | class_teachersScalarWhereInput[]
  }

  export type examsUpdateManyWithoutTeachersNestedInput = {
    create?: XOR<examsCreateWithoutTeachersInput, examsUncheckedCreateWithoutTeachersInput> | examsCreateWithoutTeachersInput[] | examsUncheckedCreateWithoutTeachersInput[]
    connectOrCreate?: examsCreateOrConnectWithoutTeachersInput | examsCreateOrConnectWithoutTeachersInput[]
    upsert?: examsUpsertWithWhereUniqueWithoutTeachersInput | examsUpsertWithWhereUniqueWithoutTeachersInput[]
    createMany?: examsCreateManyTeachersInputEnvelope
    set?: examsWhereUniqueInput | examsWhereUniqueInput[]
    disconnect?: examsWhereUniqueInput | examsWhereUniqueInput[]
    delete?: examsWhereUniqueInput | examsWhereUniqueInput[]
    connect?: examsWhereUniqueInput | examsWhereUniqueInput[]
    update?: examsUpdateWithWhereUniqueWithoutTeachersInput | examsUpdateWithWhereUniqueWithoutTeachersInput[]
    updateMany?: examsUpdateManyWithWhereWithoutTeachersInput | examsUpdateManyWithWhereWithoutTeachersInput[]
    deleteMany?: examsScalarWhereInput | examsScalarWhereInput[]
  }

  export type performanceUpdateManyWithoutTeachersNestedInput = {
    create?: XOR<performanceCreateWithoutTeachersInput, performanceUncheckedCreateWithoutTeachersInput> | performanceCreateWithoutTeachersInput[] | performanceUncheckedCreateWithoutTeachersInput[]
    connectOrCreate?: performanceCreateOrConnectWithoutTeachersInput | performanceCreateOrConnectWithoutTeachersInput[]
    upsert?: performanceUpsertWithWhereUniqueWithoutTeachersInput | performanceUpsertWithWhereUniqueWithoutTeachersInput[]
    createMany?: performanceCreateManyTeachersInputEnvelope
    set?: performanceWhereUniqueInput | performanceWhereUniqueInput[]
    disconnect?: performanceWhereUniqueInput | performanceWhereUniqueInput[]
    delete?: performanceWhereUniqueInput | performanceWhereUniqueInput[]
    connect?: performanceWhereUniqueInput | performanceWhereUniqueInput[]
    update?: performanceUpdateWithWhereUniqueWithoutTeachersInput | performanceUpdateWithWhereUniqueWithoutTeachersInput[]
    updateMany?: performanceUpdateManyWithWhereWithoutTeachersInput | performanceUpdateManyWithWhereWithoutTeachersInput[]
    deleteMany?: performanceScalarWhereInput | performanceScalarWhereInput[]
  }

  export type student_routineUpdateManyWithoutTeachersNestedInput = {
    create?: XOR<student_routineCreateWithoutTeachersInput, student_routineUncheckedCreateWithoutTeachersInput> | student_routineCreateWithoutTeachersInput[] | student_routineUncheckedCreateWithoutTeachersInput[]
    connectOrCreate?: student_routineCreateOrConnectWithoutTeachersInput | student_routineCreateOrConnectWithoutTeachersInput[]
    upsert?: student_routineUpsertWithWhereUniqueWithoutTeachersInput | student_routineUpsertWithWhereUniqueWithoutTeachersInput[]
    createMany?: student_routineCreateManyTeachersInputEnvelope
    set?: student_routineWhereUniqueInput | student_routineWhereUniqueInput[]
    disconnect?: student_routineWhereUniqueInput | student_routineWhereUniqueInput[]
    delete?: student_routineWhereUniqueInput | student_routineWhereUniqueInput[]
    connect?: student_routineWhereUniqueInput | student_routineWhereUniqueInput[]
    update?: student_routineUpdateWithWhereUniqueWithoutTeachersInput | student_routineUpdateWithWhereUniqueWithoutTeachersInput[]
    updateMany?: student_routineUpdateManyWithWhereWithoutTeachersInput | student_routineUpdateManyWithWhereWithoutTeachersInput[]
    deleteMany?: student_routineScalarWhereInput | student_routineScalarWhereInput[]
  }

  export type usersUpdateOneWithoutTeachersNestedInput = {
    create?: XOR<usersCreateWithoutTeachersInput, usersUncheckedCreateWithoutTeachersInput>
    connectOrCreate?: usersCreateOrConnectWithoutTeachersInput
    upsert?: usersUpsertWithoutTeachersInput
    disconnect?: usersWhereInput | boolean
    delete?: usersWhereInput | boolean
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutTeachersInput, usersUpdateWithoutTeachersInput>, usersUncheckedUpdateWithoutTeachersInput>
  }

  export type assignmentsUncheckedUpdateManyWithoutTeachersNestedInput = {
    create?: XOR<assignmentsCreateWithoutTeachersInput, assignmentsUncheckedCreateWithoutTeachersInput> | assignmentsCreateWithoutTeachersInput[] | assignmentsUncheckedCreateWithoutTeachersInput[]
    connectOrCreate?: assignmentsCreateOrConnectWithoutTeachersInput | assignmentsCreateOrConnectWithoutTeachersInput[]
    upsert?: assignmentsUpsertWithWhereUniqueWithoutTeachersInput | assignmentsUpsertWithWhereUniqueWithoutTeachersInput[]
    createMany?: assignmentsCreateManyTeachersInputEnvelope
    set?: assignmentsWhereUniqueInput | assignmentsWhereUniqueInput[]
    disconnect?: assignmentsWhereUniqueInput | assignmentsWhereUniqueInput[]
    delete?: assignmentsWhereUniqueInput | assignmentsWhereUniqueInput[]
    connect?: assignmentsWhereUniqueInput | assignmentsWhereUniqueInput[]
    update?: assignmentsUpdateWithWhereUniqueWithoutTeachersInput | assignmentsUpdateWithWhereUniqueWithoutTeachersInput[]
    updateMany?: assignmentsUpdateManyWithWhereWithoutTeachersInput | assignmentsUpdateManyWithWhereWithoutTeachersInput[]
    deleteMany?: assignmentsScalarWhereInput | assignmentsScalarWhereInput[]
  }

  export type attendanceUncheckedUpdateManyWithoutTeachersNestedInput = {
    create?: XOR<attendanceCreateWithoutTeachersInput, attendanceUncheckedCreateWithoutTeachersInput> | attendanceCreateWithoutTeachersInput[] | attendanceUncheckedCreateWithoutTeachersInput[]
    connectOrCreate?: attendanceCreateOrConnectWithoutTeachersInput | attendanceCreateOrConnectWithoutTeachersInput[]
    upsert?: attendanceUpsertWithWhereUniqueWithoutTeachersInput | attendanceUpsertWithWhereUniqueWithoutTeachersInput[]
    createMany?: attendanceCreateManyTeachersInputEnvelope
    set?: attendanceWhereUniqueInput | attendanceWhereUniqueInput[]
    disconnect?: attendanceWhereUniqueInput | attendanceWhereUniqueInput[]
    delete?: attendanceWhereUniqueInput | attendanceWhereUniqueInput[]
    connect?: attendanceWhereUniqueInput | attendanceWhereUniqueInput[]
    update?: attendanceUpdateWithWhereUniqueWithoutTeachersInput | attendanceUpdateWithWhereUniqueWithoutTeachersInput[]
    updateMany?: attendanceUpdateManyWithWhereWithoutTeachersInput | attendanceUpdateManyWithWhereWithoutTeachersInput[]
    deleteMany?: attendanceScalarWhereInput | attendanceScalarWhereInput[]
  }

  export type class_routineUncheckedUpdateManyWithoutTeachersNestedInput = {
    create?: XOR<class_routineCreateWithoutTeachersInput, class_routineUncheckedCreateWithoutTeachersInput> | class_routineCreateWithoutTeachersInput[] | class_routineUncheckedCreateWithoutTeachersInput[]
    connectOrCreate?: class_routineCreateOrConnectWithoutTeachersInput | class_routineCreateOrConnectWithoutTeachersInput[]
    upsert?: class_routineUpsertWithWhereUniqueWithoutTeachersInput | class_routineUpsertWithWhereUniqueWithoutTeachersInput[]
    createMany?: class_routineCreateManyTeachersInputEnvelope
    set?: class_routineWhereUniqueInput | class_routineWhereUniqueInput[]
    disconnect?: class_routineWhereUniqueInput | class_routineWhereUniqueInput[]
    delete?: class_routineWhereUniqueInput | class_routineWhereUniqueInput[]
    connect?: class_routineWhereUniqueInput | class_routineWhereUniqueInput[]
    update?: class_routineUpdateWithWhereUniqueWithoutTeachersInput | class_routineUpdateWithWhereUniqueWithoutTeachersInput[]
    updateMany?: class_routineUpdateManyWithWhereWithoutTeachersInput | class_routineUpdateManyWithWhereWithoutTeachersInput[]
    deleteMany?: class_routineScalarWhereInput | class_routineScalarWhereInput[]
  }

  export type class_teachersUncheckedUpdateManyWithoutTeachersNestedInput = {
    create?: XOR<class_teachersCreateWithoutTeachersInput, class_teachersUncheckedCreateWithoutTeachersInput> | class_teachersCreateWithoutTeachersInput[] | class_teachersUncheckedCreateWithoutTeachersInput[]
    connectOrCreate?: class_teachersCreateOrConnectWithoutTeachersInput | class_teachersCreateOrConnectWithoutTeachersInput[]
    upsert?: class_teachersUpsertWithWhereUniqueWithoutTeachersInput | class_teachersUpsertWithWhereUniqueWithoutTeachersInput[]
    createMany?: class_teachersCreateManyTeachersInputEnvelope
    set?: class_teachersWhereUniqueInput | class_teachersWhereUniqueInput[]
    disconnect?: class_teachersWhereUniqueInput | class_teachersWhereUniqueInput[]
    delete?: class_teachersWhereUniqueInput | class_teachersWhereUniqueInput[]
    connect?: class_teachersWhereUniqueInput | class_teachersWhereUniqueInput[]
    update?: class_teachersUpdateWithWhereUniqueWithoutTeachersInput | class_teachersUpdateWithWhereUniqueWithoutTeachersInput[]
    updateMany?: class_teachersUpdateManyWithWhereWithoutTeachersInput | class_teachersUpdateManyWithWhereWithoutTeachersInput[]
    deleteMany?: class_teachersScalarWhereInput | class_teachersScalarWhereInput[]
  }

  export type examsUncheckedUpdateManyWithoutTeachersNestedInput = {
    create?: XOR<examsCreateWithoutTeachersInput, examsUncheckedCreateWithoutTeachersInput> | examsCreateWithoutTeachersInput[] | examsUncheckedCreateWithoutTeachersInput[]
    connectOrCreate?: examsCreateOrConnectWithoutTeachersInput | examsCreateOrConnectWithoutTeachersInput[]
    upsert?: examsUpsertWithWhereUniqueWithoutTeachersInput | examsUpsertWithWhereUniqueWithoutTeachersInput[]
    createMany?: examsCreateManyTeachersInputEnvelope
    set?: examsWhereUniqueInput | examsWhereUniqueInput[]
    disconnect?: examsWhereUniqueInput | examsWhereUniqueInput[]
    delete?: examsWhereUniqueInput | examsWhereUniqueInput[]
    connect?: examsWhereUniqueInput | examsWhereUniqueInput[]
    update?: examsUpdateWithWhereUniqueWithoutTeachersInput | examsUpdateWithWhereUniqueWithoutTeachersInput[]
    updateMany?: examsUpdateManyWithWhereWithoutTeachersInput | examsUpdateManyWithWhereWithoutTeachersInput[]
    deleteMany?: examsScalarWhereInput | examsScalarWhereInput[]
  }

  export type performanceUncheckedUpdateManyWithoutTeachersNestedInput = {
    create?: XOR<performanceCreateWithoutTeachersInput, performanceUncheckedCreateWithoutTeachersInput> | performanceCreateWithoutTeachersInput[] | performanceUncheckedCreateWithoutTeachersInput[]
    connectOrCreate?: performanceCreateOrConnectWithoutTeachersInput | performanceCreateOrConnectWithoutTeachersInput[]
    upsert?: performanceUpsertWithWhereUniqueWithoutTeachersInput | performanceUpsertWithWhereUniqueWithoutTeachersInput[]
    createMany?: performanceCreateManyTeachersInputEnvelope
    set?: performanceWhereUniqueInput | performanceWhereUniqueInput[]
    disconnect?: performanceWhereUniqueInput | performanceWhereUniqueInput[]
    delete?: performanceWhereUniqueInput | performanceWhereUniqueInput[]
    connect?: performanceWhereUniqueInput | performanceWhereUniqueInput[]
    update?: performanceUpdateWithWhereUniqueWithoutTeachersInput | performanceUpdateWithWhereUniqueWithoutTeachersInput[]
    updateMany?: performanceUpdateManyWithWhereWithoutTeachersInput | performanceUpdateManyWithWhereWithoutTeachersInput[]
    deleteMany?: performanceScalarWhereInput | performanceScalarWhereInput[]
  }

  export type student_routineUncheckedUpdateManyWithoutTeachersNestedInput = {
    create?: XOR<student_routineCreateWithoutTeachersInput, student_routineUncheckedCreateWithoutTeachersInput> | student_routineCreateWithoutTeachersInput[] | student_routineUncheckedCreateWithoutTeachersInput[]
    connectOrCreate?: student_routineCreateOrConnectWithoutTeachersInput | student_routineCreateOrConnectWithoutTeachersInput[]
    upsert?: student_routineUpsertWithWhereUniqueWithoutTeachersInput | student_routineUpsertWithWhereUniqueWithoutTeachersInput[]
    createMany?: student_routineCreateManyTeachersInputEnvelope
    set?: student_routineWhereUniqueInput | student_routineWhereUniqueInput[]
    disconnect?: student_routineWhereUniqueInput | student_routineWhereUniqueInput[]
    delete?: student_routineWhereUniqueInput | student_routineWhereUniqueInput[]
    connect?: student_routineWhereUniqueInput | student_routineWhereUniqueInput[]
    update?: student_routineUpdateWithWhereUniqueWithoutTeachersInput | student_routineUpdateWithWhereUniqueWithoutTeachersInput[]
    updateMany?: student_routineUpdateManyWithWhereWithoutTeachersInput | student_routineUpdateManyWithWhereWithoutTeachersInput[]
    deleteMany?: student_routineScalarWhereInput | student_routineScalarWhereInput[]
  }

  export type calendarCreateNestedOneWithoutUpcoming_eventsInput = {
    create?: XOR<calendarCreateWithoutUpcoming_eventsInput, calendarUncheckedCreateWithoutUpcoming_eventsInput>
    connectOrCreate?: calendarCreateOrConnectWithoutUpcoming_eventsInput
    connect?: calendarWhereUniqueInput
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type calendarUpdateOneWithoutUpcoming_eventsNestedInput = {
    create?: XOR<calendarCreateWithoutUpcoming_eventsInput, calendarUncheckedCreateWithoutUpcoming_eventsInput>
    connectOrCreate?: calendarCreateOrConnectWithoutUpcoming_eventsInput
    upsert?: calendarUpsertWithoutUpcoming_eventsInput
    disconnect?: calendarWhereInput | boolean
    delete?: calendarWhereInput | boolean
    connect?: calendarWhereUniqueInput
    update?: XOR<XOR<calendarUpdateToOneWithWhereWithoutUpcoming_eventsInput, calendarUpdateWithoutUpcoming_eventsInput>, calendarUncheckedUpdateWithoutUpcoming_eventsInput>
  }

  export type notesCreateNestedManyWithoutUsersInput = {
    create?: XOR<notesCreateWithoutUsersInput, notesUncheckedCreateWithoutUsersInput> | notesCreateWithoutUsersInput[] | notesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: notesCreateOrConnectWithoutUsersInput | notesCreateOrConnectWithoutUsersInput[]
    createMany?: notesCreateManyUsersInputEnvelope
    connect?: notesWhereUniqueInput | notesWhereUniqueInput[]
  }

  export type noticesCreateNestedManyWithoutUsersInput = {
    create?: XOR<noticesCreateWithoutUsersInput, noticesUncheckedCreateWithoutUsersInput> | noticesCreateWithoutUsersInput[] | noticesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: noticesCreateOrConnectWithoutUsersInput | noticesCreateOrConnectWithoutUsersInput[]
    createMany?: noticesCreateManyUsersInputEnvelope
    connect?: noticesWhereUniqueInput | noticesWhereUniqueInput[]
  }

  export type studentsCreateNestedManyWithoutUsersInput = {
    create?: XOR<studentsCreateWithoutUsersInput, studentsUncheckedCreateWithoutUsersInput> | studentsCreateWithoutUsersInput[] | studentsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: studentsCreateOrConnectWithoutUsersInput | studentsCreateOrConnectWithoutUsersInput[]
    createMany?: studentsCreateManyUsersInputEnvelope
    connect?: studentsWhereUniqueInput | studentsWhereUniqueInput[]
  }

  export type teacher_routineCreateNestedManyWithoutUsersInput = {
    create?: XOR<teacher_routineCreateWithoutUsersInput, teacher_routineUncheckedCreateWithoutUsersInput> | teacher_routineCreateWithoutUsersInput[] | teacher_routineUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: teacher_routineCreateOrConnectWithoutUsersInput | teacher_routineCreateOrConnectWithoutUsersInput[]
    createMany?: teacher_routineCreateManyUsersInputEnvelope
    connect?: teacher_routineWhereUniqueInput | teacher_routineWhereUniqueInput[]
  }

  export type teachersCreateNestedManyWithoutUsersInput = {
    create?: XOR<teachersCreateWithoutUsersInput, teachersUncheckedCreateWithoutUsersInput> | teachersCreateWithoutUsersInput[] | teachersUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: teachersCreateOrConnectWithoutUsersInput | teachersCreateOrConnectWithoutUsersInput[]
    createMany?: teachersCreateManyUsersInputEnvelope
    connect?: teachersWhereUniqueInput | teachersWhereUniqueInput[]
  }

  export type workroom_messagesCreateNestedManyWithoutUsers_workroom_messages_receiver_idTousersInput = {
    create?: XOR<workroom_messagesCreateWithoutUsers_workroom_messages_receiver_idTousersInput, workroom_messagesUncheckedCreateWithoutUsers_workroom_messages_receiver_idTousersInput> | workroom_messagesCreateWithoutUsers_workroom_messages_receiver_idTousersInput[] | workroom_messagesUncheckedCreateWithoutUsers_workroom_messages_receiver_idTousersInput[]
    connectOrCreate?: workroom_messagesCreateOrConnectWithoutUsers_workroom_messages_receiver_idTousersInput | workroom_messagesCreateOrConnectWithoutUsers_workroom_messages_receiver_idTousersInput[]
    createMany?: workroom_messagesCreateManyUsers_workroom_messages_receiver_idTousersInputEnvelope
    connect?: workroom_messagesWhereUniqueInput | workroom_messagesWhereUniqueInput[]
  }

  export type workroom_messagesCreateNestedManyWithoutUsers_workroom_messages_sender_idTousersInput = {
    create?: XOR<workroom_messagesCreateWithoutUsers_workroom_messages_sender_idTousersInput, workroom_messagesUncheckedCreateWithoutUsers_workroom_messages_sender_idTousersInput> | workroom_messagesCreateWithoutUsers_workroom_messages_sender_idTousersInput[] | workroom_messagesUncheckedCreateWithoutUsers_workroom_messages_sender_idTousersInput[]
    connectOrCreate?: workroom_messagesCreateOrConnectWithoutUsers_workroom_messages_sender_idTousersInput | workroom_messagesCreateOrConnectWithoutUsers_workroom_messages_sender_idTousersInput[]
    createMany?: workroom_messagesCreateManyUsers_workroom_messages_sender_idTousersInputEnvelope
    connect?: workroom_messagesWhereUniqueInput | workroom_messagesWhereUniqueInput[]
  }

  export type notesUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<notesCreateWithoutUsersInput, notesUncheckedCreateWithoutUsersInput> | notesCreateWithoutUsersInput[] | notesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: notesCreateOrConnectWithoutUsersInput | notesCreateOrConnectWithoutUsersInput[]
    createMany?: notesCreateManyUsersInputEnvelope
    connect?: notesWhereUniqueInput | notesWhereUniqueInput[]
  }

  export type noticesUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<noticesCreateWithoutUsersInput, noticesUncheckedCreateWithoutUsersInput> | noticesCreateWithoutUsersInput[] | noticesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: noticesCreateOrConnectWithoutUsersInput | noticesCreateOrConnectWithoutUsersInput[]
    createMany?: noticesCreateManyUsersInputEnvelope
    connect?: noticesWhereUniqueInput | noticesWhereUniqueInput[]
  }

  export type studentsUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<studentsCreateWithoutUsersInput, studentsUncheckedCreateWithoutUsersInput> | studentsCreateWithoutUsersInput[] | studentsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: studentsCreateOrConnectWithoutUsersInput | studentsCreateOrConnectWithoutUsersInput[]
    createMany?: studentsCreateManyUsersInputEnvelope
    connect?: studentsWhereUniqueInput | studentsWhereUniqueInput[]
  }

  export type teacher_routineUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<teacher_routineCreateWithoutUsersInput, teacher_routineUncheckedCreateWithoutUsersInput> | teacher_routineCreateWithoutUsersInput[] | teacher_routineUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: teacher_routineCreateOrConnectWithoutUsersInput | teacher_routineCreateOrConnectWithoutUsersInput[]
    createMany?: teacher_routineCreateManyUsersInputEnvelope
    connect?: teacher_routineWhereUniqueInput | teacher_routineWhereUniqueInput[]
  }

  export type teachersUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<teachersCreateWithoutUsersInput, teachersUncheckedCreateWithoutUsersInput> | teachersCreateWithoutUsersInput[] | teachersUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: teachersCreateOrConnectWithoutUsersInput | teachersCreateOrConnectWithoutUsersInput[]
    createMany?: teachersCreateManyUsersInputEnvelope
    connect?: teachersWhereUniqueInput | teachersWhereUniqueInput[]
  }

  export type workroom_messagesUncheckedCreateNestedManyWithoutUsers_workroom_messages_receiver_idTousersInput = {
    create?: XOR<workroom_messagesCreateWithoutUsers_workroom_messages_receiver_idTousersInput, workroom_messagesUncheckedCreateWithoutUsers_workroom_messages_receiver_idTousersInput> | workroom_messagesCreateWithoutUsers_workroom_messages_receiver_idTousersInput[] | workroom_messagesUncheckedCreateWithoutUsers_workroom_messages_receiver_idTousersInput[]
    connectOrCreate?: workroom_messagesCreateOrConnectWithoutUsers_workroom_messages_receiver_idTousersInput | workroom_messagesCreateOrConnectWithoutUsers_workroom_messages_receiver_idTousersInput[]
    createMany?: workroom_messagesCreateManyUsers_workroom_messages_receiver_idTousersInputEnvelope
    connect?: workroom_messagesWhereUniqueInput | workroom_messagesWhereUniqueInput[]
  }

  export type workroom_messagesUncheckedCreateNestedManyWithoutUsers_workroom_messages_sender_idTousersInput = {
    create?: XOR<workroom_messagesCreateWithoutUsers_workroom_messages_sender_idTousersInput, workroom_messagesUncheckedCreateWithoutUsers_workroom_messages_sender_idTousersInput> | workroom_messagesCreateWithoutUsers_workroom_messages_sender_idTousersInput[] | workroom_messagesUncheckedCreateWithoutUsers_workroom_messages_sender_idTousersInput[]
    connectOrCreate?: workroom_messagesCreateOrConnectWithoutUsers_workroom_messages_sender_idTousersInput | workroom_messagesCreateOrConnectWithoutUsers_workroom_messages_sender_idTousersInput[]
    createMany?: workroom_messagesCreateManyUsers_workroom_messages_sender_idTousersInputEnvelope
    connect?: workroom_messagesWhereUniqueInput | workroom_messagesWhereUniqueInput[]
  }

  export type notesUpdateManyWithoutUsersNestedInput = {
    create?: XOR<notesCreateWithoutUsersInput, notesUncheckedCreateWithoutUsersInput> | notesCreateWithoutUsersInput[] | notesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: notesCreateOrConnectWithoutUsersInput | notesCreateOrConnectWithoutUsersInput[]
    upsert?: notesUpsertWithWhereUniqueWithoutUsersInput | notesUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: notesCreateManyUsersInputEnvelope
    set?: notesWhereUniqueInput | notesWhereUniqueInput[]
    disconnect?: notesWhereUniqueInput | notesWhereUniqueInput[]
    delete?: notesWhereUniqueInput | notesWhereUniqueInput[]
    connect?: notesWhereUniqueInput | notesWhereUniqueInput[]
    update?: notesUpdateWithWhereUniqueWithoutUsersInput | notesUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: notesUpdateManyWithWhereWithoutUsersInput | notesUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: notesScalarWhereInput | notesScalarWhereInput[]
  }

  export type noticesUpdateManyWithoutUsersNestedInput = {
    create?: XOR<noticesCreateWithoutUsersInput, noticesUncheckedCreateWithoutUsersInput> | noticesCreateWithoutUsersInput[] | noticesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: noticesCreateOrConnectWithoutUsersInput | noticesCreateOrConnectWithoutUsersInput[]
    upsert?: noticesUpsertWithWhereUniqueWithoutUsersInput | noticesUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: noticesCreateManyUsersInputEnvelope
    set?: noticesWhereUniqueInput | noticesWhereUniqueInput[]
    disconnect?: noticesWhereUniqueInput | noticesWhereUniqueInput[]
    delete?: noticesWhereUniqueInput | noticesWhereUniqueInput[]
    connect?: noticesWhereUniqueInput | noticesWhereUniqueInput[]
    update?: noticesUpdateWithWhereUniqueWithoutUsersInput | noticesUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: noticesUpdateManyWithWhereWithoutUsersInput | noticesUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: noticesScalarWhereInput | noticesScalarWhereInput[]
  }

  export type studentsUpdateManyWithoutUsersNestedInput = {
    create?: XOR<studentsCreateWithoutUsersInput, studentsUncheckedCreateWithoutUsersInput> | studentsCreateWithoutUsersInput[] | studentsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: studentsCreateOrConnectWithoutUsersInput | studentsCreateOrConnectWithoutUsersInput[]
    upsert?: studentsUpsertWithWhereUniqueWithoutUsersInput | studentsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: studentsCreateManyUsersInputEnvelope
    set?: studentsWhereUniqueInput | studentsWhereUniqueInput[]
    disconnect?: studentsWhereUniqueInput | studentsWhereUniqueInput[]
    delete?: studentsWhereUniqueInput | studentsWhereUniqueInput[]
    connect?: studentsWhereUniqueInput | studentsWhereUniqueInput[]
    update?: studentsUpdateWithWhereUniqueWithoutUsersInput | studentsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: studentsUpdateManyWithWhereWithoutUsersInput | studentsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: studentsScalarWhereInput | studentsScalarWhereInput[]
  }

  export type teacher_routineUpdateManyWithoutUsersNestedInput = {
    create?: XOR<teacher_routineCreateWithoutUsersInput, teacher_routineUncheckedCreateWithoutUsersInput> | teacher_routineCreateWithoutUsersInput[] | teacher_routineUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: teacher_routineCreateOrConnectWithoutUsersInput | teacher_routineCreateOrConnectWithoutUsersInput[]
    upsert?: teacher_routineUpsertWithWhereUniqueWithoutUsersInput | teacher_routineUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: teacher_routineCreateManyUsersInputEnvelope
    set?: teacher_routineWhereUniqueInput | teacher_routineWhereUniqueInput[]
    disconnect?: teacher_routineWhereUniqueInput | teacher_routineWhereUniqueInput[]
    delete?: teacher_routineWhereUniqueInput | teacher_routineWhereUniqueInput[]
    connect?: teacher_routineWhereUniqueInput | teacher_routineWhereUniqueInput[]
    update?: teacher_routineUpdateWithWhereUniqueWithoutUsersInput | teacher_routineUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: teacher_routineUpdateManyWithWhereWithoutUsersInput | teacher_routineUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: teacher_routineScalarWhereInput | teacher_routineScalarWhereInput[]
  }

  export type teachersUpdateManyWithoutUsersNestedInput = {
    create?: XOR<teachersCreateWithoutUsersInput, teachersUncheckedCreateWithoutUsersInput> | teachersCreateWithoutUsersInput[] | teachersUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: teachersCreateOrConnectWithoutUsersInput | teachersCreateOrConnectWithoutUsersInput[]
    upsert?: teachersUpsertWithWhereUniqueWithoutUsersInput | teachersUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: teachersCreateManyUsersInputEnvelope
    set?: teachersWhereUniqueInput | teachersWhereUniqueInput[]
    disconnect?: teachersWhereUniqueInput | teachersWhereUniqueInput[]
    delete?: teachersWhereUniqueInput | teachersWhereUniqueInput[]
    connect?: teachersWhereUniqueInput | teachersWhereUniqueInput[]
    update?: teachersUpdateWithWhereUniqueWithoutUsersInput | teachersUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: teachersUpdateManyWithWhereWithoutUsersInput | teachersUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: teachersScalarWhereInput | teachersScalarWhereInput[]
  }

  export type workroom_messagesUpdateManyWithoutUsers_workroom_messages_receiver_idTousersNestedInput = {
    create?: XOR<workroom_messagesCreateWithoutUsers_workroom_messages_receiver_idTousersInput, workroom_messagesUncheckedCreateWithoutUsers_workroom_messages_receiver_idTousersInput> | workroom_messagesCreateWithoutUsers_workroom_messages_receiver_idTousersInput[] | workroom_messagesUncheckedCreateWithoutUsers_workroom_messages_receiver_idTousersInput[]
    connectOrCreate?: workroom_messagesCreateOrConnectWithoutUsers_workroom_messages_receiver_idTousersInput | workroom_messagesCreateOrConnectWithoutUsers_workroom_messages_receiver_idTousersInput[]
    upsert?: workroom_messagesUpsertWithWhereUniqueWithoutUsers_workroom_messages_receiver_idTousersInput | workroom_messagesUpsertWithWhereUniqueWithoutUsers_workroom_messages_receiver_idTousersInput[]
    createMany?: workroom_messagesCreateManyUsers_workroom_messages_receiver_idTousersInputEnvelope
    set?: workroom_messagesWhereUniqueInput | workroom_messagesWhereUniqueInput[]
    disconnect?: workroom_messagesWhereUniqueInput | workroom_messagesWhereUniqueInput[]
    delete?: workroom_messagesWhereUniqueInput | workroom_messagesWhereUniqueInput[]
    connect?: workroom_messagesWhereUniqueInput | workroom_messagesWhereUniqueInput[]
    update?: workroom_messagesUpdateWithWhereUniqueWithoutUsers_workroom_messages_receiver_idTousersInput | workroom_messagesUpdateWithWhereUniqueWithoutUsers_workroom_messages_receiver_idTousersInput[]
    updateMany?: workroom_messagesUpdateManyWithWhereWithoutUsers_workroom_messages_receiver_idTousersInput | workroom_messagesUpdateManyWithWhereWithoutUsers_workroom_messages_receiver_idTousersInput[]
    deleteMany?: workroom_messagesScalarWhereInput | workroom_messagesScalarWhereInput[]
  }

  export type workroom_messagesUpdateManyWithoutUsers_workroom_messages_sender_idTousersNestedInput = {
    create?: XOR<workroom_messagesCreateWithoutUsers_workroom_messages_sender_idTousersInput, workroom_messagesUncheckedCreateWithoutUsers_workroom_messages_sender_idTousersInput> | workroom_messagesCreateWithoutUsers_workroom_messages_sender_idTousersInput[] | workroom_messagesUncheckedCreateWithoutUsers_workroom_messages_sender_idTousersInput[]
    connectOrCreate?: workroom_messagesCreateOrConnectWithoutUsers_workroom_messages_sender_idTousersInput | workroom_messagesCreateOrConnectWithoutUsers_workroom_messages_sender_idTousersInput[]
    upsert?: workroom_messagesUpsertWithWhereUniqueWithoutUsers_workroom_messages_sender_idTousersInput | workroom_messagesUpsertWithWhereUniqueWithoutUsers_workroom_messages_sender_idTousersInput[]
    createMany?: workroom_messagesCreateManyUsers_workroom_messages_sender_idTousersInputEnvelope
    set?: workroom_messagesWhereUniqueInput | workroom_messagesWhereUniqueInput[]
    disconnect?: workroom_messagesWhereUniqueInput | workroom_messagesWhereUniqueInput[]
    delete?: workroom_messagesWhereUniqueInput | workroom_messagesWhereUniqueInput[]
    connect?: workroom_messagesWhereUniqueInput | workroom_messagesWhereUniqueInput[]
    update?: workroom_messagesUpdateWithWhereUniqueWithoutUsers_workroom_messages_sender_idTousersInput | workroom_messagesUpdateWithWhereUniqueWithoutUsers_workroom_messages_sender_idTousersInput[]
    updateMany?: workroom_messagesUpdateManyWithWhereWithoutUsers_workroom_messages_sender_idTousersInput | workroom_messagesUpdateManyWithWhereWithoutUsers_workroom_messages_sender_idTousersInput[]
    deleteMany?: workroom_messagesScalarWhereInput | workroom_messagesScalarWhereInput[]
  }

  export type notesUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<notesCreateWithoutUsersInput, notesUncheckedCreateWithoutUsersInput> | notesCreateWithoutUsersInput[] | notesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: notesCreateOrConnectWithoutUsersInput | notesCreateOrConnectWithoutUsersInput[]
    upsert?: notesUpsertWithWhereUniqueWithoutUsersInput | notesUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: notesCreateManyUsersInputEnvelope
    set?: notesWhereUniqueInput | notesWhereUniqueInput[]
    disconnect?: notesWhereUniqueInput | notesWhereUniqueInput[]
    delete?: notesWhereUniqueInput | notesWhereUniqueInput[]
    connect?: notesWhereUniqueInput | notesWhereUniqueInput[]
    update?: notesUpdateWithWhereUniqueWithoutUsersInput | notesUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: notesUpdateManyWithWhereWithoutUsersInput | notesUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: notesScalarWhereInput | notesScalarWhereInput[]
  }

  export type noticesUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<noticesCreateWithoutUsersInput, noticesUncheckedCreateWithoutUsersInput> | noticesCreateWithoutUsersInput[] | noticesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: noticesCreateOrConnectWithoutUsersInput | noticesCreateOrConnectWithoutUsersInput[]
    upsert?: noticesUpsertWithWhereUniqueWithoutUsersInput | noticesUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: noticesCreateManyUsersInputEnvelope
    set?: noticesWhereUniqueInput | noticesWhereUniqueInput[]
    disconnect?: noticesWhereUniqueInput | noticesWhereUniqueInput[]
    delete?: noticesWhereUniqueInput | noticesWhereUniqueInput[]
    connect?: noticesWhereUniqueInput | noticesWhereUniqueInput[]
    update?: noticesUpdateWithWhereUniqueWithoutUsersInput | noticesUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: noticesUpdateManyWithWhereWithoutUsersInput | noticesUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: noticesScalarWhereInput | noticesScalarWhereInput[]
  }

  export type studentsUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<studentsCreateWithoutUsersInput, studentsUncheckedCreateWithoutUsersInput> | studentsCreateWithoutUsersInput[] | studentsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: studentsCreateOrConnectWithoutUsersInput | studentsCreateOrConnectWithoutUsersInput[]
    upsert?: studentsUpsertWithWhereUniqueWithoutUsersInput | studentsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: studentsCreateManyUsersInputEnvelope
    set?: studentsWhereUniqueInput | studentsWhereUniqueInput[]
    disconnect?: studentsWhereUniqueInput | studentsWhereUniqueInput[]
    delete?: studentsWhereUniqueInput | studentsWhereUniqueInput[]
    connect?: studentsWhereUniqueInput | studentsWhereUniqueInput[]
    update?: studentsUpdateWithWhereUniqueWithoutUsersInput | studentsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: studentsUpdateManyWithWhereWithoutUsersInput | studentsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: studentsScalarWhereInput | studentsScalarWhereInput[]
  }

  export type teacher_routineUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<teacher_routineCreateWithoutUsersInput, teacher_routineUncheckedCreateWithoutUsersInput> | teacher_routineCreateWithoutUsersInput[] | teacher_routineUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: teacher_routineCreateOrConnectWithoutUsersInput | teacher_routineCreateOrConnectWithoutUsersInput[]
    upsert?: teacher_routineUpsertWithWhereUniqueWithoutUsersInput | teacher_routineUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: teacher_routineCreateManyUsersInputEnvelope
    set?: teacher_routineWhereUniqueInput | teacher_routineWhereUniqueInput[]
    disconnect?: teacher_routineWhereUniqueInput | teacher_routineWhereUniqueInput[]
    delete?: teacher_routineWhereUniqueInput | teacher_routineWhereUniqueInput[]
    connect?: teacher_routineWhereUniqueInput | teacher_routineWhereUniqueInput[]
    update?: teacher_routineUpdateWithWhereUniqueWithoutUsersInput | teacher_routineUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: teacher_routineUpdateManyWithWhereWithoutUsersInput | teacher_routineUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: teacher_routineScalarWhereInput | teacher_routineScalarWhereInput[]
  }

  export type teachersUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<teachersCreateWithoutUsersInput, teachersUncheckedCreateWithoutUsersInput> | teachersCreateWithoutUsersInput[] | teachersUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: teachersCreateOrConnectWithoutUsersInput | teachersCreateOrConnectWithoutUsersInput[]
    upsert?: teachersUpsertWithWhereUniqueWithoutUsersInput | teachersUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: teachersCreateManyUsersInputEnvelope
    set?: teachersWhereUniqueInput | teachersWhereUniqueInput[]
    disconnect?: teachersWhereUniqueInput | teachersWhereUniqueInput[]
    delete?: teachersWhereUniqueInput | teachersWhereUniqueInput[]
    connect?: teachersWhereUniqueInput | teachersWhereUniqueInput[]
    update?: teachersUpdateWithWhereUniqueWithoutUsersInput | teachersUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: teachersUpdateManyWithWhereWithoutUsersInput | teachersUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: teachersScalarWhereInput | teachersScalarWhereInput[]
  }

  export type workroom_messagesUncheckedUpdateManyWithoutUsers_workroom_messages_receiver_idTousersNestedInput = {
    create?: XOR<workroom_messagesCreateWithoutUsers_workroom_messages_receiver_idTousersInput, workroom_messagesUncheckedCreateWithoutUsers_workroom_messages_receiver_idTousersInput> | workroom_messagesCreateWithoutUsers_workroom_messages_receiver_idTousersInput[] | workroom_messagesUncheckedCreateWithoutUsers_workroom_messages_receiver_idTousersInput[]
    connectOrCreate?: workroom_messagesCreateOrConnectWithoutUsers_workroom_messages_receiver_idTousersInput | workroom_messagesCreateOrConnectWithoutUsers_workroom_messages_receiver_idTousersInput[]
    upsert?: workroom_messagesUpsertWithWhereUniqueWithoutUsers_workroom_messages_receiver_idTousersInput | workroom_messagesUpsertWithWhereUniqueWithoutUsers_workroom_messages_receiver_idTousersInput[]
    createMany?: workroom_messagesCreateManyUsers_workroom_messages_receiver_idTousersInputEnvelope
    set?: workroom_messagesWhereUniqueInput | workroom_messagesWhereUniqueInput[]
    disconnect?: workroom_messagesWhereUniqueInput | workroom_messagesWhereUniqueInput[]
    delete?: workroom_messagesWhereUniqueInput | workroom_messagesWhereUniqueInput[]
    connect?: workroom_messagesWhereUniqueInput | workroom_messagesWhereUniqueInput[]
    update?: workroom_messagesUpdateWithWhereUniqueWithoutUsers_workroom_messages_receiver_idTousersInput | workroom_messagesUpdateWithWhereUniqueWithoutUsers_workroom_messages_receiver_idTousersInput[]
    updateMany?: workroom_messagesUpdateManyWithWhereWithoutUsers_workroom_messages_receiver_idTousersInput | workroom_messagesUpdateManyWithWhereWithoutUsers_workroom_messages_receiver_idTousersInput[]
    deleteMany?: workroom_messagesScalarWhereInput | workroom_messagesScalarWhereInput[]
  }

  export type workroom_messagesUncheckedUpdateManyWithoutUsers_workroom_messages_sender_idTousersNestedInput = {
    create?: XOR<workroom_messagesCreateWithoutUsers_workroom_messages_sender_idTousersInput, workroom_messagesUncheckedCreateWithoutUsers_workroom_messages_sender_idTousersInput> | workroom_messagesCreateWithoutUsers_workroom_messages_sender_idTousersInput[] | workroom_messagesUncheckedCreateWithoutUsers_workroom_messages_sender_idTousersInput[]
    connectOrCreate?: workroom_messagesCreateOrConnectWithoutUsers_workroom_messages_sender_idTousersInput | workroom_messagesCreateOrConnectWithoutUsers_workroom_messages_sender_idTousersInput[]
    upsert?: workroom_messagesUpsertWithWhereUniqueWithoutUsers_workroom_messages_sender_idTousersInput | workroom_messagesUpsertWithWhereUniqueWithoutUsers_workroom_messages_sender_idTousersInput[]
    createMany?: workroom_messagesCreateManyUsers_workroom_messages_sender_idTousersInputEnvelope
    set?: workroom_messagesWhereUniqueInput | workroom_messagesWhereUniqueInput[]
    disconnect?: workroom_messagesWhereUniqueInput | workroom_messagesWhereUniqueInput[]
    delete?: workroom_messagesWhereUniqueInput | workroom_messagesWhereUniqueInput[]
    connect?: workroom_messagesWhereUniqueInput | workroom_messagesWhereUniqueInput[]
    update?: workroom_messagesUpdateWithWhereUniqueWithoutUsers_workroom_messages_sender_idTousersInput | workroom_messagesUpdateWithWhereUniqueWithoutUsers_workroom_messages_sender_idTousersInput[]
    updateMany?: workroom_messagesUpdateManyWithWhereWithoutUsers_workroom_messages_sender_idTousersInput | workroom_messagesUpdateManyWithWhereWithoutUsers_workroom_messages_sender_idTousersInput[]
    deleteMany?: workroom_messagesScalarWhereInput | workroom_messagesScalarWhereInput[]
  }

  export type usersCreateNestedOneWithoutWorkroom_messages_workroom_messages_receiver_idTousersInput = {
    create?: XOR<usersCreateWithoutWorkroom_messages_workroom_messages_receiver_idTousersInput, usersUncheckedCreateWithoutWorkroom_messages_workroom_messages_receiver_idTousersInput>
    connectOrCreate?: usersCreateOrConnectWithoutWorkroom_messages_workroom_messages_receiver_idTousersInput
    connect?: usersWhereUniqueInput
  }

  export type usersCreateNestedOneWithoutWorkroom_messages_workroom_messages_sender_idTousersInput = {
    create?: XOR<usersCreateWithoutWorkroom_messages_workroom_messages_sender_idTousersInput, usersUncheckedCreateWithoutWorkroom_messages_workroom_messages_sender_idTousersInput>
    connectOrCreate?: usersCreateOrConnectWithoutWorkroom_messages_workroom_messages_sender_idTousersInput
    connect?: usersWhereUniqueInput
  }

  export type usersUpdateOneWithoutWorkroom_messages_workroom_messages_receiver_idTousersNestedInput = {
    create?: XOR<usersCreateWithoutWorkroom_messages_workroom_messages_receiver_idTousersInput, usersUncheckedCreateWithoutWorkroom_messages_workroom_messages_receiver_idTousersInput>
    connectOrCreate?: usersCreateOrConnectWithoutWorkroom_messages_workroom_messages_receiver_idTousersInput
    upsert?: usersUpsertWithoutWorkroom_messages_workroom_messages_receiver_idTousersInput
    disconnect?: usersWhereInput | boolean
    delete?: usersWhereInput | boolean
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutWorkroom_messages_workroom_messages_receiver_idTousersInput, usersUpdateWithoutWorkroom_messages_workroom_messages_receiver_idTousersInput>, usersUncheckedUpdateWithoutWorkroom_messages_workroom_messages_receiver_idTousersInput>
  }

  export type usersUpdateOneWithoutWorkroom_messages_workroom_messages_sender_idTousersNestedInput = {
    create?: XOR<usersCreateWithoutWorkroom_messages_workroom_messages_sender_idTousersInput, usersUncheckedCreateWithoutWorkroom_messages_workroom_messages_sender_idTousersInput>
    connectOrCreate?: usersCreateOrConnectWithoutWorkroom_messages_workroom_messages_sender_idTousersInput
    upsert?: usersUpsertWithoutWorkroom_messages_workroom_messages_sender_idTousersInput
    disconnect?: usersWhereInput | boolean
    delete?: usersWhereInput | boolean
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutWorkroom_messages_workroom_messages_sender_idTousersInput, usersUpdateWithoutWorkroom_messages_workroom_messages_sender_idTousersInput>, usersUncheckedUpdateWithoutWorkroom_messages_workroom_messages_sender_idTousersInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type teachersCreateWithoutAssignmentsInput = {
    specialised_subject: string
    assigned_class?: string | null
    assigned_section?: string | null
    attendance?: attendanceCreateNestedManyWithoutTeachersInput
    class_routine?: class_routineCreateNestedManyWithoutTeachersInput
    class_teachers?: class_teachersCreateNestedManyWithoutTeachersInput
    exams?: examsCreateNestedManyWithoutTeachersInput
    performance?: performanceCreateNestedManyWithoutTeachersInput
    student_routine?: student_routineCreateNestedManyWithoutTeachersInput
    users?: usersCreateNestedOneWithoutTeachersInput
  }

  export type teachersUncheckedCreateWithoutAssignmentsInput = {
    id?: number
    user_id?: number | null
    specialised_subject: string
    assigned_class?: string | null
    assigned_section?: string | null
    attendance?: attendanceUncheckedCreateNestedManyWithoutTeachersInput
    class_routine?: class_routineUncheckedCreateNestedManyWithoutTeachersInput
    class_teachers?: class_teachersUncheckedCreateNestedManyWithoutTeachersInput
    exams?: examsUncheckedCreateNestedManyWithoutTeachersInput
    performance?: performanceUncheckedCreateNestedManyWithoutTeachersInput
    student_routine?: student_routineUncheckedCreateNestedManyWithoutTeachersInput
  }

  export type teachersCreateOrConnectWithoutAssignmentsInput = {
    where: teachersWhereUniqueInput
    create: XOR<teachersCreateWithoutAssignmentsInput, teachersUncheckedCreateWithoutAssignmentsInput>
  }

  export type teachersUpsertWithoutAssignmentsInput = {
    update: XOR<teachersUpdateWithoutAssignmentsInput, teachersUncheckedUpdateWithoutAssignmentsInput>
    create: XOR<teachersCreateWithoutAssignmentsInput, teachersUncheckedCreateWithoutAssignmentsInput>
    where?: teachersWhereInput
  }

  export type teachersUpdateToOneWithWhereWithoutAssignmentsInput = {
    where?: teachersWhereInput
    data: XOR<teachersUpdateWithoutAssignmentsInput, teachersUncheckedUpdateWithoutAssignmentsInput>
  }

  export type teachersUpdateWithoutAssignmentsInput = {
    specialised_subject?: StringFieldUpdateOperationsInput | string
    assigned_class?: NullableStringFieldUpdateOperationsInput | string | null
    assigned_section?: NullableStringFieldUpdateOperationsInput | string | null
    attendance?: attendanceUpdateManyWithoutTeachersNestedInput
    class_routine?: class_routineUpdateManyWithoutTeachersNestedInput
    class_teachers?: class_teachersUpdateManyWithoutTeachersNestedInput
    exams?: examsUpdateManyWithoutTeachersNestedInput
    performance?: performanceUpdateManyWithoutTeachersNestedInput
    student_routine?: student_routineUpdateManyWithoutTeachersNestedInput
    users?: usersUpdateOneWithoutTeachersNestedInput
  }

  export type teachersUncheckedUpdateWithoutAssignmentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    specialised_subject?: StringFieldUpdateOperationsInput | string
    assigned_class?: NullableStringFieldUpdateOperationsInput | string | null
    assigned_section?: NullableStringFieldUpdateOperationsInput | string | null
    attendance?: attendanceUncheckedUpdateManyWithoutTeachersNestedInput
    class_routine?: class_routineUncheckedUpdateManyWithoutTeachersNestedInput
    class_teachers?: class_teachersUncheckedUpdateManyWithoutTeachersNestedInput
    exams?: examsUncheckedUpdateManyWithoutTeachersNestedInput
    performance?: performanceUncheckedUpdateManyWithoutTeachersNestedInput
    student_routine?: student_routineUncheckedUpdateManyWithoutTeachersNestedInput
  }

  export type studentsCreateWithoutAttendanceInput = {
    admission_number: string
    class: string
    section: string
    parent_name?: string | null
    parent_phone?: string | null
    parent_email?: string | null
    parent_work?: string | null
    parent_photo1?: string | null
    parent_photo2?: string | null
    guardian_photo?: string | null
    guardian_phone?: string | null
    roll_number?: number | null
    class_representatives?: class_representativesCreateNestedManyWithoutStudentsInput
    class_teachers?: class_teachersCreateNestedManyWithoutStudentsInput
    finances?: financesCreateNestedManyWithoutStudentsInput
    student_performance?: student_performanceCreateNestedManyWithoutStudentsInput
    users?: usersCreateNestedOneWithoutStudentsInput
  }

  export type studentsUncheckedCreateWithoutAttendanceInput = {
    id?: number
    user_id?: number | null
    admission_number: string
    class: string
    section: string
    parent_name?: string | null
    parent_phone?: string | null
    parent_email?: string | null
    parent_work?: string | null
    parent_photo1?: string | null
    parent_photo2?: string | null
    guardian_photo?: string | null
    guardian_phone?: string | null
    roll_number?: number | null
    class_representatives?: class_representativesUncheckedCreateNestedManyWithoutStudentsInput
    class_teachers?: class_teachersUncheckedCreateNestedManyWithoutStudentsInput
    finances?: financesUncheckedCreateNestedManyWithoutStudentsInput
    student_performance?: student_performanceUncheckedCreateNestedManyWithoutStudentsInput
  }

  export type studentsCreateOrConnectWithoutAttendanceInput = {
    where: studentsWhereUniqueInput
    create: XOR<studentsCreateWithoutAttendanceInput, studentsUncheckedCreateWithoutAttendanceInput>
  }

  export type teachersCreateWithoutAttendanceInput = {
    specialised_subject: string
    assigned_class?: string | null
    assigned_section?: string | null
    assignments?: assignmentsCreateNestedManyWithoutTeachersInput
    class_routine?: class_routineCreateNestedManyWithoutTeachersInput
    class_teachers?: class_teachersCreateNestedManyWithoutTeachersInput
    exams?: examsCreateNestedManyWithoutTeachersInput
    performance?: performanceCreateNestedManyWithoutTeachersInput
    student_routine?: student_routineCreateNestedManyWithoutTeachersInput
    users?: usersCreateNestedOneWithoutTeachersInput
  }

  export type teachersUncheckedCreateWithoutAttendanceInput = {
    id?: number
    user_id?: number | null
    specialised_subject: string
    assigned_class?: string | null
    assigned_section?: string | null
    assignments?: assignmentsUncheckedCreateNestedManyWithoutTeachersInput
    class_routine?: class_routineUncheckedCreateNestedManyWithoutTeachersInput
    class_teachers?: class_teachersUncheckedCreateNestedManyWithoutTeachersInput
    exams?: examsUncheckedCreateNestedManyWithoutTeachersInput
    performance?: performanceUncheckedCreateNestedManyWithoutTeachersInput
    student_routine?: student_routineUncheckedCreateNestedManyWithoutTeachersInput
  }

  export type teachersCreateOrConnectWithoutAttendanceInput = {
    where: teachersWhereUniqueInput
    create: XOR<teachersCreateWithoutAttendanceInput, teachersUncheckedCreateWithoutAttendanceInput>
  }

  export type studentsUpsertWithoutAttendanceInput = {
    update: XOR<studentsUpdateWithoutAttendanceInput, studentsUncheckedUpdateWithoutAttendanceInput>
    create: XOR<studentsCreateWithoutAttendanceInput, studentsUncheckedCreateWithoutAttendanceInput>
    where?: studentsWhereInput
  }

  export type studentsUpdateToOneWithWhereWithoutAttendanceInput = {
    where?: studentsWhereInput
    data: XOR<studentsUpdateWithoutAttendanceInput, studentsUncheckedUpdateWithoutAttendanceInput>
  }

  export type studentsUpdateWithoutAttendanceInput = {
    admission_number?: StringFieldUpdateOperationsInput | string
    class?: StringFieldUpdateOperationsInput | string
    section?: StringFieldUpdateOperationsInput | string
    parent_name?: NullableStringFieldUpdateOperationsInput | string | null
    parent_phone?: NullableStringFieldUpdateOperationsInput | string | null
    parent_email?: NullableStringFieldUpdateOperationsInput | string | null
    parent_work?: NullableStringFieldUpdateOperationsInput | string | null
    parent_photo1?: NullableStringFieldUpdateOperationsInput | string | null
    parent_photo2?: NullableStringFieldUpdateOperationsInput | string | null
    guardian_photo?: NullableStringFieldUpdateOperationsInput | string | null
    guardian_phone?: NullableStringFieldUpdateOperationsInput | string | null
    roll_number?: NullableIntFieldUpdateOperationsInput | number | null
    class_representatives?: class_representativesUpdateManyWithoutStudentsNestedInput
    class_teachers?: class_teachersUpdateManyWithoutStudentsNestedInput
    finances?: financesUpdateManyWithoutStudentsNestedInput
    student_performance?: student_performanceUpdateManyWithoutStudentsNestedInput
    users?: usersUpdateOneWithoutStudentsNestedInput
  }

  export type studentsUncheckedUpdateWithoutAttendanceInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    admission_number?: StringFieldUpdateOperationsInput | string
    class?: StringFieldUpdateOperationsInput | string
    section?: StringFieldUpdateOperationsInput | string
    parent_name?: NullableStringFieldUpdateOperationsInput | string | null
    parent_phone?: NullableStringFieldUpdateOperationsInput | string | null
    parent_email?: NullableStringFieldUpdateOperationsInput | string | null
    parent_work?: NullableStringFieldUpdateOperationsInput | string | null
    parent_photo1?: NullableStringFieldUpdateOperationsInput | string | null
    parent_photo2?: NullableStringFieldUpdateOperationsInput | string | null
    guardian_photo?: NullableStringFieldUpdateOperationsInput | string | null
    guardian_phone?: NullableStringFieldUpdateOperationsInput | string | null
    roll_number?: NullableIntFieldUpdateOperationsInput | number | null
    class_representatives?: class_representativesUncheckedUpdateManyWithoutStudentsNestedInput
    class_teachers?: class_teachersUncheckedUpdateManyWithoutStudentsNestedInput
    finances?: financesUncheckedUpdateManyWithoutStudentsNestedInput
    student_performance?: student_performanceUncheckedUpdateManyWithoutStudentsNestedInput
  }

  export type teachersUpsertWithoutAttendanceInput = {
    update: XOR<teachersUpdateWithoutAttendanceInput, teachersUncheckedUpdateWithoutAttendanceInput>
    create: XOR<teachersCreateWithoutAttendanceInput, teachersUncheckedCreateWithoutAttendanceInput>
    where?: teachersWhereInput
  }

  export type teachersUpdateToOneWithWhereWithoutAttendanceInput = {
    where?: teachersWhereInput
    data: XOR<teachersUpdateWithoutAttendanceInput, teachersUncheckedUpdateWithoutAttendanceInput>
  }

  export type teachersUpdateWithoutAttendanceInput = {
    specialised_subject?: StringFieldUpdateOperationsInput | string
    assigned_class?: NullableStringFieldUpdateOperationsInput | string | null
    assigned_section?: NullableStringFieldUpdateOperationsInput | string | null
    assignments?: assignmentsUpdateManyWithoutTeachersNestedInput
    class_routine?: class_routineUpdateManyWithoutTeachersNestedInput
    class_teachers?: class_teachersUpdateManyWithoutTeachersNestedInput
    exams?: examsUpdateManyWithoutTeachersNestedInput
    performance?: performanceUpdateManyWithoutTeachersNestedInput
    student_routine?: student_routineUpdateManyWithoutTeachersNestedInput
    users?: usersUpdateOneWithoutTeachersNestedInput
  }

  export type teachersUncheckedUpdateWithoutAttendanceInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    specialised_subject?: StringFieldUpdateOperationsInput | string
    assigned_class?: NullableStringFieldUpdateOperationsInput | string | null
    assigned_section?: NullableStringFieldUpdateOperationsInput | string | null
    assignments?: assignmentsUncheckedUpdateManyWithoutTeachersNestedInput
    class_routine?: class_routineUncheckedUpdateManyWithoutTeachersNestedInput
    class_teachers?: class_teachersUncheckedUpdateManyWithoutTeachersNestedInput
    exams?: examsUncheckedUpdateManyWithoutTeachersNestedInput
    performance?: performanceUncheckedUpdateManyWithoutTeachersNestedInput
    student_routine?: student_routineUncheckedUpdateManyWithoutTeachersNestedInput
  }

  export type upcoming_eventsCreateWithoutCalendarInput = {
    event_date: Date | string
    event_name: string
    holiday: boolean
  }

  export type upcoming_eventsUncheckedCreateWithoutCalendarInput = {
    id?: number
    event_date: Date | string
    event_name: string
    holiday: boolean
  }

  export type upcoming_eventsCreateOrConnectWithoutCalendarInput = {
    where: upcoming_eventsWhereUniqueInput
    create: XOR<upcoming_eventsCreateWithoutCalendarInput, upcoming_eventsUncheckedCreateWithoutCalendarInput>
  }

  export type upcoming_eventsCreateManyCalendarInputEnvelope = {
    data: upcoming_eventsCreateManyCalendarInput | upcoming_eventsCreateManyCalendarInput[]
    skipDuplicates?: boolean
  }

  export type upcoming_eventsUpsertWithWhereUniqueWithoutCalendarInput = {
    where: upcoming_eventsWhereUniqueInput
    update: XOR<upcoming_eventsUpdateWithoutCalendarInput, upcoming_eventsUncheckedUpdateWithoutCalendarInput>
    create: XOR<upcoming_eventsCreateWithoutCalendarInput, upcoming_eventsUncheckedCreateWithoutCalendarInput>
  }

  export type upcoming_eventsUpdateWithWhereUniqueWithoutCalendarInput = {
    where: upcoming_eventsWhereUniqueInput
    data: XOR<upcoming_eventsUpdateWithoutCalendarInput, upcoming_eventsUncheckedUpdateWithoutCalendarInput>
  }

  export type upcoming_eventsUpdateManyWithWhereWithoutCalendarInput = {
    where: upcoming_eventsScalarWhereInput
    data: XOR<upcoming_eventsUpdateManyMutationInput, upcoming_eventsUncheckedUpdateManyWithoutCalendarInput>
  }

  export type upcoming_eventsScalarWhereInput = {
    AND?: upcoming_eventsScalarWhereInput | upcoming_eventsScalarWhereInput[]
    OR?: upcoming_eventsScalarWhereInput[]
    NOT?: upcoming_eventsScalarWhereInput | upcoming_eventsScalarWhereInput[]
    id?: IntFilter<"upcoming_events"> | number
    calendar_id?: IntNullableFilter<"upcoming_events"> | number | null
    event_date?: DateTimeFilter<"upcoming_events"> | Date | string
    event_name?: StringFilter<"upcoming_events"> | string
    holiday?: BoolFilter<"upcoming_events"> | boolean
  }

  export type studentsCreateWithoutClass_representativesInput = {
    admission_number: string
    class: string
    section: string
    parent_name?: string | null
    parent_phone?: string | null
    parent_email?: string | null
    parent_work?: string | null
    parent_photo1?: string | null
    parent_photo2?: string | null
    guardian_photo?: string | null
    guardian_phone?: string | null
    roll_number?: number | null
    attendance?: attendanceCreateNestedManyWithoutStudentsInput
    class_teachers?: class_teachersCreateNestedManyWithoutStudentsInput
    finances?: financesCreateNestedManyWithoutStudentsInput
    student_performance?: student_performanceCreateNestedManyWithoutStudentsInput
    users?: usersCreateNestedOneWithoutStudentsInput
  }

  export type studentsUncheckedCreateWithoutClass_representativesInput = {
    id?: number
    user_id?: number | null
    admission_number: string
    class: string
    section: string
    parent_name?: string | null
    parent_phone?: string | null
    parent_email?: string | null
    parent_work?: string | null
    parent_photo1?: string | null
    parent_photo2?: string | null
    guardian_photo?: string | null
    guardian_phone?: string | null
    roll_number?: number | null
    attendance?: attendanceUncheckedCreateNestedManyWithoutStudentsInput
    class_teachers?: class_teachersUncheckedCreateNestedManyWithoutStudentsInput
    finances?: financesUncheckedCreateNestedManyWithoutStudentsInput
    student_performance?: student_performanceUncheckedCreateNestedManyWithoutStudentsInput
  }

  export type studentsCreateOrConnectWithoutClass_representativesInput = {
    where: studentsWhereUniqueInput
    create: XOR<studentsCreateWithoutClass_representativesInput, studentsUncheckedCreateWithoutClass_representativesInput>
  }

  export type studentsUpsertWithoutClass_representativesInput = {
    update: XOR<studentsUpdateWithoutClass_representativesInput, studentsUncheckedUpdateWithoutClass_representativesInput>
    create: XOR<studentsCreateWithoutClass_representativesInput, studentsUncheckedCreateWithoutClass_representativesInput>
    where?: studentsWhereInput
  }

  export type studentsUpdateToOneWithWhereWithoutClass_representativesInput = {
    where?: studentsWhereInput
    data: XOR<studentsUpdateWithoutClass_representativesInput, studentsUncheckedUpdateWithoutClass_representativesInput>
  }

  export type studentsUpdateWithoutClass_representativesInput = {
    admission_number?: StringFieldUpdateOperationsInput | string
    class?: StringFieldUpdateOperationsInput | string
    section?: StringFieldUpdateOperationsInput | string
    parent_name?: NullableStringFieldUpdateOperationsInput | string | null
    parent_phone?: NullableStringFieldUpdateOperationsInput | string | null
    parent_email?: NullableStringFieldUpdateOperationsInput | string | null
    parent_work?: NullableStringFieldUpdateOperationsInput | string | null
    parent_photo1?: NullableStringFieldUpdateOperationsInput | string | null
    parent_photo2?: NullableStringFieldUpdateOperationsInput | string | null
    guardian_photo?: NullableStringFieldUpdateOperationsInput | string | null
    guardian_phone?: NullableStringFieldUpdateOperationsInput | string | null
    roll_number?: NullableIntFieldUpdateOperationsInput | number | null
    attendance?: attendanceUpdateManyWithoutStudentsNestedInput
    class_teachers?: class_teachersUpdateManyWithoutStudentsNestedInput
    finances?: financesUpdateManyWithoutStudentsNestedInput
    student_performance?: student_performanceUpdateManyWithoutStudentsNestedInput
    users?: usersUpdateOneWithoutStudentsNestedInput
  }

  export type studentsUncheckedUpdateWithoutClass_representativesInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    admission_number?: StringFieldUpdateOperationsInput | string
    class?: StringFieldUpdateOperationsInput | string
    section?: StringFieldUpdateOperationsInput | string
    parent_name?: NullableStringFieldUpdateOperationsInput | string | null
    parent_phone?: NullableStringFieldUpdateOperationsInput | string | null
    parent_email?: NullableStringFieldUpdateOperationsInput | string | null
    parent_work?: NullableStringFieldUpdateOperationsInput | string | null
    parent_photo1?: NullableStringFieldUpdateOperationsInput | string | null
    parent_photo2?: NullableStringFieldUpdateOperationsInput | string | null
    guardian_photo?: NullableStringFieldUpdateOperationsInput | string | null
    guardian_phone?: NullableStringFieldUpdateOperationsInput | string | null
    roll_number?: NullableIntFieldUpdateOperationsInput | number | null
    attendance?: attendanceUncheckedUpdateManyWithoutStudentsNestedInput
    class_teachers?: class_teachersUncheckedUpdateManyWithoutStudentsNestedInput
    finances?: financesUncheckedUpdateManyWithoutStudentsNestedInput
    student_performance?: student_performanceUncheckedUpdateManyWithoutStudentsNestedInput
  }

  export type teachersCreateWithoutClass_routineInput = {
    specialised_subject: string
    assigned_class?: string | null
    assigned_section?: string | null
    assignments?: assignmentsCreateNestedManyWithoutTeachersInput
    attendance?: attendanceCreateNestedManyWithoutTeachersInput
    class_teachers?: class_teachersCreateNestedManyWithoutTeachersInput
    exams?: examsCreateNestedManyWithoutTeachersInput
    performance?: performanceCreateNestedManyWithoutTeachersInput
    student_routine?: student_routineCreateNestedManyWithoutTeachersInput
    users?: usersCreateNestedOneWithoutTeachersInput
  }

  export type teachersUncheckedCreateWithoutClass_routineInput = {
    id?: number
    user_id?: number | null
    specialised_subject: string
    assigned_class?: string | null
    assigned_section?: string | null
    assignments?: assignmentsUncheckedCreateNestedManyWithoutTeachersInput
    attendance?: attendanceUncheckedCreateNestedManyWithoutTeachersInput
    class_teachers?: class_teachersUncheckedCreateNestedManyWithoutTeachersInput
    exams?: examsUncheckedCreateNestedManyWithoutTeachersInput
    performance?: performanceUncheckedCreateNestedManyWithoutTeachersInput
    student_routine?: student_routineUncheckedCreateNestedManyWithoutTeachersInput
  }

  export type teachersCreateOrConnectWithoutClass_routineInput = {
    where: teachersWhereUniqueInput
    create: XOR<teachersCreateWithoutClass_routineInput, teachersUncheckedCreateWithoutClass_routineInput>
  }

  export type teachersUpsertWithoutClass_routineInput = {
    update: XOR<teachersUpdateWithoutClass_routineInput, teachersUncheckedUpdateWithoutClass_routineInput>
    create: XOR<teachersCreateWithoutClass_routineInput, teachersUncheckedCreateWithoutClass_routineInput>
    where?: teachersWhereInput
  }

  export type teachersUpdateToOneWithWhereWithoutClass_routineInput = {
    where?: teachersWhereInput
    data: XOR<teachersUpdateWithoutClass_routineInput, teachersUncheckedUpdateWithoutClass_routineInput>
  }

  export type teachersUpdateWithoutClass_routineInput = {
    specialised_subject?: StringFieldUpdateOperationsInput | string
    assigned_class?: NullableStringFieldUpdateOperationsInput | string | null
    assigned_section?: NullableStringFieldUpdateOperationsInput | string | null
    assignments?: assignmentsUpdateManyWithoutTeachersNestedInput
    attendance?: attendanceUpdateManyWithoutTeachersNestedInput
    class_teachers?: class_teachersUpdateManyWithoutTeachersNestedInput
    exams?: examsUpdateManyWithoutTeachersNestedInput
    performance?: performanceUpdateManyWithoutTeachersNestedInput
    student_routine?: student_routineUpdateManyWithoutTeachersNestedInput
    users?: usersUpdateOneWithoutTeachersNestedInput
  }

  export type teachersUncheckedUpdateWithoutClass_routineInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    specialised_subject?: StringFieldUpdateOperationsInput | string
    assigned_class?: NullableStringFieldUpdateOperationsInput | string | null
    assigned_section?: NullableStringFieldUpdateOperationsInput | string | null
    assignments?: assignmentsUncheckedUpdateManyWithoutTeachersNestedInput
    attendance?: attendanceUncheckedUpdateManyWithoutTeachersNestedInput
    class_teachers?: class_teachersUncheckedUpdateManyWithoutTeachersNestedInput
    exams?: examsUncheckedUpdateManyWithoutTeachersNestedInput
    performance?: performanceUncheckedUpdateManyWithoutTeachersNestedInput
    student_routine?: student_routineUncheckedUpdateManyWithoutTeachersNestedInput
  }

  export type studentsCreateWithoutClass_teachersInput = {
    admission_number: string
    class: string
    section: string
    parent_name?: string | null
    parent_phone?: string | null
    parent_email?: string | null
    parent_work?: string | null
    parent_photo1?: string | null
    parent_photo2?: string | null
    guardian_photo?: string | null
    guardian_phone?: string | null
    roll_number?: number | null
    attendance?: attendanceCreateNestedManyWithoutStudentsInput
    class_representatives?: class_representativesCreateNestedManyWithoutStudentsInput
    finances?: financesCreateNestedManyWithoutStudentsInput
    student_performance?: student_performanceCreateNestedManyWithoutStudentsInput
    users?: usersCreateNestedOneWithoutStudentsInput
  }

  export type studentsUncheckedCreateWithoutClass_teachersInput = {
    id?: number
    user_id?: number | null
    admission_number: string
    class: string
    section: string
    parent_name?: string | null
    parent_phone?: string | null
    parent_email?: string | null
    parent_work?: string | null
    parent_photo1?: string | null
    parent_photo2?: string | null
    guardian_photo?: string | null
    guardian_phone?: string | null
    roll_number?: number | null
    attendance?: attendanceUncheckedCreateNestedManyWithoutStudentsInput
    class_representatives?: class_representativesUncheckedCreateNestedManyWithoutStudentsInput
    finances?: financesUncheckedCreateNestedManyWithoutStudentsInput
    student_performance?: student_performanceUncheckedCreateNestedManyWithoutStudentsInput
  }

  export type studentsCreateOrConnectWithoutClass_teachersInput = {
    where: studentsWhereUniqueInput
    create: XOR<studentsCreateWithoutClass_teachersInput, studentsUncheckedCreateWithoutClass_teachersInput>
  }

  export type teachersCreateWithoutClass_teachersInput = {
    specialised_subject: string
    assigned_class?: string | null
    assigned_section?: string | null
    assignments?: assignmentsCreateNestedManyWithoutTeachersInput
    attendance?: attendanceCreateNestedManyWithoutTeachersInput
    class_routine?: class_routineCreateNestedManyWithoutTeachersInput
    exams?: examsCreateNestedManyWithoutTeachersInput
    performance?: performanceCreateNestedManyWithoutTeachersInput
    student_routine?: student_routineCreateNestedManyWithoutTeachersInput
    users?: usersCreateNestedOneWithoutTeachersInput
  }

  export type teachersUncheckedCreateWithoutClass_teachersInput = {
    id?: number
    user_id?: number | null
    specialised_subject: string
    assigned_class?: string | null
    assigned_section?: string | null
    assignments?: assignmentsUncheckedCreateNestedManyWithoutTeachersInput
    attendance?: attendanceUncheckedCreateNestedManyWithoutTeachersInput
    class_routine?: class_routineUncheckedCreateNestedManyWithoutTeachersInput
    exams?: examsUncheckedCreateNestedManyWithoutTeachersInput
    performance?: performanceUncheckedCreateNestedManyWithoutTeachersInput
    student_routine?: student_routineUncheckedCreateNestedManyWithoutTeachersInput
  }

  export type teachersCreateOrConnectWithoutClass_teachersInput = {
    where: teachersWhereUniqueInput
    create: XOR<teachersCreateWithoutClass_teachersInput, teachersUncheckedCreateWithoutClass_teachersInput>
  }

  export type studentsUpsertWithoutClass_teachersInput = {
    update: XOR<studentsUpdateWithoutClass_teachersInput, studentsUncheckedUpdateWithoutClass_teachersInput>
    create: XOR<studentsCreateWithoutClass_teachersInput, studentsUncheckedCreateWithoutClass_teachersInput>
    where?: studentsWhereInput
  }

  export type studentsUpdateToOneWithWhereWithoutClass_teachersInput = {
    where?: studentsWhereInput
    data: XOR<studentsUpdateWithoutClass_teachersInput, studentsUncheckedUpdateWithoutClass_teachersInput>
  }

  export type studentsUpdateWithoutClass_teachersInput = {
    admission_number?: StringFieldUpdateOperationsInput | string
    class?: StringFieldUpdateOperationsInput | string
    section?: StringFieldUpdateOperationsInput | string
    parent_name?: NullableStringFieldUpdateOperationsInput | string | null
    parent_phone?: NullableStringFieldUpdateOperationsInput | string | null
    parent_email?: NullableStringFieldUpdateOperationsInput | string | null
    parent_work?: NullableStringFieldUpdateOperationsInput | string | null
    parent_photo1?: NullableStringFieldUpdateOperationsInput | string | null
    parent_photo2?: NullableStringFieldUpdateOperationsInput | string | null
    guardian_photo?: NullableStringFieldUpdateOperationsInput | string | null
    guardian_phone?: NullableStringFieldUpdateOperationsInput | string | null
    roll_number?: NullableIntFieldUpdateOperationsInput | number | null
    attendance?: attendanceUpdateManyWithoutStudentsNestedInput
    class_representatives?: class_representativesUpdateManyWithoutStudentsNestedInput
    finances?: financesUpdateManyWithoutStudentsNestedInput
    student_performance?: student_performanceUpdateManyWithoutStudentsNestedInput
    users?: usersUpdateOneWithoutStudentsNestedInput
  }

  export type studentsUncheckedUpdateWithoutClass_teachersInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    admission_number?: StringFieldUpdateOperationsInput | string
    class?: StringFieldUpdateOperationsInput | string
    section?: StringFieldUpdateOperationsInput | string
    parent_name?: NullableStringFieldUpdateOperationsInput | string | null
    parent_phone?: NullableStringFieldUpdateOperationsInput | string | null
    parent_email?: NullableStringFieldUpdateOperationsInput | string | null
    parent_work?: NullableStringFieldUpdateOperationsInput | string | null
    parent_photo1?: NullableStringFieldUpdateOperationsInput | string | null
    parent_photo2?: NullableStringFieldUpdateOperationsInput | string | null
    guardian_photo?: NullableStringFieldUpdateOperationsInput | string | null
    guardian_phone?: NullableStringFieldUpdateOperationsInput | string | null
    roll_number?: NullableIntFieldUpdateOperationsInput | number | null
    attendance?: attendanceUncheckedUpdateManyWithoutStudentsNestedInput
    class_representatives?: class_representativesUncheckedUpdateManyWithoutStudentsNestedInput
    finances?: financesUncheckedUpdateManyWithoutStudentsNestedInput
    student_performance?: student_performanceUncheckedUpdateManyWithoutStudentsNestedInput
  }

  export type teachersUpsertWithoutClass_teachersInput = {
    update: XOR<teachersUpdateWithoutClass_teachersInput, teachersUncheckedUpdateWithoutClass_teachersInput>
    create: XOR<teachersCreateWithoutClass_teachersInput, teachersUncheckedCreateWithoutClass_teachersInput>
    where?: teachersWhereInput
  }

  export type teachersUpdateToOneWithWhereWithoutClass_teachersInput = {
    where?: teachersWhereInput
    data: XOR<teachersUpdateWithoutClass_teachersInput, teachersUncheckedUpdateWithoutClass_teachersInput>
  }

  export type teachersUpdateWithoutClass_teachersInput = {
    specialised_subject?: StringFieldUpdateOperationsInput | string
    assigned_class?: NullableStringFieldUpdateOperationsInput | string | null
    assigned_section?: NullableStringFieldUpdateOperationsInput | string | null
    assignments?: assignmentsUpdateManyWithoutTeachersNestedInput
    attendance?: attendanceUpdateManyWithoutTeachersNestedInput
    class_routine?: class_routineUpdateManyWithoutTeachersNestedInput
    exams?: examsUpdateManyWithoutTeachersNestedInput
    performance?: performanceUpdateManyWithoutTeachersNestedInput
    student_routine?: student_routineUpdateManyWithoutTeachersNestedInput
    users?: usersUpdateOneWithoutTeachersNestedInput
  }

  export type teachersUncheckedUpdateWithoutClass_teachersInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    specialised_subject?: StringFieldUpdateOperationsInput | string
    assigned_class?: NullableStringFieldUpdateOperationsInput | string | null
    assigned_section?: NullableStringFieldUpdateOperationsInput | string | null
    assignments?: assignmentsUncheckedUpdateManyWithoutTeachersNestedInput
    attendance?: attendanceUncheckedUpdateManyWithoutTeachersNestedInput
    class_routine?: class_routineUncheckedUpdateManyWithoutTeachersNestedInput
    exams?: examsUncheckedUpdateManyWithoutTeachersNestedInput
    performance?: performanceUncheckedUpdateManyWithoutTeachersNestedInput
    student_routine?: student_routineUncheckedUpdateManyWithoutTeachersNestedInput
  }

  export type teachersCreateWithoutExamsInput = {
    specialised_subject: string
    assigned_class?: string | null
    assigned_section?: string | null
    assignments?: assignmentsCreateNestedManyWithoutTeachersInput
    attendance?: attendanceCreateNestedManyWithoutTeachersInput
    class_routine?: class_routineCreateNestedManyWithoutTeachersInput
    class_teachers?: class_teachersCreateNestedManyWithoutTeachersInput
    performance?: performanceCreateNestedManyWithoutTeachersInput
    student_routine?: student_routineCreateNestedManyWithoutTeachersInput
    users?: usersCreateNestedOneWithoutTeachersInput
  }

  export type teachersUncheckedCreateWithoutExamsInput = {
    id?: number
    user_id?: number | null
    specialised_subject: string
    assigned_class?: string | null
    assigned_section?: string | null
    assignments?: assignmentsUncheckedCreateNestedManyWithoutTeachersInput
    attendance?: attendanceUncheckedCreateNestedManyWithoutTeachersInput
    class_routine?: class_routineUncheckedCreateNestedManyWithoutTeachersInput
    class_teachers?: class_teachersUncheckedCreateNestedManyWithoutTeachersInput
    performance?: performanceUncheckedCreateNestedManyWithoutTeachersInput
    student_routine?: student_routineUncheckedCreateNestedManyWithoutTeachersInput
  }

  export type teachersCreateOrConnectWithoutExamsInput = {
    where: teachersWhereUniqueInput
    create: XOR<teachersCreateWithoutExamsInput, teachersUncheckedCreateWithoutExamsInput>
  }

  export type performanceCreateWithoutExamsInput = {
    class: string
    section: string
    student_performance?: student_performanceCreateNestedOneWithoutPerformanceInput
    teachers?: teachersCreateNestedOneWithoutPerformanceInput
  }

  export type performanceUncheckedCreateWithoutExamsInput = {
    id?: number
    class: string
    section: string
    class_teacher?: number | null
    class_performance?: number | null
  }

  export type performanceCreateOrConnectWithoutExamsInput = {
    where: performanceWhereUniqueInput
    create: XOR<performanceCreateWithoutExamsInput, performanceUncheckedCreateWithoutExamsInput>
  }

  export type performanceCreateManyExamsInputEnvelope = {
    data: performanceCreateManyExamsInput | performanceCreateManyExamsInput[]
    skipDuplicates?: boolean
  }

  export type student_performanceCreateWithoutExamsInput = {
    marks_obtained: Decimal | DecimalJsLike | number | string
    total_marks: Decimal | DecimalJsLike | number | string
    performance?: performanceCreateNestedManyWithoutStudent_performanceInput
    students?: studentsCreateNestedOneWithoutStudent_performanceInput
  }

  export type student_performanceUncheckedCreateWithoutExamsInput = {
    id?: number
    student_id?: number | null
    marks_obtained: Decimal | DecimalJsLike | number | string
    total_marks: Decimal | DecimalJsLike | number | string
    performance?: performanceUncheckedCreateNestedManyWithoutStudent_performanceInput
  }

  export type student_performanceCreateOrConnectWithoutExamsInput = {
    where: student_performanceWhereUniqueInput
    create: XOR<student_performanceCreateWithoutExamsInput, student_performanceUncheckedCreateWithoutExamsInput>
  }

  export type student_performanceCreateManyExamsInputEnvelope = {
    data: student_performanceCreateManyExamsInput | student_performanceCreateManyExamsInput[]
    skipDuplicates?: boolean
  }

  export type teachersUpsertWithoutExamsInput = {
    update: XOR<teachersUpdateWithoutExamsInput, teachersUncheckedUpdateWithoutExamsInput>
    create: XOR<teachersCreateWithoutExamsInput, teachersUncheckedCreateWithoutExamsInput>
    where?: teachersWhereInput
  }

  export type teachersUpdateToOneWithWhereWithoutExamsInput = {
    where?: teachersWhereInput
    data: XOR<teachersUpdateWithoutExamsInput, teachersUncheckedUpdateWithoutExamsInput>
  }

  export type teachersUpdateWithoutExamsInput = {
    specialised_subject?: StringFieldUpdateOperationsInput | string
    assigned_class?: NullableStringFieldUpdateOperationsInput | string | null
    assigned_section?: NullableStringFieldUpdateOperationsInput | string | null
    assignments?: assignmentsUpdateManyWithoutTeachersNestedInput
    attendance?: attendanceUpdateManyWithoutTeachersNestedInput
    class_routine?: class_routineUpdateManyWithoutTeachersNestedInput
    class_teachers?: class_teachersUpdateManyWithoutTeachersNestedInput
    performance?: performanceUpdateManyWithoutTeachersNestedInput
    student_routine?: student_routineUpdateManyWithoutTeachersNestedInput
    users?: usersUpdateOneWithoutTeachersNestedInput
  }

  export type teachersUncheckedUpdateWithoutExamsInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    specialised_subject?: StringFieldUpdateOperationsInput | string
    assigned_class?: NullableStringFieldUpdateOperationsInput | string | null
    assigned_section?: NullableStringFieldUpdateOperationsInput | string | null
    assignments?: assignmentsUncheckedUpdateManyWithoutTeachersNestedInput
    attendance?: attendanceUncheckedUpdateManyWithoutTeachersNestedInput
    class_routine?: class_routineUncheckedUpdateManyWithoutTeachersNestedInput
    class_teachers?: class_teachersUncheckedUpdateManyWithoutTeachersNestedInput
    performance?: performanceUncheckedUpdateManyWithoutTeachersNestedInput
    student_routine?: student_routineUncheckedUpdateManyWithoutTeachersNestedInput
  }

  export type performanceUpsertWithWhereUniqueWithoutExamsInput = {
    where: performanceWhereUniqueInput
    update: XOR<performanceUpdateWithoutExamsInput, performanceUncheckedUpdateWithoutExamsInput>
    create: XOR<performanceCreateWithoutExamsInput, performanceUncheckedCreateWithoutExamsInput>
  }

  export type performanceUpdateWithWhereUniqueWithoutExamsInput = {
    where: performanceWhereUniqueInput
    data: XOR<performanceUpdateWithoutExamsInput, performanceUncheckedUpdateWithoutExamsInput>
  }

  export type performanceUpdateManyWithWhereWithoutExamsInput = {
    where: performanceScalarWhereInput
    data: XOR<performanceUpdateManyMutationInput, performanceUncheckedUpdateManyWithoutExamsInput>
  }

  export type performanceScalarWhereInput = {
    AND?: performanceScalarWhereInput | performanceScalarWhereInput[]
    OR?: performanceScalarWhereInput[]
    NOT?: performanceScalarWhereInput | performanceScalarWhereInput[]
    id?: IntFilter<"performance"> | number
    class?: StringFilter<"performance"> | string
    section?: StringFilter<"performance"> | string
    class_teacher?: IntNullableFilter<"performance"> | number | null
    class_performance?: IntNullableFilter<"performance"> | number | null
    exam_id?: IntNullableFilter<"performance"> | number | null
  }

  export type student_performanceUpsertWithWhereUniqueWithoutExamsInput = {
    where: student_performanceWhereUniqueInput
    update: XOR<student_performanceUpdateWithoutExamsInput, student_performanceUncheckedUpdateWithoutExamsInput>
    create: XOR<student_performanceCreateWithoutExamsInput, student_performanceUncheckedCreateWithoutExamsInput>
  }

  export type student_performanceUpdateWithWhereUniqueWithoutExamsInput = {
    where: student_performanceWhereUniqueInput
    data: XOR<student_performanceUpdateWithoutExamsInput, student_performanceUncheckedUpdateWithoutExamsInput>
  }

  export type student_performanceUpdateManyWithWhereWithoutExamsInput = {
    where: student_performanceScalarWhereInput
    data: XOR<student_performanceUpdateManyMutationInput, student_performanceUncheckedUpdateManyWithoutExamsInput>
  }

  export type student_performanceScalarWhereInput = {
    AND?: student_performanceScalarWhereInput | student_performanceScalarWhereInput[]
    OR?: student_performanceScalarWhereInput[]
    NOT?: student_performanceScalarWhereInput | student_performanceScalarWhereInput[]
    id?: IntFilter<"student_performance"> | number
    student_id?: IntNullableFilter<"student_performance"> | number | null
    exam_id?: IntNullableFilter<"student_performance"> | number | null
    marks_obtained?: DecimalFilter<"student_performance"> | Decimal | DecimalJsLike | number | string
    total_marks?: DecimalFilter<"student_performance"> | Decimal | DecimalJsLike | number | string
  }

  export type studentsCreateWithoutFinancesInput = {
    admission_number: string
    class: string
    section: string
    parent_name?: string | null
    parent_phone?: string | null
    parent_email?: string | null
    parent_work?: string | null
    parent_photo1?: string | null
    parent_photo2?: string | null
    guardian_photo?: string | null
    guardian_phone?: string | null
    roll_number?: number | null
    attendance?: attendanceCreateNestedManyWithoutStudentsInput
    class_representatives?: class_representativesCreateNestedManyWithoutStudentsInput
    class_teachers?: class_teachersCreateNestedManyWithoutStudentsInput
    student_performance?: student_performanceCreateNestedManyWithoutStudentsInput
    users?: usersCreateNestedOneWithoutStudentsInput
  }

  export type studentsUncheckedCreateWithoutFinancesInput = {
    id?: number
    user_id?: number | null
    admission_number: string
    class: string
    section: string
    parent_name?: string | null
    parent_phone?: string | null
    parent_email?: string | null
    parent_work?: string | null
    parent_photo1?: string | null
    parent_photo2?: string | null
    guardian_photo?: string | null
    guardian_phone?: string | null
    roll_number?: number | null
    attendance?: attendanceUncheckedCreateNestedManyWithoutStudentsInput
    class_representatives?: class_representativesUncheckedCreateNestedManyWithoutStudentsInput
    class_teachers?: class_teachersUncheckedCreateNestedManyWithoutStudentsInput
    student_performance?: student_performanceUncheckedCreateNestedManyWithoutStudentsInput
  }

  export type studentsCreateOrConnectWithoutFinancesInput = {
    where: studentsWhereUniqueInput
    create: XOR<studentsCreateWithoutFinancesInput, studentsUncheckedCreateWithoutFinancesInput>
  }

  export type studentsUpsertWithoutFinancesInput = {
    update: XOR<studentsUpdateWithoutFinancesInput, studentsUncheckedUpdateWithoutFinancesInput>
    create: XOR<studentsCreateWithoutFinancesInput, studentsUncheckedCreateWithoutFinancesInput>
    where?: studentsWhereInput
  }

  export type studentsUpdateToOneWithWhereWithoutFinancesInput = {
    where?: studentsWhereInput
    data: XOR<studentsUpdateWithoutFinancesInput, studentsUncheckedUpdateWithoutFinancesInput>
  }

  export type studentsUpdateWithoutFinancesInput = {
    admission_number?: StringFieldUpdateOperationsInput | string
    class?: StringFieldUpdateOperationsInput | string
    section?: StringFieldUpdateOperationsInput | string
    parent_name?: NullableStringFieldUpdateOperationsInput | string | null
    parent_phone?: NullableStringFieldUpdateOperationsInput | string | null
    parent_email?: NullableStringFieldUpdateOperationsInput | string | null
    parent_work?: NullableStringFieldUpdateOperationsInput | string | null
    parent_photo1?: NullableStringFieldUpdateOperationsInput | string | null
    parent_photo2?: NullableStringFieldUpdateOperationsInput | string | null
    guardian_photo?: NullableStringFieldUpdateOperationsInput | string | null
    guardian_phone?: NullableStringFieldUpdateOperationsInput | string | null
    roll_number?: NullableIntFieldUpdateOperationsInput | number | null
    attendance?: attendanceUpdateManyWithoutStudentsNestedInput
    class_representatives?: class_representativesUpdateManyWithoutStudentsNestedInput
    class_teachers?: class_teachersUpdateManyWithoutStudentsNestedInput
    student_performance?: student_performanceUpdateManyWithoutStudentsNestedInput
    users?: usersUpdateOneWithoutStudentsNestedInput
  }

  export type studentsUncheckedUpdateWithoutFinancesInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    admission_number?: StringFieldUpdateOperationsInput | string
    class?: StringFieldUpdateOperationsInput | string
    section?: StringFieldUpdateOperationsInput | string
    parent_name?: NullableStringFieldUpdateOperationsInput | string | null
    parent_phone?: NullableStringFieldUpdateOperationsInput | string | null
    parent_email?: NullableStringFieldUpdateOperationsInput | string | null
    parent_work?: NullableStringFieldUpdateOperationsInput | string | null
    parent_photo1?: NullableStringFieldUpdateOperationsInput | string | null
    parent_photo2?: NullableStringFieldUpdateOperationsInput | string | null
    guardian_photo?: NullableStringFieldUpdateOperationsInput | string | null
    guardian_phone?: NullableStringFieldUpdateOperationsInput | string | null
    roll_number?: NullableIntFieldUpdateOperationsInput | number | null
    attendance?: attendanceUncheckedUpdateManyWithoutStudentsNestedInput
    class_representatives?: class_representativesUncheckedUpdateManyWithoutStudentsNestedInput
    class_teachers?: class_teachersUncheckedUpdateManyWithoutStudentsNestedInput
    student_performance?: student_performanceUncheckedUpdateManyWithoutStudentsNestedInput
  }

  export type usersCreateWithoutNotesInput = {
    name: string
    email: string
    password: string
    role: string
    phone?: string | null
    address?: string | null
    photo?: string | null
    notices?: noticesCreateNestedManyWithoutUsersInput
    students?: studentsCreateNestedManyWithoutUsersInput
    teacher_routine?: teacher_routineCreateNestedManyWithoutUsersInput
    teachers?: teachersCreateNestedManyWithoutUsersInput
    workroom_messages_workroom_messages_receiver_idTousers?: workroom_messagesCreateNestedManyWithoutUsers_workroom_messages_receiver_idTousersInput
    workroom_messages_workroom_messages_sender_idTousers?: workroom_messagesCreateNestedManyWithoutUsers_workroom_messages_sender_idTousersInput
  }

  export type usersUncheckedCreateWithoutNotesInput = {
    id?: number
    name: string
    email: string
    password: string
    role: string
    phone?: string | null
    address?: string | null
    photo?: string | null
    notices?: noticesUncheckedCreateNestedManyWithoutUsersInput
    students?: studentsUncheckedCreateNestedManyWithoutUsersInput
    teacher_routine?: teacher_routineUncheckedCreateNestedManyWithoutUsersInput
    teachers?: teachersUncheckedCreateNestedManyWithoutUsersInput
    workroom_messages_workroom_messages_receiver_idTousers?: workroom_messagesUncheckedCreateNestedManyWithoutUsers_workroom_messages_receiver_idTousersInput
    workroom_messages_workroom_messages_sender_idTousers?: workroom_messagesUncheckedCreateNestedManyWithoutUsers_workroom_messages_sender_idTousersInput
  }

  export type usersCreateOrConnectWithoutNotesInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutNotesInput, usersUncheckedCreateWithoutNotesInput>
  }

  export type usersUpsertWithoutNotesInput = {
    update: XOR<usersUpdateWithoutNotesInput, usersUncheckedUpdateWithoutNotesInput>
    create: XOR<usersCreateWithoutNotesInput, usersUncheckedCreateWithoutNotesInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutNotesInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutNotesInput, usersUncheckedUpdateWithoutNotesInput>
  }

  export type usersUpdateWithoutNotesInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    notices?: noticesUpdateManyWithoutUsersNestedInput
    students?: studentsUpdateManyWithoutUsersNestedInput
    teacher_routine?: teacher_routineUpdateManyWithoutUsersNestedInput
    teachers?: teachersUpdateManyWithoutUsersNestedInput
    workroom_messages_workroom_messages_receiver_idTousers?: workroom_messagesUpdateManyWithoutUsers_workroom_messages_receiver_idTousersNestedInput
    workroom_messages_workroom_messages_sender_idTousers?: workroom_messagesUpdateManyWithoutUsers_workroom_messages_sender_idTousersNestedInput
  }

  export type usersUncheckedUpdateWithoutNotesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    notices?: noticesUncheckedUpdateManyWithoutUsersNestedInput
    students?: studentsUncheckedUpdateManyWithoutUsersNestedInput
    teacher_routine?: teacher_routineUncheckedUpdateManyWithoutUsersNestedInput
    teachers?: teachersUncheckedUpdateManyWithoutUsersNestedInput
    workroom_messages_workroom_messages_receiver_idTousers?: workroom_messagesUncheckedUpdateManyWithoutUsers_workroom_messages_receiver_idTousersNestedInput
    workroom_messages_workroom_messages_sender_idTousers?: workroom_messagesUncheckedUpdateManyWithoutUsers_workroom_messages_sender_idTousersNestedInput
  }

  export type usersCreateWithoutNoticesInput = {
    name: string
    email: string
    password: string
    role: string
    phone?: string | null
    address?: string | null
    photo?: string | null
    notes?: notesCreateNestedManyWithoutUsersInput
    students?: studentsCreateNestedManyWithoutUsersInput
    teacher_routine?: teacher_routineCreateNestedManyWithoutUsersInput
    teachers?: teachersCreateNestedManyWithoutUsersInput
    workroom_messages_workroom_messages_receiver_idTousers?: workroom_messagesCreateNestedManyWithoutUsers_workroom_messages_receiver_idTousersInput
    workroom_messages_workroom_messages_sender_idTousers?: workroom_messagesCreateNestedManyWithoutUsers_workroom_messages_sender_idTousersInput
  }

  export type usersUncheckedCreateWithoutNoticesInput = {
    id?: number
    name: string
    email: string
    password: string
    role: string
    phone?: string | null
    address?: string | null
    photo?: string | null
    notes?: notesUncheckedCreateNestedManyWithoutUsersInput
    students?: studentsUncheckedCreateNestedManyWithoutUsersInput
    teacher_routine?: teacher_routineUncheckedCreateNestedManyWithoutUsersInput
    teachers?: teachersUncheckedCreateNestedManyWithoutUsersInput
    workroom_messages_workroom_messages_receiver_idTousers?: workroom_messagesUncheckedCreateNestedManyWithoutUsers_workroom_messages_receiver_idTousersInput
    workroom_messages_workroom_messages_sender_idTousers?: workroom_messagesUncheckedCreateNestedManyWithoutUsers_workroom_messages_sender_idTousersInput
  }

  export type usersCreateOrConnectWithoutNoticesInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutNoticesInput, usersUncheckedCreateWithoutNoticesInput>
  }

  export type usersUpsertWithoutNoticesInput = {
    update: XOR<usersUpdateWithoutNoticesInput, usersUncheckedUpdateWithoutNoticesInput>
    create: XOR<usersCreateWithoutNoticesInput, usersUncheckedCreateWithoutNoticesInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutNoticesInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutNoticesInput, usersUncheckedUpdateWithoutNoticesInput>
  }

  export type usersUpdateWithoutNoticesInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: notesUpdateManyWithoutUsersNestedInput
    students?: studentsUpdateManyWithoutUsersNestedInput
    teacher_routine?: teacher_routineUpdateManyWithoutUsersNestedInput
    teachers?: teachersUpdateManyWithoutUsersNestedInput
    workroom_messages_workroom_messages_receiver_idTousers?: workroom_messagesUpdateManyWithoutUsers_workroom_messages_receiver_idTousersNestedInput
    workroom_messages_workroom_messages_sender_idTousers?: workroom_messagesUpdateManyWithoutUsers_workroom_messages_sender_idTousersNestedInput
  }

  export type usersUncheckedUpdateWithoutNoticesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: notesUncheckedUpdateManyWithoutUsersNestedInput
    students?: studentsUncheckedUpdateManyWithoutUsersNestedInput
    teacher_routine?: teacher_routineUncheckedUpdateManyWithoutUsersNestedInput
    teachers?: teachersUncheckedUpdateManyWithoutUsersNestedInput
    workroom_messages_workroom_messages_receiver_idTousers?: workroom_messagesUncheckedUpdateManyWithoutUsers_workroom_messages_receiver_idTousersNestedInput
    workroom_messages_workroom_messages_sender_idTousers?: workroom_messagesUncheckedUpdateManyWithoutUsers_workroom_messages_sender_idTousersNestedInput
  }

  export type examsCreateWithoutPerformanceInput = {
    class: string
    section: string
    subject: string
    exam_date: Date | string
    exam_duration?: string | null
    exam_type?: string | null
    teachers?: teachersCreateNestedOneWithoutExamsInput
    student_performance?: student_performanceCreateNestedManyWithoutExamsInput
  }

  export type examsUncheckedCreateWithoutPerformanceInput = {
    id?: number
    class: string
    section: string
    subject: string
    exam_date: Date | string
    exam_duration?: string | null
    exam_type?: string | null
    created_by?: number | null
    student_performance?: student_performanceUncheckedCreateNestedManyWithoutExamsInput
  }

  export type examsCreateOrConnectWithoutPerformanceInput = {
    where: examsWhereUniqueInput
    create: XOR<examsCreateWithoutPerformanceInput, examsUncheckedCreateWithoutPerformanceInput>
  }

  export type student_performanceCreateWithoutPerformanceInput = {
    marks_obtained: Decimal | DecimalJsLike | number | string
    total_marks: Decimal | DecimalJsLike | number | string
    exams?: examsCreateNestedOneWithoutStudent_performanceInput
    students?: studentsCreateNestedOneWithoutStudent_performanceInput
  }

  export type student_performanceUncheckedCreateWithoutPerformanceInput = {
    id?: number
    student_id?: number | null
    exam_id?: number | null
    marks_obtained: Decimal | DecimalJsLike | number | string
    total_marks: Decimal | DecimalJsLike | number | string
  }

  export type student_performanceCreateOrConnectWithoutPerformanceInput = {
    where: student_performanceWhereUniqueInput
    create: XOR<student_performanceCreateWithoutPerformanceInput, student_performanceUncheckedCreateWithoutPerformanceInput>
  }

  export type teachersCreateWithoutPerformanceInput = {
    specialised_subject: string
    assigned_class?: string | null
    assigned_section?: string | null
    assignments?: assignmentsCreateNestedManyWithoutTeachersInput
    attendance?: attendanceCreateNestedManyWithoutTeachersInput
    class_routine?: class_routineCreateNestedManyWithoutTeachersInput
    class_teachers?: class_teachersCreateNestedManyWithoutTeachersInput
    exams?: examsCreateNestedManyWithoutTeachersInput
    student_routine?: student_routineCreateNestedManyWithoutTeachersInput
    users?: usersCreateNestedOneWithoutTeachersInput
  }

  export type teachersUncheckedCreateWithoutPerformanceInput = {
    id?: number
    user_id?: number | null
    specialised_subject: string
    assigned_class?: string | null
    assigned_section?: string | null
    assignments?: assignmentsUncheckedCreateNestedManyWithoutTeachersInput
    attendance?: attendanceUncheckedCreateNestedManyWithoutTeachersInput
    class_routine?: class_routineUncheckedCreateNestedManyWithoutTeachersInput
    class_teachers?: class_teachersUncheckedCreateNestedManyWithoutTeachersInput
    exams?: examsUncheckedCreateNestedManyWithoutTeachersInput
    student_routine?: student_routineUncheckedCreateNestedManyWithoutTeachersInput
  }

  export type teachersCreateOrConnectWithoutPerformanceInput = {
    where: teachersWhereUniqueInput
    create: XOR<teachersCreateWithoutPerformanceInput, teachersUncheckedCreateWithoutPerformanceInput>
  }

  export type examsUpsertWithoutPerformanceInput = {
    update: XOR<examsUpdateWithoutPerformanceInput, examsUncheckedUpdateWithoutPerformanceInput>
    create: XOR<examsCreateWithoutPerformanceInput, examsUncheckedCreateWithoutPerformanceInput>
    where?: examsWhereInput
  }

  export type examsUpdateToOneWithWhereWithoutPerformanceInput = {
    where?: examsWhereInput
    data: XOR<examsUpdateWithoutPerformanceInput, examsUncheckedUpdateWithoutPerformanceInput>
  }

  export type examsUpdateWithoutPerformanceInput = {
    class?: StringFieldUpdateOperationsInput | string
    section?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    exam_date?: DateTimeFieldUpdateOperationsInput | Date | string
    exam_duration?: NullableStringFieldUpdateOperationsInput | string | null
    exam_type?: NullableStringFieldUpdateOperationsInput | string | null
    teachers?: teachersUpdateOneWithoutExamsNestedInput
    student_performance?: student_performanceUpdateManyWithoutExamsNestedInput
  }

  export type examsUncheckedUpdateWithoutPerformanceInput = {
    id?: IntFieldUpdateOperationsInput | number
    class?: StringFieldUpdateOperationsInput | string
    section?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    exam_date?: DateTimeFieldUpdateOperationsInput | Date | string
    exam_duration?: NullableStringFieldUpdateOperationsInput | string | null
    exam_type?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    student_performance?: student_performanceUncheckedUpdateManyWithoutExamsNestedInput
  }

  export type student_performanceUpsertWithoutPerformanceInput = {
    update: XOR<student_performanceUpdateWithoutPerformanceInput, student_performanceUncheckedUpdateWithoutPerformanceInput>
    create: XOR<student_performanceCreateWithoutPerformanceInput, student_performanceUncheckedCreateWithoutPerformanceInput>
    where?: student_performanceWhereInput
  }

  export type student_performanceUpdateToOneWithWhereWithoutPerformanceInput = {
    where?: student_performanceWhereInput
    data: XOR<student_performanceUpdateWithoutPerformanceInput, student_performanceUncheckedUpdateWithoutPerformanceInput>
  }

  export type student_performanceUpdateWithoutPerformanceInput = {
    marks_obtained?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total_marks?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    exams?: examsUpdateOneWithoutStudent_performanceNestedInput
    students?: studentsUpdateOneWithoutStudent_performanceNestedInput
  }

  export type student_performanceUncheckedUpdateWithoutPerformanceInput = {
    id?: IntFieldUpdateOperationsInput | number
    student_id?: NullableIntFieldUpdateOperationsInput | number | null
    exam_id?: NullableIntFieldUpdateOperationsInput | number | null
    marks_obtained?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total_marks?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type teachersUpsertWithoutPerformanceInput = {
    update: XOR<teachersUpdateWithoutPerformanceInput, teachersUncheckedUpdateWithoutPerformanceInput>
    create: XOR<teachersCreateWithoutPerformanceInput, teachersUncheckedCreateWithoutPerformanceInput>
    where?: teachersWhereInput
  }

  export type teachersUpdateToOneWithWhereWithoutPerformanceInput = {
    where?: teachersWhereInput
    data: XOR<teachersUpdateWithoutPerformanceInput, teachersUncheckedUpdateWithoutPerformanceInput>
  }

  export type teachersUpdateWithoutPerformanceInput = {
    specialised_subject?: StringFieldUpdateOperationsInput | string
    assigned_class?: NullableStringFieldUpdateOperationsInput | string | null
    assigned_section?: NullableStringFieldUpdateOperationsInput | string | null
    assignments?: assignmentsUpdateManyWithoutTeachersNestedInput
    attendance?: attendanceUpdateManyWithoutTeachersNestedInput
    class_routine?: class_routineUpdateManyWithoutTeachersNestedInput
    class_teachers?: class_teachersUpdateManyWithoutTeachersNestedInput
    exams?: examsUpdateManyWithoutTeachersNestedInput
    student_routine?: student_routineUpdateManyWithoutTeachersNestedInput
    users?: usersUpdateOneWithoutTeachersNestedInput
  }

  export type teachersUncheckedUpdateWithoutPerformanceInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    specialised_subject?: StringFieldUpdateOperationsInput | string
    assigned_class?: NullableStringFieldUpdateOperationsInput | string | null
    assigned_section?: NullableStringFieldUpdateOperationsInput | string | null
    assignments?: assignmentsUncheckedUpdateManyWithoutTeachersNestedInput
    attendance?: attendanceUncheckedUpdateManyWithoutTeachersNestedInput
    class_routine?: class_routineUncheckedUpdateManyWithoutTeachersNestedInput
    class_teachers?: class_teachersUncheckedUpdateManyWithoutTeachersNestedInput
    exams?: examsUncheckedUpdateManyWithoutTeachersNestedInput
    student_routine?: student_routineUncheckedUpdateManyWithoutTeachersNestedInput
  }

  export type performanceCreateWithoutStudent_performanceInput = {
    class: string
    section: string
    exams?: examsCreateNestedOneWithoutPerformanceInput
    teachers?: teachersCreateNestedOneWithoutPerformanceInput
  }

  export type performanceUncheckedCreateWithoutStudent_performanceInput = {
    id?: number
    class: string
    section: string
    class_teacher?: number | null
    exam_id?: number | null
  }

  export type performanceCreateOrConnectWithoutStudent_performanceInput = {
    where: performanceWhereUniqueInput
    create: XOR<performanceCreateWithoutStudent_performanceInput, performanceUncheckedCreateWithoutStudent_performanceInput>
  }

  export type performanceCreateManyStudent_performanceInputEnvelope = {
    data: performanceCreateManyStudent_performanceInput | performanceCreateManyStudent_performanceInput[]
    skipDuplicates?: boolean
  }

  export type examsCreateWithoutStudent_performanceInput = {
    class: string
    section: string
    subject: string
    exam_date: Date | string
    exam_duration?: string | null
    exam_type?: string | null
    teachers?: teachersCreateNestedOneWithoutExamsInput
    performance?: performanceCreateNestedManyWithoutExamsInput
  }

  export type examsUncheckedCreateWithoutStudent_performanceInput = {
    id?: number
    class: string
    section: string
    subject: string
    exam_date: Date | string
    exam_duration?: string | null
    exam_type?: string | null
    created_by?: number | null
    performance?: performanceUncheckedCreateNestedManyWithoutExamsInput
  }

  export type examsCreateOrConnectWithoutStudent_performanceInput = {
    where: examsWhereUniqueInput
    create: XOR<examsCreateWithoutStudent_performanceInput, examsUncheckedCreateWithoutStudent_performanceInput>
  }

  export type studentsCreateWithoutStudent_performanceInput = {
    admission_number: string
    class: string
    section: string
    parent_name?: string | null
    parent_phone?: string | null
    parent_email?: string | null
    parent_work?: string | null
    parent_photo1?: string | null
    parent_photo2?: string | null
    guardian_photo?: string | null
    guardian_phone?: string | null
    roll_number?: number | null
    attendance?: attendanceCreateNestedManyWithoutStudentsInput
    class_representatives?: class_representativesCreateNestedManyWithoutStudentsInput
    class_teachers?: class_teachersCreateNestedManyWithoutStudentsInput
    finances?: financesCreateNestedManyWithoutStudentsInput
    users?: usersCreateNestedOneWithoutStudentsInput
  }

  export type studentsUncheckedCreateWithoutStudent_performanceInput = {
    id?: number
    user_id?: number | null
    admission_number: string
    class: string
    section: string
    parent_name?: string | null
    parent_phone?: string | null
    parent_email?: string | null
    parent_work?: string | null
    parent_photo1?: string | null
    parent_photo2?: string | null
    guardian_photo?: string | null
    guardian_phone?: string | null
    roll_number?: number | null
    attendance?: attendanceUncheckedCreateNestedManyWithoutStudentsInput
    class_representatives?: class_representativesUncheckedCreateNestedManyWithoutStudentsInput
    class_teachers?: class_teachersUncheckedCreateNestedManyWithoutStudentsInput
    finances?: financesUncheckedCreateNestedManyWithoutStudentsInput
  }

  export type studentsCreateOrConnectWithoutStudent_performanceInput = {
    where: studentsWhereUniqueInput
    create: XOR<studentsCreateWithoutStudent_performanceInput, studentsUncheckedCreateWithoutStudent_performanceInput>
  }

  export type performanceUpsertWithWhereUniqueWithoutStudent_performanceInput = {
    where: performanceWhereUniqueInput
    update: XOR<performanceUpdateWithoutStudent_performanceInput, performanceUncheckedUpdateWithoutStudent_performanceInput>
    create: XOR<performanceCreateWithoutStudent_performanceInput, performanceUncheckedCreateWithoutStudent_performanceInput>
  }

  export type performanceUpdateWithWhereUniqueWithoutStudent_performanceInput = {
    where: performanceWhereUniqueInput
    data: XOR<performanceUpdateWithoutStudent_performanceInput, performanceUncheckedUpdateWithoutStudent_performanceInput>
  }

  export type performanceUpdateManyWithWhereWithoutStudent_performanceInput = {
    where: performanceScalarWhereInput
    data: XOR<performanceUpdateManyMutationInput, performanceUncheckedUpdateManyWithoutStudent_performanceInput>
  }

  export type examsUpsertWithoutStudent_performanceInput = {
    update: XOR<examsUpdateWithoutStudent_performanceInput, examsUncheckedUpdateWithoutStudent_performanceInput>
    create: XOR<examsCreateWithoutStudent_performanceInput, examsUncheckedCreateWithoutStudent_performanceInput>
    where?: examsWhereInput
  }

  export type examsUpdateToOneWithWhereWithoutStudent_performanceInput = {
    where?: examsWhereInput
    data: XOR<examsUpdateWithoutStudent_performanceInput, examsUncheckedUpdateWithoutStudent_performanceInput>
  }

  export type examsUpdateWithoutStudent_performanceInput = {
    class?: StringFieldUpdateOperationsInput | string
    section?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    exam_date?: DateTimeFieldUpdateOperationsInput | Date | string
    exam_duration?: NullableStringFieldUpdateOperationsInput | string | null
    exam_type?: NullableStringFieldUpdateOperationsInput | string | null
    teachers?: teachersUpdateOneWithoutExamsNestedInput
    performance?: performanceUpdateManyWithoutExamsNestedInput
  }

  export type examsUncheckedUpdateWithoutStudent_performanceInput = {
    id?: IntFieldUpdateOperationsInput | number
    class?: StringFieldUpdateOperationsInput | string
    section?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    exam_date?: DateTimeFieldUpdateOperationsInput | Date | string
    exam_duration?: NullableStringFieldUpdateOperationsInput | string | null
    exam_type?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: NullableIntFieldUpdateOperationsInput | number | null
    performance?: performanceUncheckedUpdateManyWithoutExamsNestedInput
  }

  export type studentsUpsertWithoutStudent_performanceInput = {
    update: XOR<studentsUpdateWithoutStudent_performanceInput, studentsUncheckedUpdateWithoutStudent_performanceInput>
    create: XOR<studentsCreateWithoutStudent_performanceInput, studentsUncheckedCreateWithoutStudent_performanceInput>
    where?: studentsWhereInput
  }

  export type studentsUpdateToOneWithWhereWithoutStudent_performanceInput = {
    where?: studentsWhereInput
    data: XOR<studentsUpdateWithoutStudent_performanceInput, studentsUncheckedUpdateWithoutStudent_performanceInput>
  }

  export type studentsUpdateWithoutStudent_performanceInput = {
    admission_number?: StringFieldUpdateOperationsInput | string
    class?: StringFieldUpdateOperationsInput | string
    section?: StringFieldUpdateOperationsInput | string
    parent_name?: NullableStringFieldUpdateOperationsInput | string | null
    parent_phone?: NullableStringFieldUpdateOperationsInput | string | null
    parent_email?: NullableStringFieldUpdateOperationsInput | string | null
    parent_work?: NullableStringFieldUpdateOperationsInput | string | null
    parent_photo1?: NullableStringFieldUpdateOperationsInput | string | null
    parent_photo2?: NullableStringFieldUpdateOperationsInput | string | null
    guardian_photo?: NullableStringFieldUpdateOperationsInput | string | null
    guardian_phone?: NullableStringFieldUpdateOperationsInput | string | null
    roll_number?: NullableIntFieldUpdateOperationsInput | number | null
    attendance?: attendanceUpdateManyWithoutStudentsNestedInput
    class_representatives?: class_representativesUpdateManyWithoutStudentsNestedInput
    class_teachers?: class_teachersUpdateManyWithoutStudentsNestedInput
    finances?: financesUpdateManyWithoutStudentsNestedInput
    users?: usersUpdateOneWithoutStudentsNestedInput
  }

  export type studentsUncheckedUpdateWithoutStudent_performanceInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    admission_number?: StringFieldUpdateOperationsInput | string
    class?: StringFieldUpdateOperationsInput | string
    section?: StringFieldUpdateOperationsInput | string
    parent_name?: NullableStringFieldUpdateOperationsInput | string | null
    parent_phone?: NullableStringFieldUpdateOperationsInput | string | null
    parent_email?: NullableStringFieldUpdateOperationsInput | string | null
    parent_work?: NullableStringFieldUpdateOperationsInput | string | null
    parent_photo1?: NullableStringFieldUpdateOperationsInput | string | null
    parent_photo2?: NullableStringFieldUpdateOperationsInput | string | null
    guardian_photo?: NullableStringFieldUpdateOperationsInput | string | null
    guardian_phone?: NullableStringFieldUpdateOperationsInput | string | null
    roll_number?: NullableIntFieldUpdateOperationsInput | number | null
    attendance?: attendanceUncheckedUpdateManyWithoutStudentsNestedInput
    class_representatives?: class_representativesUncheckedUpdateManyWithoutStudentsNestedInput
    class_teachers?: class_teachersUncheckedUpdateManyWithoutStudentsNestedInput
    finances?: financesUncheckedUpdateManyWithoutStudentsNestedInput
  }

  export type teachersCreateWithoutStudent_routineInput = {
    specialised_subject: string
    assigned_class?: string | null
    assigned_section?: string | null
    assignments?: assignmentsCreateNestedManyWithoutTeachersInput
    attendance?: attendanceCreateNestedManyWithoutTeachersInput
    class_routine?: class_routineCreateNestedManyWithoutTeachersInput
    class_teachers?: class_teachersCreateNestedManyWithoutTeachersInput
    exams?: examsCreateNestedManyWithoutTeachersInput
    performance?: performanceCreateNestedManyWithoutTeachersInput
    users?: usersCreateNestedOneWithoutTeachersInput
  }

  export type teachersUncheckedCreateWithoutStudent_routineInput = {
    id?: number
    user_id?: number | null
    specialised_subject: string
    assigned_class?: string | null
    assigned_section?: string | null
    assignments?: assignmentsUncheckedCreateNestedManyWithoutTeachersInput
    attendance?: attendanceUncheckedCreateNestedManyWithoutTeachersInput
    class_routine?: class_routineUncheckedCreateNestedManyWithoutTeachersInput
    class_teachers?: class_teachersUncheckedCreateNestedManyWithoutTeachersInput
    exams?: examsUncheckedCreateNestedManyWithoutTeachersInput
    performance?: performanceUncheckedCreateNestedManyWithoutTeachersInput
  }

  export type teachersCreateOrConnectWithoutStudent_routineInput = {
    where: teachersWhereUniqueInput
    create: XOR<teachersCreateWithoutStudent_routineInput, teachersUncheckedCreateWithoutStudent_routineInput>
  }

  export type teachersUpsertWithoutStudent_routineInput = {
    update: XOR<teachersUpdateWithoutStudent_routineInput, teachersUncheckedUpdateWithoutStudent_routineInput>
    create: XOR<teachersCreateWithoutStudent_routineInput, teachersUncheckedCreateWithoutStudent_routineInput>
    where?: teachersWhereInput
  }

  export type teachersUpdateToOneWithWhereWithoutStudent_routineInput = {
    where?: teachersWhereInput
    data: XOR<teachersUpdateWithoutStudent_routineInput, teachersUncheckedUpdateWithoutStudent_routineInput>
  }

  export type teachersUpdateWithoutStudent_routineInput = {
    specialised_subject?: StringFieldUpdateOperationsInput | string
    assigned_class?: NullableStringFieldUpdateOperationsInput | string | null
    assigned_section?: NullableStringFieldUpdateOperationsInput | string | null
    assignments?: assignmentsUpdateManyWithoutTeachersNestedInput
    attendance?: attendanceUpdateManyWithoutTeachersNestedInput
    class_routine?: class_routineUpdateManyWithoutTeachersNestedInput
    class_teachers?: class_teachersUpdateManyWithoutTeachersNestedInput
    exams?: examsUpdateManyWithoutTeachersNestedInput
    performance?: performanceUpdateManyWithoutTeachersNestedInput
    users?: usersUpdateOneWithoutTeachersNestedInput
  }

  export type teachersUncheckedUpdateWithoutStudent_routineInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    specialised_subject?: StringFieldUpdateOperationsInput | string
    assigned_class?: NullableStringFieldUpdateOperationsInput | string | null
    assigned_section?: NullableStringFieldUpdateOperationsInput | string | null
    assignments?: assignmentsUncheckedUpdateManyWithoutTeachersNestedInput
    attendance?: attendanceUncheckedUpdateManyWithoutTeachersNestedInput
    class_routine?: class_routineUncheckedUpdateManyWithoutTeachersNestedInput
    class_teachers?: class_teachersUncheckedUpdateManyWithoutTeachersNestedInput
    exams?: examsUncheckedUpdateManyWithoutTeachersNestedInput
    performance?: performanceUncheckedUpdateManyWithoutTeachersNestedInput
  }

  export type attendanceCreateWithoutStudentsInput = {
    class: number
    section: string
    date: Date | string
    status: string
    created_at?: Date | string | null
    teachers: teachersCreateNestedOneWithoutAttendanceInput
  }

  export type attendanceUncheckedCreateWithoutStudentsInput = {
    id?: number
    teacher_id: number
    class: number
    section: string
    date: Date | string
    status: string
    created_at?: Date | string | null
  }

  export type attendanceCreateOrConnectWithoutStudentsInput = {
    where: attendanceWhereUniqueInput
    create: XOR<attendanceCreateWithoutStudentsInput, attendanceUncheckedCreateWithoutStudentsInput>
  }

  export type attendanceCreateManyStudentsInputEnvelope = {
    data: attendanceCreateManyStudentsInput | attendanceCreateManyStudentsInput[]
    skipDuplicates?: boolean
  }

  export type class_representativesCreateWithoutStudentsInput = {
    class: string
    section: string
  }

  export type class_representativesUncheckedCreateWithoutStudentsInput = {
    id?: number
    class: string
    section: string
  }

  export type class_representativesCreateOrConnectWithoutStudentsInput = {
    where: class_representativesWhereUniqueInput
    create: XOR<class_representativesCreateWithoutStudentsInput, class_representativesUncheckedCreateWithoutStudentsInput>
  }

  export type class_representativesCreateManyStudentsInputEnvelope = {
    data: class_representativesCreateManyStudentsInput | class_representativesCreateManyStudentsInput[]
    skipDuplicates?: boolean
  }

  export type class_teachersCreateWithoutStudentsInput = {
    class: string
    section: string
    second_class_representative_student_id?: number | null
    teachers: teachersCreateNestedOneWithoutClass_teachersInput
  }

  export type class_teachersUncheckedCreateWithoutStudentsInput = {
    id?: number
    class: string
    section: string
    teacher_id: number
    second_class_representative_student_id?: number | null
  }

  export type class_teachersCreateOrConnectWithoutStudentsInput = {
    where: class_teachersWhereUniqueInput
    create: XOR<class_teachersCreateWithoutStudentsInput, class_teachersUncheckedCreateWithoutStudentsInput>
  }

  export type class_teachersCreateManyStudentsInputEnvelope = {
    data: class_teachersCreateManyStudentsInput | class_teachersCreateManyStudentsInput[]
    skipDuplicates?: boolean
  }

  export type financesCreateWithoutStudentsInput = {
    total_fee: Decimal | DecimalJsLike | number | string
    paid_amount?: Decimal | DecimalJsLike | number | string | null
    due_amount?: Decimal | DecimalJsLike | number | string | null
    month: string
    payment_status?: string | null
    penalty?: Decimal | DecimalJsLike | number | string | null
    expenses?: Decimal | DecimalJsLike | number | string | null
  }

  export type financesUncheckedCreateWithoutStudentsInput = {
    id?: number
    total_fee: Decimal | DecimalJsLike | number | string
    paid_amount?: Decimal | DecimalJsLike | number | string | null
    due_amount?: Decimal | DecimalJsLike | number | string | null
    month: string
    payment_status?: string | null
    penalty?: Decimal | DecimalJsLike | number | string | null
    expenses?: Decimal | DecimalJsLike | number | string | null
  }

  export type financesCreateOrConnectWithoutStudentsInput = {
    where: financesWhereUniqueInput
    create: XOR<financesCreateWithoutStudentsInput, financesUncheckedCreateWithoutStudentsInput>
  }

  export type financesCreateManyStudentsInputEnvelope = {
    data: financesCreateManyStudentsInput | financesCreateManyStudentsInput[]
    skipDuplicates?: boolean
  }

  export type student_performanceCreateWithoutStudentsInput = {
    marks_obtained: Decimal | DecimalJsLike | number | string
    total_marks: Decimal | DecimalJsLike | number | string
    performance?: performanceCreateNestedManyWithoutStudent_performanceInput
    exams?: examsCreateNestedOneWithoutStudent_performanceInput
  }

  export type student_performanceUncheckedCreateWithoutStudentsInput = {
    id?: number
    exam_id?: number | null
    marks_obtained: Decimal | DecimalJsLike | number | string
    total_marks: Decimal | DecimalJsLike | number | string
    performance?: performanceUncheckedCreateNestedManyWithoutStudent_performanceInput
  }

  export type student_performanceCreateOrConnectWithoutStudentsInput = {
    where: student_performanceWhereUniqueInput
    create: XOR<student_performanceCreateWithoutStudentsInput, student_performanceUncheckedCreateWithoutStudentsInput>
  }

  export type student_performanceCreateManyStudentsInputEnvelope = {
    data: student_performanceCreateManyStudentsInput | student_performanceCreateManyStudentsInput[]
    skipDuplicates?: boolean
  }

  export type usersCreateWithoutStudentsInput = {
    name: string
    email: string
    password: string
    role: string
    phone?: string | null
    address?: string | null
    photo?: string | null
    notes?: notesCreateNestedManyWithoutUsersInput
    notices?: noticesCreateNestedManyWithoutUsersInput
    teacher_routine?: teacher_routineCreateNestedManyWithoutUsersInput
    teachers?: teachersCreateNestedManyWithoutUsersInput
    workroom_messages_workroom_messages_receiver_idTousers?: workroom_messagesCreateNestedManyWithoutUsers_workroom_messages_receiver_idTousersInput
    workroom_messages_workroom_messages_sender_idTousers?: workroom_messagesCreateNestedManyWithoutUsers_workroom_messages_sender_idTousersInput
  }

  export type usersUncheckedCreateWithoutStudentsInput = {
    id?: number
    name: string
    email: string
    password: string
    role: string
    phone?: string | null
    address?: string | null
    photo?: string | null
    notes?: notesUncheckedCreateNestedManyWithoutUsersInput
    notices?: noticesUncheckedCreateNestedManyWithoutUsersInput
    teacher_routine?: teacher_routineUncheckedCreateNestedManyWithoutUsersInput
    teachers?: teachersUncheckedCreateNestedManyWithoutUsersInput
    workroom_messages_workroom_messages_receiver_idTousers?: workroom_messagesUncheckedCreateNestedManyWithoutUsers_workroom_messages_receiver_idTousersInput
    workroom_messages_workroom_messages_sender_idTousers?: workroom_messagesUncheckedCreateNestedManyWithoutUsers_workroom_messages_sender_idTousersInput
  }

  export type usersCreateOrConnectWithoutStudentsInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutStudentsInput, usersUncheckedCreateWithoutStudentsInput>
  }

  export type attendanceUpsertWithWhereUniqueWithoutStudentsInput = {
    where: attendanceWhereUniqueInput
    update: XOR<attendanceUpdateWithoutStudentsInput, attendanceUncheckedUpdateWithoutStudentsInput>
    create: XOR<attendanceCreateWithoutStudentsInput, attendanceUncheckedCreateWithoutStudentsInput>
  }

  export type attendanceUpdateWithWhereUniqueWithoutStudentsInput = {
    where: attendanceWhereUniqueInput
    data: XOR<attendanceUpdateWithoutStudentsInput, attendanceUncheckedUpdateWithoutStudentsInput>
  }

  export type attendanceUpdateManyWithWhereWithoutStudentsInput = {
    where: attendanceScalarWhereInput
    data: XOR<attendanceUpdateManyMutationInput, attendanceUncheckedUpdateManyWithoutStudentsInput>
  }

  export type attendanceScalarWhereInput = {
    AND?: attendanceScalarWhereInput | attendanceScalarWhereInput[]
    OR?: attendanceScalarWhereInput[]
    NOT?: attendanceScalarWhereInput | attendanceScalarWhereInput[]
    id?: IntFilter<"attendance"> | number
    student_id?: IntFilter<"attendance"> | number
    teacher_id?: IntFilter<"attendance"> | number
    class?: IntFilter<"attendance"> | number
    section?: StringFilter<"attendance"> | string
    date?: DateTimeFilter<"attendance"> | Date | string
    status?: StringFilter<"attendance"> | string
    created_at?: DateTimeNullableFilter<"attendance"> | Date | string | null
  }

  export type class_representativesUpsertWithWhereUniqueWithoutStudentsInput = {
    where: class_representativesWhereUniqueInput
    update: XOR<class_representativesUpdateWithoutStudentsInput, class_representativesUncheckedUpdateWithoutStudentsInput>
    create: XOR<class_representativesCreateWithoutStudentsInput, class_representativesUncheckedCreateWithoutStudentsInput>
  }

  export type class_representativesUpdateWithWhereUniqueWithoutStudentsInput = {
    where: class_representativesWhereUniqueInput
    data: XOR<class_representativesUpdateWithoutStudentsInput, class_representativesUncheckedUpdateWithoutStudentsInput>
  }

  export type class_representativesUpdateManyWithWhereWithoutStudentsInput = {
    where: class_representativesScalarWhereInput
    data: XOR<class_representativesUpdateManyMutationInput, class_representativesUncheckedUpdateManyWithoutStudentsInput>
  }

  export type class_representativesScalarWhereInput = {
    AND?: class_representativesScalarWhereInput | class_representativesScalarWhereInput[]
    OR?: class_representativesScalarWhereInput[]
    NOT?: class_representativesScalarWhereInput | class_representativesScalarWhereInput[]
    id?: IntFilter<"class_representatives"> | number
    student_id?: IntNullableFilter<"class_representatives"> | number | null
    class?: StringFilter<"class_representatives"> | string
    section?: StringFilter<"class_representatives"> | string
  }

  export type class_teachersUpsertWithWhereUniqueWithoutStudentsInput = {
    where: class_teachersWhereUniqueInput
    update: XOR<class_teachersUpdateWithoutStudentsInput, class_teachersUncheckedUpdateWithoutStudentsInput>
    create: XOR<class_teachersCreateWithoutStudentsInput, class_teachersUncheckedCreateWithoutStudentsInput>
  }

  export type class_teachersUpdateWithWhereUniqueWithoutStudentsInput = {
    where: class_teachersWhereUniqueInput
    data: XOR<class_teachersUpdateWithoutStudentsInput, class_teachersUncheckedUpdateWithoutStudentsInput>
  }

  export type class_teachersUpdateManyWithWhereWithoutStudentsInput = {
    where: class_teachersScalarWhereInput
    data: XOR<class_teachersUpdateManyMutationInput, class_teachersUncheckedUpdateManyWithoutStudentsInput>
  }

  export type class_teachersScalarWhereInput = {
    AND?: class_teachersScalarWhereInput | class_teachersScalarWhereInput[]
    OR?: class_teachersScalarWhereInput[]
    NOT?: class_teachersScalarWhereInput | class_teachersScalarWhereInput[]
    id?: IntFilter<"class_teachers"> | number
    class?: StringFilter<"class_teachers"> | string
    section?: StringFilter<"class_teachers"> | string
    teacher_id?: IntFilter<"class_teachers"> | number
    class_representative_student_id?: IntNullableFilter<"class_teachers"> | number | null
    second_class_representative_student_id?: IntNullableFilter<"class_teachers"> | number | null
  }

  export type financesUpsertWithWhereUniqueWithoutStudentsInput = {
    where: financesWhereUniqueInput
    update: XOR<financesUpdateWithoutStudentsInput, financesUncheckedUpdateWithoutStudentsInput>
    create: XOR<financesCreateWithoutStudentsInput, financesUncheckedCreateWithoutStudentsInput>
  }

  export type financesUpdateWithWhereUniqueWithoutStudentsInput = {
    where: financesWhereUniqueInput
    data: XOR<financesUpdateWithoutStudentsInput, financesUncheckedUpdateWithoutStudentsInput>
  }

  export type financesUpdateManyWithWhereWithoutStudentsInput = {
    where: financesScalarWhereInput
    data: XOR<financesUpdateManyMutationInput, financesUncheckedUpdateManyWithoutStudentsInput>
  }

  export type financesScalarWhereInput = {
    AND?: financesScalarWhereInput | financesScalarWhereInput[]
    OR?: financesScalarWhereInput[]
    NOT?: financesScalarWhereInput | financesScalarWhereInput[]
    id?: IntFilter<"finances"> | number
    student_id?: IntNullableFilter<"finances"> | number | null
    total_fee?: DecimalFilter<"finances"> | Decimal | DecimalJsLike | number | string
    paid_amount?: DecimalNullableFilter<"finances"> | Decimal | DecimalJsLike | number | string | null
    due_amount?: DecimalNullableFilter<"finances"> | Decimal | DecimalJsLike | number | string | null
    month?: StringFilter<"finances"> | string
    payment_status?: StringNullableFilter<"finances"> | string | null
    penalty?: DecimalNullableFilter<"finances"> | Decimal | DecimalJsLike | number | string | null
    expenses?: DecimalNullableFilter<"finances"> | Decimal | DecimalJsLike | number | string | null
  }

  export type student_performanceUpsertWithWhereUniqueWithoutStudentsInput = {
    where: student_performanceWhereUniqueInput
    update: XOR<student_performanceUpdateWithoutStudentsInput, student_performanceUncheckedUpdateWithoutStudentsInput>
    create: XOR<student_performanceCreateWithoutStudentsInput, student_performanceUncheckedCreateWithoutStudentsInput>
  }

  export type student_performanceUpdateWithWhereUniqueWithoutStudentsInput = {
    where: student_performanceWhereUniqueInput
    data: XOR<student_performanceUpdateWithoutStudentsInput, student_performanceUncheckedUpdateWithoutStudentsInput>
  }

  export type student_performanceUpdateManyWithWhereWithoutStudentsInput = {
    where: student_performanceScalarWhereInput
    data: XOR<student_performanceUpdateManyMutationInput, student_performanceUncheckedUpdateManyWithoutStudentsInput>
  }

  export type usersUpsertWithoutStudentsInput = {
    update: XOR<usersUpdateWithoutStudentsInput, usersUncheckedUpdateWithoutStudentsInput>
    create: XOR<usersCreateWithoutStudentsInput, usersUncheckedCreateWithoutStudentsInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutStudentsInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutStudentsInput, usersUncheckedUpdateWithoutStudentsInput>
  }

  export type usersUpdateWithoutStudentsInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: notesUpdateManyWithoutUsersNestedInput
    notices?: noticesUpdateManyWithoutUsersNestedInput
    teacher_routine?: teacher_routineUpdateManyWithoutUsersNestedInput
    teachers?: teachersUpdateManyWithoutUsersNestedInput
    workroom_messages_workroom_messages_receiver_idTousers?: workroom_messagesUpdateManyWithoutUsers_workroom_messages_receiver_idTousersNestedInput
    workroom_messages_workroom_messages_sender_idTousers?: workroom_messagesUpdateManyWithoutUsers_workroom_messages_sender_idTousersNestedInput
  }

  export type usersUncheckedUpdateWithoutStudentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: notesUncheckedUpdateManyWithoutUsersNestedInput
    notices?: noticesUncheckedUpdateManyWithoutUsersNestedInput
    teacher_routine?: teacher_routineUncheckedUpdateManyWithoutUsersNestedInput
    teachers?: teachersUncheckedUpdateManyWithoutUsersNestedInput
    workroom_messages_workroom_messages_receiver_idTousers?: workroom_messagesUncheckedUpdateManyWithoutUsers_workroom_messages_receiver_idTousersNestedInput
    workroom_messages_workroom_messages_sender_idTousers?: workroom_messagesUncheckedUpdateManyWithoutUsers_workroom_messages_sender_idTousersNestedInput
  }

  export type usersCreateWithoutTeacher_routineInput = {
    name: string
    email: string
    password: string
    role: string
    phone?: string | null
    address?: string | null
    photo?: string | null
    notes?: notesCreateNestedManyWithoutUsersInput
    notices?: noticesCreateNestedManyWithoutUsersInput
    students?: studentsCreateNestedManyWithoutUsersInput
    teachers?: teachersCreateNestedManyWithoutUsersInput
    workroom_messages_workroom_messages_receiver_idTousers?: workroom_messagesCreateNestedManyWithoutUsers_workroom_messages_receiver_idTousersInput
    workroom_messages_workroom_messages_sender_idTousers?: workroom_messagesCreateNestedManyWithoutUsers_workroom_messages_sender_idTousersInput
  }

  export type usersUncheckedCreateWithoutTeacher_routineInput = {
    id?: number
    name: string
    email: string
    password: string
    role: string
    phone?: string | null
    address?: string | null
    photo?: string | null
    notes?: notesUncheckedCreateNestedManyWithoutUsersInput
    notices?: noticesUncheckedCreateNestedManyWithoutUsersInput
    students?: studentsUncheckedCreateNestedManyWithoutUsersInput
    teachers?: teachersUncheckedCreateNestedManyWithoutUsersInput
    workroom_messages_workroom_messages_receiver_idTousers?: workroom_messagesUncheckedCreateNestedManyWithoutUsers_workroom_messages_receiver_idTousersInput
    workroom_messages_workroom_messages_sender_idTousers?: workroom_messagesUncheckedCreateNestedManyWithoutUsers_workroom_messages_sender_idTousersInput
  }

  export type usersCreateOrConnectWithoutTeacher_routineInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutTeacher_routineInput, usersUncheckedCreateWithoutTeacher_routineInput>
  }

  export type usersUpsertWithoutTeacher_routineInput = {
    update: XOR<usersUpdateWithoutTeacher_routineInput, usersUncheckedUpdateWithoutTeacher_routineInput>
    create: XOR<usersCreateWithoutTeacher_routineInput, usersUncheckedCreateWithoutTeacher_routineInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutTeacher_routineInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutTeacher_routineInput, usersUncheckedUpdateWithoutTeacher_routineInput>
  }

  export type usersUpdateWithoutTeacher_routineInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: notesUpdateManyWithoutUsersNestedInput
    notices?: noticesUpdateManyWithoutUsersNestedInput
    students?: studentsUpdateManyWithoutUsersNestedInput
    teachers?: teachersUpdateManyWithoutUsersNestedInput
    workroom_messages_workroom_messages_receiver_idTousers?: workroom_messagesUpdateManyWithoutUsers_workroom_messages_receiver_idTousersNestedInput
    workroom_messages_workroom_messages_sender_idTousers?: workroom_messagesUpdateManyWithoutUsers_workroom_messages_sender_idTousersNestedInput
  }

  export type usersUncheckedUpdateWithoutTeacher_routineInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: notesUncheckedUpdateManyWithoutUsersNestedInput
    notices?: noticesUncheckedUpdateManyWithoutUsersNestedInput
    students?: studentsUncheckedUpdateManyWithoutUsersNestedInput
    teachers?: teachersUncheckedUpdateManyWithoutUsersNestedInput
    workroom_messages_workroom_messages_receiver_idTousers?: workroom_messagesUncheckedUpdateManyWithoutUsers_workroom_messages_receiver_idTousersNestedInput
    workroom_messages_workroom_messages_sender_idTousers?: workroom_messagesUncheckedUpdateManyWithoutUsers_workroom_messages_sender_idTousersNestedInput
  }

  export type assignmentsCreateWithoutTeachersInput = {
    title: string
    description: string
    subject: string
    class: string
    section: string
    due_date: Date | string
    file?: string | null
  }

  export type assignmentsUncheckedCreateWithoutTeachersInput = {
    id?: number
    title: string
    description: string
    subject: string
    class: string
    section: string
    due_date: Date | string
    file?: string | null
  }

  export type assignmentsCreateOrConnectWithoutTeachersInput = {
    where: assignmentsWhereUniqueInput
    create: XOR<assignmentsCreateWithoutTeachersInput, assignmentsUncheckedCreateWithoutTeachersInput>
  }

  export type assignmentsCreateManyTeachersInputEnvelope = {
    data: assignmentsCreateManyTeachersInput | assignmentsCreateManyTeachersInput[]
    skipDuplicates?: boolean
  }

  export type attendanceCreateWithoutTeachersInput = {
    class: number
    section: string
    date: Date | string
    status: string
    created_at?: Date | string | null
    students: studentsCreateNestedOneWithoutAttendanceInput
  }

  export type attendanceUncheckedCreateWithoutTeachersInput = {
    id?: number
    student_id: number
    class: number
    section: string
    date: Date | string
    status: string
    created_at?: Date | string | null
  }

  export type attendanceCreateOrConnectWithoutTeachersInput = {
    where: attendanceWhereUniqueInput
    create: XOR<attendanceCreateWithoutTeachersInput, attendanceUncheckedCreateWithoutTeachersInput>
  }

  export type attendanceCreateManyTeachersInputEnvelope = {
    data: attendanceCreateManyTeachersInput | attendanceCreateManyTeachersInput[]
    skipDuplicates?: boolean
  }

  export type class_routineCreateWithoutTeachersInput = {
    class: string
    section: string
    day: string
    period: number
    subject: string
  }

  export type class_routineUncheckedCreateWithoutTeachersInput = {
    id?: number
    class: string
    section: string
    day: string
    period: number
    subject: string
  }

  export type class_routineCreateOrConnectWithoutTeachersInput = {
    where: class_routineWhereUniqueInput
    create: XOR<class_routineCreateWithoutTeachersInput, class_routineUncheckedCreateWithoutTeachersInput>
  }

  export type class_routineCreateManyTeachersInputEnvelope = {
    data: class_routineCreateManyTeachersInput | class_routineCreateManyTeachersInput[]
    skipDuplicates?: boolean
  }

  export type class_teachersCreateWithoutTeachersInput = {
    class: string
    section: string
    second_class_representative_student_id?: number | null
    students?: studentsCreateNestedOneWithoutClass_teachersInput
  }

  export type class_teachersUncheckedCreateWithoutTeachersInput = {
    id?: number
    class: string
    section: string
    class_representative_student_id?: number | null
    second_class_representative_student_id?: number | null
  }

  export type class_teachersCreateOrConnectWithoutTeachersInput = {
    where: class_teachersWhereUniqueInput
    create: XOR<class_teachersCreateWithoutTeachersInput, class_teachersUncheckedCreateWithoutTeachersInput>
  }

  export type class_teachersCreateManyTeachersInputEnvelope = {
    data: class_teachersCreateManyTeachersInput | class_teachersCreateManyTeachersInput[]
    skipDuplicates?: boolean
  }

  export type examsCreateWithoutTeachersInput = {
    class: string
    section: string
    subject: string
    exam_date: Date | string
    exam_duration?: string | null
    exam_type?: string | null
    performance?: performanceCreateNestedManyWithoutExamsInput
    student_performance?: student_performanceCreateNestedManyWithoutExamsInput
  }

  export type examsUncheckedCreateWithoutTeachersInput = {
    id?: number
    class: string
    section: string
    subject: string
    exam_date: Date | string
    exam_duration?: string | null
    exam_type?: string | null
    performance?: performanceUncheckedCreateNestedManyWithoutExamsInput
    student_performance?: student_performanceUncheckedCreateNestedManyWithoutExamsInput
  }

  export type examsCreateOrConnectWithoutTeachersInput = {
    where: examsWhereUniqueInput
    create: XOR<examsCreateWithoutTeachersInput, examsUncheckedCreateWithoutTeachersInput>
  }

  export type examsCreateManyTeachersInputEnvelope = {
    data: examsCreateManyTeachersInput | examsCreateManyTeachersInput[]
    skipDuplicates?: boolean
  }

  export type performanceCreateWithoutTeachersInput = {
    class: string
    section: string
    exams?: examsCreateNestedOneWithoutPerformanceInput
    student_performance?: student_performanceCreateNestedOneWithoutPerformanceInput
  }

  export type performanceUncheckedCreateWithoutTeachersInput = {
    id?: number
    class: string
    section: string
    class_performance?: number | null
    exam_id?: number | null
  }

  export type performanceCreateOrConnectWithoutTeachersInput = {
    where: performanceWhereUniqueInput
    create: XOR<performanceCreateWithoutTeachersInput, performanceUncheckedCreateWithoutTeachersInput>
  }

  export type performanceCreateManyTeachersInputEnvelope = {
    data: performanceCreateManyTeachersInput | performanceCreateManyTeachersInput[]
    skipDuplicates?: boolean
  }

  export type student_routineCreateWithoutTeachersInput = {
    class: string
    section: string
    day: string
    teacher_name: string
    teacher_subject?: string | null
    time_slot: string
  }

  export type student_routineUncheckedCreateWithoutTeachersInput = {
    id?: number
    class: string
    section: string
    day: string
    teacher_name: string
    teacher_subject?: string | null
    time_slot: string
  }

  export type student_routineCreateOrConnectWithoutTeachersInput = {
    where: student_routineWhereUniqueInput
    create: XOR<student_routineCreateWithoutTeachersInput, student_routineUncheckedCreateWithoutTeachersInput>
  }

  export type student_routineCreateManyTeachersInputEnvelope = {
    data: student_routineCreateManyTeachersInput | student_routineCreateManyTeachersInput[]
    skipDuplicates?: boolean
  }

  export type usersCreateWithoutTeachersInput = {
    name: string
    email: string
    password: string
    role: string
    phone?: string | null
    address?: string | null
    photo?: string | null
    notes?: notesCreateNestedManyWithoutUsersInput
    notices?: noticesCreateNestedManyWithoutUsersInput
    students?: studentsCreateNestedManyWithoutUsersInput
    teacher_routine?: teacher_routineCreateNestedManyWithoutUsersInput
    workroom_messages_workroom_messages_receiver_idTousers?: workroom_messagesCreateNestedManyWithoutUsers_workroom_messages_receiver_idTousersInput
    workroom_messages_workroom_messages_sender_idTousers?: workroom_messagesCreateNestedManyWithoutUsers_workroom_messages_sender_idTousersInput
  }

  export type usersUncheckedCreateWithoutTeachersInput = {
    id?: number
    name: string
    email: string
    password: string
    role: string
    phone?: string | null
    address?: string | null
    photo?: string | null
    notes?: notesUncheckedCreateNestedManyWithoutUsersInput
    notices?: noticesUncheckedCreateNestedManyWithoutUsersInput
    students?: studentsUncheckedCreateNestedManyWithoutUsersInput
    teacher_routine?: teacher_routineUncheckedCreateNestedManyWithoutUsersInput
    workroom_messages_workroom_messages_receiver_idTousers?: workroom_messagesUncheckedCreateNestedManyWithoutUsers_workroom_messages_receiver_idTousersInput
    workroom_messages_workroom_messages_sender_idTousers?: workroom_messagesUncheckedCreateNestedManyWithoutUsers_workroom_messages_sender_idTousersInput
  }

  export type usersCreateOrConnectWithoutTeachersInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutTeachersInput, usersUncheckedCreateWithoutTeachersInput>
  }

  export type assignmentsUpsertWithWhereUniqueWithoutTeachersInput = {
    where: assignmentsWhereUniqueInput
    update: XOR<assignmentsUpdateWithoutTeachersInput, assignmentsUncheckedUpdateWithoutTeachersInput>
    create: XOR<assignmentsCreateWithoutTeachersInput, assignmentsUncheckedCreateWithoutTeachersInput>
  }

  export type assignmentsUpdateWithWhereUniqueWithoutTeachersInput = {
    where: assignmentsWhereUniqueInput
    data: XOR<assignmentsUpdateWithoutTeachersInput, assignmentsUncheckedUpdateWithoutTeachersInput>
  }

  export type assignmentsUpdateManyWithWhereWithoutTeachersInput = {
    where: assignmentsScalarWhereInput
    data: XOR<assignmentsUpdateManyMutationInput, assignmentsUncheckedUpdateManyWithoutTeachersInput>
  }

  export type assignmentsScalarWhereInput = {
    AND?: assignmentsScalarWhereInput | assignmentsScalarWhereInput[]
    OR?: assignmentsScalarWhereInput[]
    NOT?: assignmentsScalarWhereInput | assignmentsScalarWhereInput[]
    id?: IntFilter<"assignments"> | number
    title?: StringFilter<"assignments"> | string
    description?: StringFilter<"assignments"> | string
    subject?: StringFilter<"assignments"> | string
    class?: StringFilter<"assignments"> | string
    section?: StringFilter<"assignments"> | string
    assigned_by?: IntNullableFilter<"assignments"> | number | null
    due_date?: DateTimeFilter<"assignments"> | Date | string
    file?: StringNullableFilter<"assignments"> | string | null
  }

  export type attendanceUpsertWithWhereUniqueWithoutTeachersInput = {
    where: attendanceWhereUniqueInput
    update: XOR<attendanceUpdateWithoutTeachersInput, attendanceUncheckedUpdateWithoutTeachersInput>
    create: XOR<attendanceCreateWithoutTeachersInput, attendanceUncheckedCreateWithoutTeachersInput>
  }

  export type attendanceUpdateWithWhereUniqueWithoutTeachersInput = {
    where: attendanceWhereUniqueInput
    data: XOR<attendanceUpdateWithoutTeachersInput, attendanceUncheckedUpdateWithoutTeachersInput>
  }

  export type attendanceUpdateManyWithWhereWithoutTeachersInput = {
    where: attendanceScalarWhereInput
    data: XOR<attendanceUpdateManyMutationInput, attendanceUncheckedUpdateManyWithoutTeachersInput>
  }

  export type class_routineUpsertWithWhereUniqueWithoutTeachersInput = {
    where: class_routineWhereUniqueInput
    update: XOR<class_routineUpdateWithoutTeachersInput, class_routineUncheckedUpdateWithoutTeachersInput>
    create: XOR<class_routineCreateWithoutTeachersInput, class_routineUncheckedCreateWithoutTeachersInput>
  }

  export type class_routineUpdateWithWhereUniqueWithoutTeachersInput = {
    where: class_routineWhereUniqueInput
    data: XOR<class_routineUpdateWithoutTeachersInput, class_routineUncheckedUpdateWithoutTeachersInput>
  }

  export type class_routineUpdateManyWithWhereWithoutTeachersInput = {
    where: class_routineScalarWhereInput
    data: XOR<class_routineUpdateManyMutationInput, class_routineUncheckedUpdateManyWithoutTeachersInput>
  }

  export type class_routineScalarWhereInput = {
    AND?: class_routineScalarWhereInput | class_routineScalarWhereInput[]
    OR?: class_routineScalarWhereInput[]
    NOT?: class_routineScalarWhereInput | class_routineScalarWhereInput[]
    id?: IntFilter<"class_routine"> | number
    class?: StringFilter<"class_routine"> | string
    section?: StringFilter<"class_routine"> | string
    day?: StringFilter<"class_routine"> | string
    period?: IntFilter<"class_routine"> | number
    subject?: StringFilter<"class_routine"> | string
    teacher_id?: IntNullableFilter<"class_routine"> | number | null
  }

  export type class_teachersUpsertWithWhereUniqueWithoutTeachersInput = {
    where: class_teachersWhereUniqueInput
    update: XOR<class_teachersUpdateWithoutTeachersInput, class_teachersUncheckedUpdateWithoutTeachersInput>
    create: XOR<class_teachersCreateWithoutTeachersInput, class_teachersUncheckedCreateWithoutTeachersInput>
  }

  export type class_teachersUpdateWithWhereUniqueWithoutTeachersInput = {
    where: class_teachersWhereUniqueInput
    data: XOR<class_teachersUpdateWithoutTeachersInput, class_teachersUncheckedUpdateWithoutTeachersInput>
  }

  export type class_teachersUpdateManyWithWhereWithoutTeachersInput = {
    where: class_teachersScalarWhereInput
    data: XOR<class_teachersUpdateManyMutationInput, class_teachersUncheckedUpdateManyWithoutTeachersInput>
  }

  export type examsUpsertWithWhereUniqueWithoutTeachersInput = {
    where: examsWhereUniqueInput
    update: XOR<examsUpdateWithoutTeachersInput, examsUncheckedUpdateWithoutTeachersInput>
    create: XOR<examsCreateWithoutTeachersInput, examsUncheckedCreateWithoutTeachersInput>
  }

  export type examsUpdateWithWhereUniqueWithoutTeachersInput = {
    where: examsWhereUniqueInput
    data: XOR<examsUpdateWithoutTeachersInput, examsUncheckedUpdateWithoutTeachersInput>
  }

  export type examsUpdateManyWithWhereWithoutTeachersInput = {
    where: examsScalarWhereInput
    data: XOR<examsUpdateManyMutationInput, examsUncheckedUpdateManyWithoutTeachersInput>
  }

  export type examsScalarWhereInput = {
    AND?: examsScalarWhereInput | examsScalarWhereInput[]
    OR?: examsScalarWhereInput[]
    NOT?: examsScalarWhereInput | examsScalarWhereInput[]
    id?: IntFilter<"exams"> | number
    class?: StringFilter<"exams"> | string
    section?: StringFilter<"exams"> | string
    subject?: StringFilter<"exams"> | string
    exam_date?: DateTimeFilter<"exams"> | Date | string
    exam_duration?: StringNullableFilter<"exams"> | string | null
    exam_type?: StringNullableFilter<"exams"> | string | null
    created_by?: IntNullableFilter<"exams"> | number | null
  }

  export type performanceUpsertWithWhereUniqueWithoutTeachersInput = {
    where: performanceWhereUniqueInput
    update: XOR<performanceUpdateWithoutTeachersInput, performanceUncheckedUpdateWithoutTeachersInput>
    create: XOR<performanceCreateWithoutTeachersInput, performanceUncheckedCreateWithoutTeachersInput>
  }

  export type performanceUpdateWithWhereUniqueWithoutTeachersInput = {
    where: performanceWhereUniqueInput
    data: XOR<performanceUpdateWithoutTeachersInput, performanceUncheckedUpdateWithoutTeachersInput>
  }

  export type performanceUpdateManyWithWhereWithoutTeachersInput = {
    where: performanceScalarWhereInput
    data: XOR<performanceUpdateManyMutationInput, performanceUncheckedUpdateManyWithoutTeachersInput>
  }

  export type student_routineUpsertWithWhereUniqueWithoutTeachersInput = {
    where: student_routineWhereUniqueInput
    update: XOR<student_routineUpdateWithoutTeachersInput, student_routineUncheckedUpdateWithoutTeachersInput>
    create: XOR<student_routineCreateWithoutTeachersInput, student_routineUncheckedCreateWithoutTeachersInput>
  }

  export type student_routineUpdateWithWhereUniqueWithoutTeachersInput = {
    where: student_routineWhereUniqueInput
    data: XOR<student_routineUpdateWithoutTeachersInput, student_routineUncheckedUpdateWithoutTeachersInput>
  }

  export type student_routineUpdateManyWithWhereWithoutTeachersInput = {
    where: student_routineScalarWhereInput
    data: XOR<student_routineUpdateManyMutationInput, student_routineUncheckedUpdateManyWithoutTeachersInput>
  }

  export type student_routineScalarWhereInput = {
    AND?: student_routineScalarWhereInput | student_routineScalarWhereInput[]
    OR?: student_routineScalarWhereInput[]
    NOT?: student_routineScalarWhereInput | student_routineScalarWhereInput[]
    id?: IntFilter<"student_routine"> | number
    class?: StringFilter<"student_routine"> | string
    section?: StringFilter<"student_routine"> | string
    day?: StringFilter<"student_routine"> | string
    teacher_id?: IntFilter<"student_routine"> | number
    teacher_name?: StringFilter<"student_routine"> | string
    teacher_subject?: StringNullableFilter<"student_routine"> | string | null
    time_slot?: StringFilter<"student_routine"> | string
  }

  export type usersUpsertWithoutTeachersInput = {
    update: XOR<usersUpdateWithoutTeachersInput, usersUncheckedUpdateWithoutTeachersInput>
    create: XOR<usersCreateWithoutTeachersInput, usersUncheckedCreateWithoutTeachersInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutTeachersInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutTeachersInput, usersUncheckedUpdateWithoutTeachersInput>
  }

  export type usersUpdateWithoutTeachersInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: notesUpdateManyWithoutUsersNestedInput
    notices?: noticesUpdateManyWithoutUsersNestedInput
    students?: studentsUpdateManyWithoutUsersNestedInput
    teacher_routine?: teacher_routineUpdateManyWithoutUsersNestedInput
    workroom_messages_workroom_messages_receiver_idTousers?: workroom_messagesUpdateManyWithoutUsers_workroom_messages_receiver_idTousersNestedInput
    workroom_messages_workroom_messages_sender_idTousers?: workroom_messagesUpdateManyWithoutUsers_workroom_messages_sender_idTousersNestedInput
  }

  export type usersUncheckedUpdateWithoutTeachersInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: notesUncheckedUpdateManyWithoutUsersNestedInput
    notices?: noticesUncheckedUpdateManyWithoutUsersNestedInput
    students?: studentsUncheckedUpdateManyWithoutUsersNestedInput
    teacher_routine?: teacher_routineUncheckedUpdateManyWithoutUsersNestedInput
    workroom_messages_workroom_messages_receiver_idTousers?: workroom_messagesUncheckedUpdateManyWithoutUsers_workroom_messages_receiver_idTousersNestedInput
    workroom_messages_workroom_messages_sender_idTousers?: workroom_messagesUncheckedUpdateManyWithoutUsers_workroom_messages_sender_idTousersNestedInput
  }

  export type calendarCreateWithoutUpcoming_eventsInput = {
    month: string
    calendar: string
    year?: number | null
  }

  export type calendarUncheckedCreateWithoutUpcoming_eventsInput = {
    id?: number
    month: string
    calendar: string
    year?: number | null
  }

  export type calendarCreateOrConnectWithoutUpcoming_eventsInput = {
    where: calendarWhereUniqueInput
    create: XOR<calendarCreateWithoutUpcoming_eventsInput, calendarUncheckedCreateWithoutUpcoming_eventsInput>
  }

  export type calendarUpsertWithoutUpcoming_eventsInput = {
    update: XOR<calendarUpdateWithoutUpcoming_eventsInput, calendarUncheckedUpdateWithoutUpcoming_eventsInput>
    create: XOR<calendarCreateWithoutUpcoming_eventsInput, calendarUncheckedCreateWithoutUpcoming_eventsInput>
    where?: calendarWhereInput
  }

  export type calendarUpdateToOneWithWhereWithoutUpcoming_eventsInput = {
    where?: calendarWhereInput
    data: XOR<calendarUpdateWithoutUpcoming_eventsInput, calendarUncheckedUpdateWithoutUpcoming_eventsInput>
  }

  export type calendarUpdateWithoutUpcoming_eventsInput = {
    month?: StringFieldUpdateOperationsInput | string
    calendar?: StringFieldUpdateOperationsInput | string
    year?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type calendarUncheckedUpdateWithoutUpcoming_eventsInput = {
    id?: IntFieldUpdateOperationsInput | number
    month?: StringFieldUpdateOperationsInput | string
    calendar?: StringFieldUpdateOperationsInput | string
    year?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type notesCreateWithoutUsersInput = {
    title: string
    content: string
    subject: string
    class: string
    section: string
    files?: string | null
    created_at?: Date | string | null
  }

  export type notesUncheckedCreateWithoutUsersInput = {
    id?: number
    title: string
    content: string
    subject: string
    class: string
    section: string
    files?: string | null
    created_at?: Date | string | null
  }

  export type notesCreateOrConnectWithoutUsersInput = {
    where: notesWhereUniqueInput
    create: XOR<notesCreateWithoutUsersInput, notesUncheckedCreateWithoutUsersInput>
  }

  export type notesCreateManyUsersInputEnvelope = {
    data: notesCreateManyUsersInput | notesCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type noticesCreateWithoutUsersInput = {
    title: string
    content: string
    created_at?: Date | string | null
    target_role: string
  }

  export type noticesUncheckedCreateWithoutUsersInput = {
    id?: number
    title: string
    content: string
    created_at?: Date | string | null
    target_role: string
  }

  export type noticesCreateOrConnectWithoutUsersInput = {
    where: noticesWhereUniqueInput
    create: XOR<noticesCreateWithoutUsersInput, noticesUncheckedCreateWithoutUsersInput>
  }

  export type noticesCreateManyUsersInputEnvelope = {
    data: noticesCreateManyUsersInput | noticesCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type studentsCreateWithoutUsersInput = {
    admission_number: string
    class: string
    section: string
    parent_name?: string | null
    parent_phone?: string | null
    parent_email?: string | null
    parent_work?: string | null
    parent_photo1?: string | null
    parent_photo2?: string | null
    guardian_photo?: string | null
    guardian_phone?: string | null
    roll_number?: number | null
    attendance?: attendanceCreateNestedManyWithoutStudentsInput
    class_representatives?: class_representativesCreateNestedManyWithoutStudentsInput
    class_teachers?: class_teachersCreateNestedManyWithoutStudentsInput
    finances?: financesCreateNestedManyWithoutStudentsInput
    student_performance?: student_performanceCreateNestedManyWithoutStudentsInput
  }

  export type studentsUncheckedCreateWithoutUsersInput = {
    id?: number
    admission_number: string
    class: string
    section: string
    parent_name?: string | null
    parent_phone?: string | null
    parent_email?: string | null
    parent_work?: string | null
    parent_photo1?: string | null
    parent_photo2?: string | null
    guardian_photo?: string | null
    guardian_phone?: string | null
    roll_number?: number | null
    attendance?: attendanceUncheckedCreateNestedManyWithoutStudentsInput
    class_representatives?: class_representativesUncheckedCreateNestedManyWithoutStudentsInput
    class_teachers?: class_teachersUncheckedCreateNestedManyWithoutStudentsInput
    finances?: financesUncheckedCreateNestedManyWithoutStudentsInput
    student_performance?: student_performanceUncheckedCreateNestedManyWithoutStudentsInput
  }

  export type studentsCreateOrConnectWithoutUsersInput = {
    where: studentsWhereUniqueInput
    create: XOR<studentsCreateWithoutUsersInput, studentsUncheckedCreateWithoutUsersInput>
  }

  export type studentsCreateManyUsersInputEnvelope = {
    data: studentsCreateManyUsersInput | studentsCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type teacher_routineCreateWithoutUsersInput = {
    day: string
    time_slot: string
    class: string
    section: string
  }

  export type teacher_routineUncheckedCreateWithoutUsersInput = {
    id?: number
    day: string
    time_slot: string
    class: string
    section: string
  }

  export type teacher_routineCreateOrConnectWithoutUsersInput = {
    where: teacher_routineWhereUniqueInput
    create: XOR<teacher_routineCreateWithoutUsersInput, teacher_routineUncheckedCreateWithoutUsersInput>
  }

  export type teacher_routineCreateManyUsersInputEnvelope = {
    data: teacher_routineCreateManyUsersInput | teacher_routineCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type teachersCreateWithoutUsersInput = {
    specialised_subject: string
    assigned_class?: string | null
    assigned_section?: string | null
    assignments?: assignmentsCreateNestedManyWithoutTeachersInput
    attendance?: attendanceCreateNestedManyWithoutTeachersInput
    class_routine?: class_routineCreateNestedManyWithoutTeachersInput
    class_teachers?: class_teachersCreateNestedManyWithoutTeachersInput
    exams?: examsCreateNestedManyWithoutTeachersInput
    performance?: performanceCreateNestedManyWithoutTeachersInput
    student_routine?: student_routineCreateNestedManyWithoutTeachersInput
  }

  export type teachersUncheckedCreateWithoutUsersInput = {
    id?: number
    specialised_subject: string
    assigned_class?: string | null
    assigned_section?: string | null
    assignments?: assignmentsUncheckedCreateNestedManyWithoutTeachersInput
    attendance?: attendanceUncheckedCreateNestedManyWithoutTeachersInput
    class_routine?: class_routineUncheckedCreateNestedManyWithoutTeachersInput
    class_teachers?: class_teachersUncheckedCreateNestedManyWithoutTeachersInput
    exams?: examsUncheckedCreateNestedManyWithoutTeachersInput
    performance?: performanceUncheckedCreateNestedManyWithoutTeachersInput
    student_routine?: student_routineUncheckedCreateNestedManyWithoutTeachersInput
  }

  export type teachersCreateOrConnectWithoutUsersInput = {
    where: teachersWhereUniqueInput
    create: XOR<teachersCreateWithoutUsersInput, teachersUncheckedCreateWithoutUsersInput>
  }

  export type teachersCreateManyUsersInputEnvelope = {
    data: teachersCreateManyUsersInput | teachersCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type workroom_messagesCreateWithoutUsers_workroom_messages_receiver_idTousersInput = {
    message: string
    sent_at?: Date | string | null
    users_workroom_messages_sender_idTousers?: usersCreateNestedOneWithoutWorkroom_messages_workroom_messages_sender_idTousersInput
  }

  export type workroom_messagesUncheckedCreateWithoutUsers_workroom_messages_receiver_idTousersInput = {
    id?: number
    sender_id?: number | null
    message: string
    sent_at?: Date | string | null
  }

  export type workroom_messagesCreateOrConnectWithoutUsers_workroom_messages_receiver_idTousersInput = {
    where: workroom_messagesWhereUniqueInput
    create: XOR<workroom_messagesCreateWithoutUsers_workroom_messages_receiver_idTousersInput, workroom_messagesUncheckedCreateWithoutUsers_workroom_messages_receiver_idTousersInput>
  }

  export type workroom_messagesCreateManyUsers_workroom_messages_receiver_idTousersInputEnvelope = {
    data: workroom_messagesCreateManyUsers_workroom_messages_receiver_idTousersInput | workroom_messagesCreateManyUsers_workroom_messages_receiver_idTousersInput[]
    skipDuplicates?: boolean
  }

  export type workroom_messagesCreateWithoutUsers_workroom_messages_sender_idTousersInput = {
    message: string
    sent_at?: Date | string | null
    users_workroom_messages_receiver_idTousers?: usersCreateNestedOneWithoutWorkroom_messages_workroom_messages_receiver_idTousersInput
  }

  export type workroom_messagesUncheckedCreateWithoutUsers_workroom_messages_sender_idTousersInput = {
    id?: number
    receiver_id?: number | null
    message: string
    sent_at?: Date | string | null
  }

  export type workroom_messagesCreateOrConnectWithoutUsers_workroom_messages_sender_idTousersInput = {
    where: workroom_messagesWhereUniqueInput
    create: XOR<workroom_messagesCreateWithoutUsers_workroom_messages_sender_idTousersInput, workroom_messagesUncheckedCreateWithoutUsers_workroom_messages_sender_idTousersInput>
  }

  export type workroom_messagesCreateManyUsers_workroom_messages_sender_idTousersInputEnvelope = {
    data: workroom_messagesCreateManyUsers_workroom_messages_sender_idTousersInput | workroom_messagesCreateManyUsers_workroom_messages_sender_idTousersInput[]
    skipDuplicates?: boolean
  }

  export type notesUpsertWithWhereUniqueWithoutUsersInput = {
    where: notesWhereUniqueInput
    update: XOR<notesUpdateWithoutUsersInput, notesUncheckedUpdateWithoutUsersInput>
    create: XOR<notesCreateWithoutUsersInput, notesUncheckedCreateWithoutUsersInput>
  }

  export type notesUpdateWithWhereUniqueWithoutUsersInput = {
    where: notesWhereUniqueInput
    data: XOR<notesUpdateWithoutUsersInput, notesUncheckedUpdateWithoutUsersInput>
  }

  export type notesUpdateManyWithWhereWithoutUsersInput = {
    where: notesScalarWhereInput
    data: XOR<notesUpdateManyMutationInput, notesUncheckedUpdateManyWithoutUsersInput>
  }

  export type notesScalarWhereInput = {
    AND?: notesScalarWhereInput | notesScalarWhereInput[]
    OR?: notesScalarWhereInput[]
    NOT?: notesScalarWhereInput | notesScalarWhereInput[]
    id?: IntFilter<"notes"> | number
    title?: StringFilter<"notes"> | string
    content?: StringFilter<"notes"> | string
    subject?: StringFilter<"notes"> | string
    class?: StringFilter<"notes"> | string
    section?: StringFilter<"notes"> | string
    created_by?: IntNullableFilter<"notes"> | number | null
    files?: StringNullableFilter<"notes"> | string | null
    created_at?: DateTimeNullableFilter<"notes"> | Date | string | null
  }

  export type noticesUpsertWithWhereUniqueWithoutUsersInput = {
    where: noticesWhereUniqueInput
    update: XOR<noticesUpdateWithoutUsersInput, noticesUncheckedUpdateWithoutUsersInput>
    create: XOR<noticesCreateWithoutUsersInput, noticesUncheckedCreateWithoutUsersInput>
  }

  export type noticesUpdateWithWhereUniqueWithoutUsersInput = {
    where: noticesWhereUniqueInput
    data: XOR<noticesUpdateWithoutUsersInput, noticesUncheckedUpdateWithoutUsersInput>
  }

  export type noticesUpdateManyWithWhereWithoutUsersInput = {
    where: noticesScalarWhereInput
    data: XOR<noticesUpdateManyMutationInput, noticesUncheckedUpdateManyWithoutUsersInput>
  }

  export type noticesScalarWhereInput = {
    AND?: noticesScalarWhereInput | noticesScalarWhereInput[]
    OR?: noticesScalarWhereInput[]
    NOT?: noticesScalarWhereInput | noticesScalarWhereInput[]
    id?: IntFilter<"notices"> | number
    title?: StringFilter<"notices"> | string
    content?: StringFilter<"notices"> | string
    created_at?: DateTimeNullableFilter<"notices"> | Date | string | null
    created_by?: IntNullableFilter<"notices"> | number | null
    target_role?: StringFilter<"notices"> | string
  }

  export type studentsUpsertWithWhereUniqueWithoutUsersInput = {
    where: studentsWhereUniqueInput
    update: XOR<studentsUpdateWithoutUsersInput, studentsUncheckedUpdateWithoutUsersInput>
    create: XOR<studentsCreateWithoutUsersInput, studentsUncheckedCreateWithoutUsersInput>
  }

  export type studentsUpdateWithWhereUniqueWithoutUsersInput = {
    where: studentsWhereUniqueInput
    data: XOR<studentsUpdateWithoutUsersInput, studentsUncheckedUpdateWithoutUsersInput>
  }

  export type studentsUpdateManyWithWhereWithoutUsersInput = {
    where: studentsScalarWhereInput
    data: XOR<studentsUpdateManyMutationInput, studentsUncheckedUpdateManyWithoutUsersInput>
  }

  export type studentsScalarWhereInput = {
    AND?: studentsScalarWhereInput | studentsScalarWhereInput[]
    OR?: studentsScalarWhereInput[]
    NOT?: studentsScalarWhereInput | studentsScalarWhereInput[]
    id?: IntFilter<"students"> | number
    user_id?: IntNullableFilter<"students"> | number | null
    admission_number?: StringFilter<"students"> | string
    class?: StringFilter<"students"> | string
    section?: StringFilter<"students"> | string
    parent_name?: StringNullableFilter<"students"> | string | null
    parent_phone?: StringNullableFilter<"students"> | string | null
    parent_email?: StringNullableFilter<"students"> | string | null
    parent_work?: StringNullableFilter<"students"> | string | null
    parent_photo1?: StringNullableFilter<"students"> | string | null
    parent_photo2?: StringNullableFilter<"students"> | string | null
    guardian_photo?: StringNullableFilter<"students"> | string | null
    guardian_phone?: StringNullableFilter<"students"> | string | null
    roll_number?: IntNullableFilter<"students"> | number | null
  }

  export type teacher_routineUpsertWithWhereUniqueWithoutUsersInput = {
    where: teacher_routineWhereUniqueInput
    update: XOR<teacher_routineUpdateWithoutUsersInput, teacher_routineUncheckedUpdateWithoutUsersInput>
    create: XOR<teacher_routineCreateWithoutUsersInput, teacher_routineUncheckedCreateWithoutUsersInput>
  }

  export type teacher_routineUpdateWithWhereUniqueWithoutUsersInput = {
    where: teacher_routineWhereUniqueInput
    data: XOR<teacher_routineUpdateWithoutUsersInput, teacher_routineUncheckedUpdateWithoutUsersInput>
  }

  export type teacher_routineUpdateManyWithWhereWithoutUsersInput = {
    where: teacher_routineScalarWhereInput
    data: XOR<teacher_routineUpdateManyMutationInput, teacher_routineUncheckedUpdateManyWithoutUsersInput>
  }

  export type teacher_routineScalarWhereInput = {
    AND?: teacher_routineScalarWhereInput | teacher_routineScalarWhereInput[]
    OR?: teacher_routineScalarWhereInput[]
    NOT?: teacher_routineScalarWhereInput | teacher_routineScalarWhereInput[]
    id?: IntFilter<"teacher_routine"> | number
    teacher_id?: IntFilter<"teacher_routine"> | number
    day?: StringFilter<"teacher_routine"> | string
    time_slot?: StringFilter<"teacher_routine"> | string
    class?: StringFilter<"teacher_routine"> | string
    section?: StringFilter<"teacher_routine"> | string
  }

  export type teachersUpsertWithWhereUniqueWithoutUsersInput = {
    where: teachersWhereUniqueInput
    update: XOR<teachersUpdateWithoutUsersInput, teachersUncheckedUpdateWithoutUsersInput>
    create: XOR<teachersCreateWithoutUsersInput, teachersUncheckedCreateWithoutUsersInput>
  }

  export type teachersUpdateWithWhereUniqueWithoutUsersInput = {
    where: teachersWhereUniqueInput
    data: XOR<teachersUpdateWithoutUsersInput, teachersUncheckedUpdateWithoutUsersInput>
  }

  export type teachersUpdateManyWithWhereWithoutUsersInput = {
    where: teachersScalarWhereInput
    data: XOR<teachersUpdateManyMutationInput, teachersUncheckedUpdateManyWithoutUsersInput>
  }

  export type teachersScalarWhereInput = {
    AND?: teachersScalarWhereInput | teachersScalarWhereInput[]
    OR?: teachersScalarWhereInput[]
    NOT?: teachersScalarWhereInput | teachersScalarWhereInput[]
    id?: IntFilter<"teachers"> | number
    user_id?: IntNullableFilter<"teachers"> | number | null
    specialised_subject?: StringFilter<"teachers"> | string
    assigned_class?: StringNullableFilter<"teachers"> | string | null
    assigned_section?: StringNullableFilter<"teachers"> | string | null
  }

  export type workroom_messagesUpsertWithWhereUniqueWithoutUsers_workroom_messages_receiver_idTousersInput = {
    where: workroom_messagesWhereUniqueInput
    update: XOR<workroom_messagesUpdateWithoutUsers_workroom_messages_receiver_idTousersInput, workroom_messagesUncheckedUpdateWithoutUsers_workroom_messages_receiver_idTousersInput>
    create: XOR<workroom_messagesCreateWithoutUsers_workroom_messages_receiver_idTousersInput, workroom_messagesUncheckedCreateWithoutUsers_workroom_messages_receiver_idTousersInput>
  }

  export type workroom_messagesUpdateWithWhereUniqueWithoutUsers_workroom_messages_receiver_idTousersInput = {
    where: workroom_messagesWhereUniqueInput
    data: XOR<workroom_messagesUpdateWithoutUsers_workroom_messages_receiver_idTousersInput, workroom_messagesUncheckedUpdateWithoutUsers_workroom_messages_receiver_idTousersInput>
  }

  export type workroom_messagesUpdateManyWithWhereWithoutUsers_workroom_messages_receiver_idTousersInput = {
    where: workroom_messagesScalarWhereInput
    data: XOR<workroom_messagesUpdateManyMutationInput, workroom_messagesUncheckedUpdateManyWithoutUsers_workroom_messages_receiver_idTousersInput>
  }

  export type workroom_messagesScalarWhereInput = {
    AND?: workroom_messagesScalarWhereInput | workroom_messagesScalarWhereInput[]
    OR?: workroom_messagesScalarWhereInput[]
    NOT?: workroom_messagesScalarWhereInput | workroom_messagesScalarWhereInput[]
    id?: IntFilter<"workroom_messages"> | number
    sender_id?: IntNullableFilter<"workroom_messages"> | number | null
    receiver_id?: IntNullableFilter<"workroom_messages"> | number | null
    message?: StringFilter<"workroom_messages"> | string
    sent_at?: DateTimeNullableFilter<"workroom_messages"> | Date | string | null
  }

  export type workroom_messagesUpsertWithWhereUniqueWithoutUsers_workroom_messages_sender_idTousersInput = {
    where: workroom_messagesWhereUniqueInput
    update: XOR<workroom_messagesUpdateWithoutUsers_workroom_messages_sender_idTousersInput, workroom_messagesUncheckedUpdateWithoutUsers_workroom_messages_sender_idTousersInput>
    create: XOR<workroom_messagesCreateWithoutUsers_workroom_messages_sender_idTousersInput, workroom_messagesUncheckedCreateWithoutUsers_workroom_messages_sender_idTousersInput>
  }

  export type workroom_messagesUpdateWithWhereUniqueWithoutUsers_workroom_messages_sender_idTousersInput = {
    where: workroom_messagesWhereUniqueInput
    data: XOR<workroom_messagesUpdateWithoutUsers_workroom_messages_sender_idTousersInput, workroom_messagesUncheckedUpdateWithoutUsers_workroom_messages_sender_idTousersInput>
  }

  export type workroom_messagesUpdateManyWithWhereWithoutUsers_workroom_messages_sender_idTousersInput = {
    where: workroom_messagesScalarWhereInput
    data: XOR<workroom_messagesUpdateManyMutationInput, workroom_messagesUncheckedUpdateManyWithoutUsers_workroom_messages_sender_idTousersInput>
  }

  export type usersCreateWithoutWorkroom_messages_workroom_messages_receiver_idTousersInput = {
    name: string
    email: string
    password: string
    role: string
    phone?: string | null
    address?: string | null
    photo?: string | null
    notes?: notesCreateNestedManyWithoutUsersInput
    notices?: noticesCreateNestedManyWithoutUsersInput
    students?: studentsCreateNestedManyWithoutUsersInput
    teacher_routine?: teacher_routineCreateNestedManyWithoutUsersInput
    teachers?: teachersCreateNestedManyWithoutUsersInput
    workroom_messages_workroom_messages_sender_idTousers?: workroom_messagesCreateNestedManyWithoutUsers_workroom_messages_sender_idTousersInput
  }

  export type usersUncheckedCreateWithoutWorkroom_messages_workroom_messages_receiver_idTousersInput = {
    id?: number
    name: string
    email: string
    password: string
    role: string
    phone?: string | null
    address?: string | null
    photo?: string | null
    notes?: notesUncheckedCreateNestedManyWithoutUsersInput
    notices?: noticesUncheckedCreateNestedManyWithoutUsersInput
    students?: studentsUncheckedCreateNestedManyWithoutUsersInput
    teacher_routine?: teacher_routineUncheckedCreateNestedManyWithoutUsersInput
    teachers?: teachersUncheckedCreateNestedManyWithoutUsersInput
    workroom_messages_workroom_messages_sender_idTousers?: workroom_messagesUncheckedCreateNestedManyWithoutUsers_workroom_messages_sender_idTousersInput
  }

  export type usersCreateOrConnectWithoutWorkroom_messages_workroom_messages_receiver_idTousersInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutWorkroom_messages_workroom_messages_receiver_idTousersInput, usersUncheckedCreateWithoutWorkroom_messages_workroom_messages_receiver_idTousersInput>
  }

  export type usersCreateWithoutWorkroom_messages_workroom_messages_sender_idTousersInput = {
    name: string
    email: string
    password: string
    role: string
    phone?: string | null
    address?: string | null
    photo?: string | null
    notes?: notesCreateNestedManyWithoutUsersInput
    notices?: noticesCreateNestedManyWithoutUsersInput
    students?: studentsCreateNestedManyWithoutUsersInput
    teacher_routine?: teacher_routineCreateNestedManyWithoutUsersInput
    teachers?: teachersCreateNestedManyWithoutUsersInput
    workroom_messages_workroom_messages_receiver_idTousers?: workroom_messagesCreateNestedManyWithoutUsers_workroom_messages_receiver_idTousersInput
  }

  export type usersUncheckedCreateWithoutWorkroom_messages_workroom_messages_sender_idTousersInput = {
    id?: number
    name: string
    email: string
    password: string
    role: string
    phone?: string | null
    address?: string | null
    photo?: string | null
    notes?: notesUncheckedCreateNestedManyWithoutUsersInput
    notices?: noticesUncheckedCreateNestedManyWithoutUsersInput
    students?: studentsUncheckedCreateNestedManyWithoutUsersInput
    teacher_routine?: teacher_routineUncheckedCreateNestedManyWithoutUsersInput
    teachers?: teachersUncheckedCreateNestedManyWithoutUsersInput
    workroom_messages_workroom_messages_receiver_idTousers?: workroom_messagesUncheckedCreateNestedManyWithoutUsers_workroom_messages_receiver_idTousersInput
  }

  export type usersCreateOrConnectWithoutWorkroom_messages_workroom_messages_sender_idTousersInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutWorkroom_messages_workroom_messages_sender_idTousersInput, usersUncheckedCreateWithoutWorkroom_messages_workroom_messages_sender_idTousersInput>
  }

  export type usersUpsertWithoutWorkroom_messages_workroom_messages_receiver_idTousersInput = {
    update: XOR<usersUpdateWithoutWorkroom_messages_workroom_messages_receiver_idTousersInput, usersUncheckedUpdateWithoutWorkroom_messages_workroom_messages_receiver_idTousersInput>
    create: XOR<usersCreateWithoutWorkroom_messages_workroom_messages_receiver_idTousersInput, usersUncheckedCreateWithoutWorkroom_messages_workroom_messages_receiver_idTousersInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutWorkroom_messages_workroom_messages_receiver_idTousersInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutWorkroom_messages_workroom_messages_receiver_idTousersInput, usersUncheckedUpdateWithoutWorkroom_messages_workroom_messages_receiver_idTousersInput>
  }

  export type usersUpdateWithoutWorkroom_messages_workroom_messages_receiver_idTousersInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: notesUpdateManyWithoutUsersNestedInput
    notices?: noticesUpdateManyWithoutUsersNestedInput
    students?: studentsUpdateManyWithoutUsersNestedInput
    teacher_routine?: teacher_routineUpdateManyWithoutUsersNestedInput
    teachers?: teachersUpdateManyWithoutUsersNestedInput
    workroom_messages_workroom_messages_sender_idTousers?: workroom_messagesUpdateManyWithoutUsers_workroom_messages_sender_idTousersNestedInput
  }

  export type usersUncheckedUpdateWithoutWorkroom_messages_workroom_messages_receiver_idTousersInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: notesUncheckedUpdateManyWithoutUsersNestedInput
    notices?: noticesUncheckedUpdateManyWithoutUsersNestedInput
    students?: studentsUncheckedUpdateManyWithoutUsersNestedInput
    teacher_routine?: teacher_routineUncheckedUpdateManyWithoutUsersNestedInput
    teachers?: teachersUncheckedUpdateManyWithoutUsersNestedInput
    workroom_messages_workroom_messages_sender_idTousers?: workroom_messagesUncheckedUpdateManyWithoutUsers_workroom_messages_sender_idTousersNestedInput
  }

  export type usersUpsertWithoutWorkroom_messages_workroom_messages_sender_idTousersInput = {
    update: XOR<usersUpdateWithoutWorkroom_messages_workroom_messages_sender_idTousersInput, usersUncheckedUpdateWithoutWorkroom_messages_workroom_messages_sender_idTousersInput>
    create: XOR<usersCreateWithoutWorkroom_messages_workroom_messages_sender_idTousersInput, usersUncheckedCreateWithoutWorkroom_messages_workroom_messages_sender_idTousersInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutWorkroom_messages_workroom_messages_sender_idTousersInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutWorkroom_messages_workroom_messages_sender_idTousersInput, usersUncheckedUpdateWithoutWorkroom_messages_workroom_messages_sender_idTousersInput>
  }

  export type usersUpdateWithoutWorkroom_messages_workroom_messages_sender_idTousersInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: notesUpdateManyWithoutUsersNestedInput
    notices?: noticesUpdateManyWithoutUsersNestedInput
    students?: studentsUpdateManyWithoutUsersNestedInput
    teacher_routine?: teacher_routineUpdateManyWithoutUsersNestedInput
    teachers?: teachersUpdateManyWithoutUsersNestedInput
    workroom_messages_workroom_messages_receiver_idTousers?: workroom_messagesUpdateManyWithoutUsers_workroom_messages_receiver_idTousersNestedInput
  }

  export type usersUncheckedUpdateWithoutWorkroom_messages_workroom_messages_sender_idTousersInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: notesUncheckedUpdateManyWithoutUsersNestedInput
    notices?: noticesUncheckedUpdateManyWithoutUsersNestedInput
    students?: studentsUncheckedUpdateManyWithoutUsersNestedInput
    teacher_routine?: teacher_routineUncheckedUpdateManyWithoutUsersNestedInput
    teachers?: teachersUncheckedUpdateManyWithoutUsersNestedInput
    workroom_messages_workroom_messages_receiver_idTousers?: workroom_messagesUncheckedUpdateManyWithoutUsers_workroom_messages_receiver_idTousersNestedInput
  }

  export type upcoming_eventsCreateManyCalendarInput = {
    id?: number
    event_date: Date | string
    event_name: string
    holiday: boolean
  }

  export type upcoming_eventsUpdateWithoutCalendarInput = {
    event_date?: DateTimeFieldUpdateOperationsInput | Date | string
    event_name?: StringFieldUpdateOperationsInput | string
    holiday?: BoolFieldUpdateOperationsInput | boolean
  }

  export type upcoming_eventsUncheckedUpdateWithoutCalendarInput = {
    id?: IntFieldUpdateOperationsInput | number
    event_date?: DateTimeFieldUpdateOperationsInput | Date | string
    event_name?: StringFieldUpdateOperationsInput | string
    holiday?: BoolFieldUpdateOperationsInput | boolean
  }

  export type upcoming_eventsUncheckedUpdateManyWithoutCalendarInput = {
    id?: IntFieldUpdateOperationsInput | number
    event_date?: DateTimeFieldUpdateOperationsInput | Date | string
    event_name?: StringFieldUpdateOperationsInput | string
    holiday?: BoolFieldUpdateOperationsInput | boolean
  }

  export type performanceCreateManyExamsInput = {
    id?: number
    class: string
    section: string
    class_teacher?: number | null
    class_performance?: number | null
  }

  export type student_performanceCreateManyExamsInput = {
    id?: number
    student_id?: number | null
    marks_obtained: Decimal | DecimalJsLike | number | string
    total_marks: Decimal | DecimalJsLike | number | string
  }

  export type performanceUpdateWithoutExamsInput = {
    class?: StringFieldUpdateOperationsInput | string
    section?: StringFieldUpdateOperationsInput | string
    student_performance?: student_performanceUpdateOneWithoutPerformanceNestedInput
    teachers?: teachersUpdateOneWithoutPerformanceNestedInput
  }

  export type performanceUncheckedUpdateWithoutExamsInput = {
    id?: IntFieldUpdateOperationsInput | number
    class?: StringFieldUpdateOperationsInput | string
    section?: StringFieldUpdateOperationsInput | string
    class_teacher?: NullableIntFieldUpdateOperationsInput | number | null
    class_performance?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type performanceUncheckedUpdateManyWithoutExamsInput = {
    id?: IntFieldUpdateOperationsInput | number
    class?: StringFieldUpdateOperationsInput | string
    section?: StringFieldUpdateOperationsInput | string
    class_teacher?: NullableIntFieldUpdateOperationsInput | number | null
    class_performance?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type student_performanceUpdateWithoutExamsInput = {
    marks_obtained?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total_marks?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    performance?: performanceUpdateManyWithoutStudent_performanceNestedInput
    students?: studentsUpdateOneWithoutStudent_performanceNestedInput
  }

  export type student_performanceUncheckedUpdateWithoutExamsInput = {
    id?: IntFieldUpdateOperationsInput | number
    student_id?: NullableIntFieldUpdateOperationsInput | number | null
    marks_obtained?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total_marks?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    performance?: performanceUncheckedUpdateManyWithoutStudent_performanceNestedInput
  }

  export type student_performanceUncheckedUpdateManyWithoutExamsInput = {
    id?: IntFieldUpdateOperationsInput | number
    student_id?: NullableIntFieldUpdateOperationsInput | number | null
    marks_obtained?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total_marks?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type performanceCreateManyStudent_performanceInput = {
    id?: number
    class: string
    section: string
    class_teacher?: number | null
    exam_id?: number | null
  }

  export type performanceUpdateWithoutStudent_performanceInput = {
    class?: StringFieldUpdateOperationsInput | string
    section?: StringFieldUpdateOperationsInput | string
    exams?: examsUpdateOneWithoutPerformanceNestedInput
    teachers?: teachersUpdateOneWithoutPerformanceNestedInput
  }

  export type performanceUncheckedUpdateWithoutStudent_performanceInput = {
    id?: IntFieldUpdateOperationsInput | number
    class?: StringFieldUpdateOperationsInput | string
    section?: StringFieldUpdateOperationsInput | string
    class_teacher?: NullableIntFieldUpdateOperationsInput | number | null
    exam_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type performanceUncheckedUpdateManyWithoutStudent_performanceInput = {
    id?: IntFieldUpdateOperationsInput | number
    class?: StringFieldUpdateOperationsInput | string
    section?: StringFieldUpdateOperationsInput | string
    class_teacher?: NullableIntFieldUpdateOperationsInput | number | null
    exam_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type attendanceCreateManyStudentsInput = {
    id?: number
    teacher_id: number
    class: number
    section: string
    date: Date | string
    status: string
    created_at?: Date | string | null
  }

  export type class_representativesCreateManyStudentsInput = {
    id?: number
    class: string
    section: string
  }

  export type class_teachersCreateManyStudentsInput = {
    id?: number
    class: string
    section: string
    teacher_id: number
    second_class_representative_student_id?: number | null
  }

  export type financesCreateManyStudentsInput = {
    id?: number
    total_fee: Decimal | DecimalJsLike | number | string
    paid_amount?: Decimal | DecimalJsLike | number | string | null
    due_amount?: Decimal | DecimalJsLike | number | string | null
    month: string
    payment_status?: string | null
    penalty?: Decimal | DecimalJsLike | number | string | null
    expenses?: Decimal | DecimalJsLike | number | string | null
  }

  export type student_performanceCreateManyStudentsInput = {
    id?: number
    exam_id?: number | null
    marks_obtained: Decimal | DecimalJsLike | number | string
    total_marks: Decimal | DecimalJsLike | number | string
  }

  export type attendanceUpdateWithoutStudentsInput = {
    class?: IntFieldUpdateOperationsInput | number
    section?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    teachers?: teachersUpdateOneRequiredWithoutAttendanceNestedInput
  }

  export type attendanceUncheckedUpdateWithoutStudentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    teacher_id?: IntFieldUpdateOperationsInput | number
    class?: IntFieldUpdateOperationsInput | number
    section?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type attendanceUncheckedUpdateManyWithoutStudentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    teacher_id?: IntFieldUpdateOperationsInput | number
    class?: IntFieldUpdateOperationsInput | number
    section?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type class_representativesUpdateWithoutStudentsInput = {
    class?: StringFieldUpdateOperationsInput | string
    section?: StringFieldUpdateOperationsInput | string
  }

  export type class_representativesUncheckedUpdateWithoutStudentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    class?: StringFieldUpdateOperationsInput | string
    section?: StringFieldUpdateOperationsInput | string
  }

  export type class_representativesUncheckedUpdateManyWithoutStudentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    class?: StringFieldUpdateOperationsInput | string
    section?: StringFieldUpdateOperationsInput | string
  }

  export type class_teachersUpdateWithoutStudentsInput = {
    class?: StringFieldUpdateOperationsInput | string
    section?: StringFieldUpdateOperationsInput | string
    second_class_representative_student_id?: NullableIntFieldUpdateOperationsInput | number | null
    teachers?: teachersUpdateOneRequiredWithoutClass_teachersNestedInput
  }

  export type class_teachersUncheckedUpdateWithoutStudentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    class?: StringFieldUpdateOperationsInput | string
    section?: StringFieldUpdateOperationsInput | string
    teacher_id?: IntFieldUpdateOperationsInput | number
    second_class_representative_student_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type class_teachersUncheckedUpdateManyWithoutStudentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    class?: StringFieldUpdateOperationsInput | string
    section?: StringFieldUpdateOperationsInput | string
    teacher_id?: IntFieldUpdateOperationsInput | number
    second_class_representative_student_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type financesUpdateWithoutStudentsInput = {
    total_fee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paid_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    due_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    month?: StringFieldUpdateOperationsInput | string
    payment_status?: NullableStringFieldUpdateOperationsInput | string | null
    penalty?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    expenses?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type financesUncheckedUpdateWithoutStudentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    total_fee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paid_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    due_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    month?: StringFieldUpdateOperationsInput | string
    payment_status?: NullableStringFieldUpdateOperationsInput | string | null
    penalty?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    expenses?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type financesUncheckedUpdateManyWithoutStudentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    total_fee?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    paid_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    due_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    month?: StringFieldUpdateOperationsInput | string
    payment_status?: NullableStringFieldUpdateOperationsInput | string | null
    penalty?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    expenses?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type student_performanceUpdateWithoutStudentsInput = {
    marks_obtained?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total_marks?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    performance?: performanceUpdateManyWithoutStudent_performanceNestedInput
    exams?: examsUpdateOneWithoutStudent_performanceNestedInput
  }

  export type student_performanceUncheckedUpdateWithoutStudentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    exam_id?: NullableIntFieldUpdateOperationsInput | number | null
    marks_obtained?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total_marks?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    performance?: performanceUncheckedUpdateManyWithoutStudent_performanceNestedInput
  }

  export type student_performanceUncheckedUpdateManyWithoutStudentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    exam_id?: NullableIntFieldUpdateOperationsInput | number | null
    marks_obtained?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total_marks?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type assignmentsCreateManyTeachersInput = {
    id?: number
    title: string
    description: string
    subject: string
    class: string
    section: string
    due_date: Date | string
    file?: string | null
  }

  export type attendanceCreateManyTeachersInput = {
    id?: number
    student_id: number
    class: number
    section: string
    date: Date | string
    status: string
    created_at?: Date | string | null
  }

  export type class_routineCreateManyTeachersInput = {
    id?: number
    class: string
    section: string
    day: string
    period: number
    subject: string
  }

  export type class_teachersCreateManyTeachersInput = {
    id?: number
    class: string
    section: string
    class_representative_student_id?: number | null
    second_class_representative_student_id?: number | null
  }

  export type examsCreateManyTeachersInput = {
    id?: number
    class: string
    section: string
    subject: string
    exam_date: Date | string
    exam_duration?: string | null
    exam_type?: string | null
  }

  export type performanceCreateManyTeachersInput = {
    id?: number
    class: string
    section: string
    class_performance?: number | null
    exam_id?: number | null
  }

  export type student_routineCreateManyTeachersInput = {
    id?: number
    class: string
    section: string
    day: string
    teacher_name: string
    teacher_subject?: string | null
    time_slot: string
  }

  export type assignmentsUpdateWithoutTeachersInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    class?: StringFieldUpdateOperationsInput | string
    section?: StringFieldUpdateOperationsInput | string
    due_date?: DateTimeFieldUpdateOperationsInput | Date | string
    file?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type assignmentsUncheckedUpdateWithoutTeachersInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    class?: StringFieldUpdateOperationsInput | string
    section?: StringFieldUpdateOperationsInput | string
    due_date?: DateTimeFieldUpdateOperationsInput | Date | string
    file?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type assignmentsUncheckedUpdateManyWithoutTeachersInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    class?: StringFieldUpdateOperationsInput | string
    section?: StringFieldUpdateOperationsInput | string
    due_date?: DateTimeFieldUpdateOperationsInput | Date | string
    file?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type attendanceUpdateWithoutTeachersInput = {
    class?: IntFieldUpdateOperationsInput | number
    section?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    students?: studentsUpdateOneRequiredWithoutAttendanceNestedInput
  }

  export type attendanceUncheckedUpdateWithoutTeachersInput = {
    id?: IntFieldUpdateOperationsInput | number
    student_id?: IntFieldUpdateOperationsInput | number
    class?: IntFieldUpdateOperationsInput | number
    section?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type attendanceUncheckedUpdateManyWithoutTeachersInput = {
    id?: IntFieldUpdateOperationsInput | number
    student_id?: IntFieldUpdateOperationsInput | number
    class?: IntFieldUpdateOperationsInput | number
    section?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type class_routineUpdateWithoutTeachersInput = {
    class?: StringFieldUpdateOperationsInput | string
    section?: StringFieldUpdateOperationsInput | string
    day?: StringFieldUpdateOperationsInput | string
    period?: IntFieldUpdateOperationsInput | number
    subject?: StringFieldUpdateOperationsInput | string
  }

  export type class_routineUncheckedUpdateWithoutTeachersInput = {
    id?: IntFieldUpdateOperationsInput | number
    class?: StringFieldUpdateOperationsInput | string
    section?: StringFieldUpdateOperationsInput | string
    day?: StringFieldUpdateOperationsInput | string
    period?: IntFieldUpdateOperationsInput | number
    subject?: StringFieldUpdateOperationsInput | string
  }

  export type class_routineUncheckedUpdateManyWithoutTeachersInput = {
    id?: IntFieldUpdateOperationsInput | number
    class?: StringFieldUpdateOperationsInput | string
    section?: StringFieldUpdateOperationsInput | string
    day?: StringFieldUpdateOperationsInput | string
    period?: IntFieldUpdateOperationsInput | number
    subject?: StringFieldUpdateOperationsInput | string
  }

  export type class_teachersUpdateWithoutTeachersInput = {
    class?: StringFieldUpdateOperationsInput | string
    section?: StringFieldUpdateOperationsInput | string
    second_class_representative_student_id?: NullableIntFieldUpdateOperationsInput | number | null
    students?: studentsUpdateOneWithoutClass_teachersNestedInput
  }

  export type class_teachersUncheckedUpdateWithoutTeachersInput = {
    id?: IntFieldUpdateOperationsInput | number
    class?: StringFieldUpdateOperationsInput | string
    section?: StringFieldUpdateOperationsInput | string
    class_representative_student_id?: NullableIntFieldUpdateOperationsInput | number | null
    second_class_representative_student_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type class_teachersUncheckedUpdateManyWithoutTeachersInput = {
    id?: IntFieldUpdateOperationsInput | number
    class?: StringFieldUpdateOperationsInput | string
    section?: StringFieldUpdateOperationsInput | string
    class_representative_student_id?: NullableIntFieldUpdateOperationsInput | number | null
    second_class_representative_student_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type examsUpdateWithoutTeachersInput = {
    class?: StringFieldUpdateOperationsInput | string
    section?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    exam_date?: DateTimeFieldUpdateOperationsInput | Date | string
    exam_duration?: NullableStringFieldUpdateOperationsInput | string | null
    exam_type?: NullableStringFieldUpdateOperationsInput | string | null
    performance?: performanceUpdateManyWithoutExamsNestedInput
    student_performance?: student_performanceUpdateManyWithoutExamsNestedInput
  }

  export type examsUncheckedUpdateWithoutTeachersInput = {
    id?: IntFieldUpdateOperationsInput | number
    class?: StringFieldUpdateOperationsInput | string
    section?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    exam_date?: DateTimeFieldUpdateOperationsInput | Date | string
    exam_duration?: NullableStringFieldUpdateOperationsInput | string | null
    exam_type?: NullableStringFieldUpdateOperationsInput | string | null
    performance?: performanceUncheckedUpdateManyWithoutExamsNestedInput
    student_performance?: student_performanceUncheckedUpdateManyWithoutExamsNestedInput
  }

  export type examsUncheckedUpdateManyWithoutTeachersInput = {
    id?: IntFieldUpdateOperationsInput | number
    class?: StringFieldUpdateOperationsInput | string
    section?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    exam_date?: DateTimeFieldUpdateOperationsInput | Date | string
    exam_duration?: NullableStringFieldUpdateOperationsInput | string | null
    exam_type?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type performanceUpdateWithoutTeachersInput = {
    class?: StringFieldUpdateOperationsInput | string
    section?: StringFieldUpdateOperationsInput | string
    exams?: examsUpdateOneWithoutPerformanceNestedInput
    student_performance?: student_performanceUpdateOneWithoutPerformanceNestedInput
  }

  export type performanceUncheckedUpdateWithoutTeachersInput = {
    id?: IntFieldUpdateOperationsInput | number
    class?: StringFieldUpdateOperationsInput | string
    section?: StringFieldUpdateOperationsInput | string
    class_performance?: NullableIntFieldUpdateOperationsInput | number | null
    exam_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type performanceUncheckedUpdateManyWithoutTeachersInput = {
    id?: IntFieldUpdateOperationsInput | number
    class?: StringFieldUpdateOperationsInput | string
    section?: StringFieldUpdateOperationsInput | string
    class_performance?: NullableIntFieldUpdateOperationsInput | number | null
    exam_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type student_routineUpdateWithoutTeachersInput = {
    class?: StringFieldUpdateOperationsInput | string
    section?: StringFieldUpdateOperationsInput | string
    day?: StringFieldUpdateOperationsInput | string
    teacher_name?: StringFieldUpdateOperationsInput | string
    teacher_subject?: NullableStringFieldUpdateOperationsInput | string | null
    time_slot?: StringFieldUpdateOperationsInput | string
  }

  export type student_routineUncheckedUpdateWithoutTeachersInput = {
    id?: IntFieldUpdateOperationsInput | number
    class?: StringFieldUpdateOperationsInput | string
    section?: StringFieldUpdateOperationsInput | string
    day?: StringFieldUpdateOperationsInput | string
    teacher_name?: StringFieldUpdateOperationsInput | string
    teacher_subject?: NullableStringFieldUpdateOperationsInput | string | null
    time_slot?: StringFieldUpdateOperationsInput | string
  }

  export type student_routineUncheckedUpdateManyWithoutTeachersInput = {
    id?: IntFieldUpdateOperationsInput | number
    class?: StringFieldUpdateOperationsInput | string
    section?: StringFieldUpdateOperationsInput | string
    day?: StringFieldUpdateOperationsInput | string
    teacher_name?: StringFieldUpdateOperationsInput | string
    teacher_subject?: NullableStringFieldUpdateOperationsInput | string | null
    time_slot?: StringFieldUpdateOperationsInput | string
  }

  export type notesCreateManyUsersInput = {
    id?: number
    title: string
    content: string
    subject: string
    class: string
    section: string
    files?: string | null
    created_at?: Date | string | null
  }

  export type noticesCreateManyUsersInput = {
    id?: number
    title: string
    content: string
    created_at?: Date | string | null
    target_role: string
  }

  export type studentsCreateManyUsersInput = {
    id?: number
    admission_number: string
    class: string
    section: string
    parent_name?: string | null
    parent_phone?: string | null
    parent_email?: string | null
    parent_work?: string | null
    parent_photo1?: string | null
    parent_photo2?: string | null
    guardian_photo?: string | null
    guardian_phone?: string | null
    roll_number?: number | null
  }

  export type teacher_routineCreateManyUsersInput = {
    id?: number
    day: string
    time_slot: string
    class: string
    section: string
  }

  export type teachersCreateManyUsersInput = {
    id?: number
    specialised_subject: string
    assigned_class?: string | null
    assigned_section?: string | null
  }

  export type workroom_messagesCreateManyUsers_workroom_messages_receiver_idTousersInput = {
    id?: number
    sender_id?: number | null
    message: string
    sent_at?: Date | string | null
  }

  export type workroom_messagesCreateManyUsers_workroom_messages_sender_idTousersInput = {
    id?: number
    receiver_id?: number | null
    message: string
    sent_at?: Date | string | null
  }

  export type notesUpdateWithoutUsersInput = {
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    class?: StringFieldUpdateOperationsInput | string
    section?: StringFieldUpdateOperationsInput | string
    files?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type notesUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    class?: StringFieldUpdateOperationsInput | string
    section?: StringFieldUpdateOperationsInput | string
    files?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type notesUncheckedUpdateManyWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    class?: StringFieldUpdateOperationsInput | string
    section?: StringFieldUpdateOperationsInput | string
    files?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type noticesUpdateWithoutUsersInput = {
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    target_role?: StringFieldUpdateOperationsInput | string
  }

  export type noticesUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    target_role?: StringFieldUpdateOperationsInput | string
  }

  export type noticesUncheckedUpdateManyWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    target_role?: StringFieldUpdateOperationsInput | string
  }

  export type studentsUpdateWithoutUsersInput = {
    admission_number?: StringFieldUpdateOperationsInput | string
    class?: StringFieldUpdateOperationsInput | string
    section?: StringFieldUpdateOperationsInput | string
    parent_name?: NullableStringFieldUpdateOperationsInput | string | null
    parent_phone?: NullableStringFieldUpdateOperationsInput | string | null
    parent_email?: NullableStringFieldUpdateOperationsInput | string | null
    parent_work?: NullableStringFieldUpdateOperationsInput | string | null
    parent_photo1?: NullableStringFieldUpdateOperationsInput | string | null
    parent_photo2?: NullableStringFieldUpdateOperationsInput | string | null
    guardian_photo?: NullableStringFieldUpdateOperationsInput | string | null
    guardian_phone?: NullableStringFieldUpdateOperationsInput | string | null
    roll_number?: NullableIntFieldUpdateOperationsInput | number | null
    attendance?: attendanceUpdateManyWithoutStudentsNestedInput
    class_representatives?: class_representativesUpdateManyWithoutStudentsNestedInput
    class_teachers?: class_teachersUpdateManyWithoutStudentsNestedInput
    finances?: financesUpdateManyWithoutStudentsNestedInput
    student_performance?: student_performanceUpdateManyWithoutStudentsNestedInput
  }

  export type studentsUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    admission_number?: StringFieldUpdateOperationsInput | string
    class?: StringFieldUpdateOperationsInput | string
    section?: StringFieldUpdateOperationsInput | string
    parent_name?: NullableStringFieldUpdateOperationsInput | string | null
    parent_phone?: NullableStringFieldUpdateOperationsInput | string | null
    parent_email?: NullableStringFieldUpdateOperationsInput | string | null
    parent_work?: NullableStringFieldUpdateOperationsInput | string | null
    parent_photo1?: NullableStringFieldUpdateOperationsInput | string | null
    parent_photo2?: NullableStringFieldUpdateOperationsInput | string | null
    guardian_photo?: NullableStringFieldUpdateOperationsInput | string | null
    guardian_phone?: NullableStringFieldUpdateOperationsInput | string | null
    roll_number?: NullableIntFieldUpdateOperationsInput | number | null
    attendance?: attendanceUncheckedUpdateManyWithoutStudentsNestedInput
    class_representatives?: class_representativesUncheckedUpdateManyWithoutStudentsNestedInput
    class_teachers?: class_teachersUncheckedUpdateManyWithoutStudentsNestedInput
    finances?: financesUncheckedUpdateManyWithoutStudentsNestedInput
    student_performance?: student_performanceUncheckedUpdateManyWithoutStudentsNestedInput
  }

  export type studentsUncheckedUpdateManyWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    admission_number?: StringFieldUpdateOperationsInput | string
    class?: StringFieldUpdateOperationsInput | string
    section?: StringFieldUpdateOperationsInput | string
    parent_name?: NullableStringFieldUpdateOperationsInput | string | null
    parent_phone?: NullableStringFieldUpdateOperationsInput | string | null
    parent_email?: NullableStringFieldUpdateOperationsInput | string | null
    parent_work?: NullableStringFieldUpdateOperationsInput | string | null
    parent_photo1?: NullableStringFieldUpdateOperationsInput | string | null
    parent_photo2?: NullableStringFieldUpdateOperationsInput | string | null
    guardian_photo?: NullableStringFieldUpdateOperationsInput | string | null
    guardian_phone?: NullableStringFieldUpdateOperationsInput | string | null
    roll_number?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type teacher_routineUpdateWithoutUsersInput = {
    day?: StringFieldUpdateOperationsInput | string
    time_slot?: StringFieldUpdateOperationsInput | string
    class?: StringFieldUpdateOperationsInput | string
    section?: StringFieldUpdateOperationsInput | string
  }

  export type teacher_routineUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    day?: StringFieldUpdateOperationsInput | string
    time_slot?: StringFieldUpdateOperationsInput | string
    class?: StringFieldUpdateOperationsInput | string
    section?: StringFieldUpdateOperationsInput | string
  }

  export type teacher_routineUncheckedUpdateManyWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    day?: StringFieldUpdateOperationsInput | string
    time_slot?: StringFieldUpdateOperationsInput | string
    class?: StringFieldUpdateOperationsInput | string
    section?: StringFieldUpdateOperationsInput | string
  }

  export type teachersUpdateWithoutUsersInput = {
    specialised_subject?: StringFieldUpdateOperationsInput | string
    assigned_class?: NullableStringFieldUpdateOperationsInput | string | null
    assigned_section?: NullableStringFieldUpdateOperationsInput | string | null
    assignments?: assignmentsUpdateManyWithoutTeachersNestedInput
    attendance?: attendanceUpdateManyWithoutTeachersNestedInput
    class_routine?: class_routineUpdateManyWithoutTeachersNestedInput
    class_teachers?: class_teachersUpdateManyWithoutTeachersNestedInput
    exams?: examsUpdateManyWithoutTeachersNestedInput
    performance?: performanceUpdateManyWithoutTeachersNestedInput
    student_routine?: student_routineUpdateManyWithoutTeachersNestedInput
  }

  export type teachersUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    specialised_subject?: StringFieldUpdateOperationsInput | string
    assigned_class?: NullableStringFieldUpdateOperationsInput | string | null
    assigned_section?: NullableStringFieldUpdateOperationsInput | string | null
    assignments?: assignmentsUncheckedUpdateManyWithoutTeachersNestedInput
    attendance?: attendanceUncheckedUpdateManyWithoutTeachersNestedInput
    class_routine?: class_routineUncheckedUpdateManyWithoutTeachersNestedInput
    class_teachers?: class_teachersUncheckedUpdateManyWithoutTeachersNestedInput
    exams?: examsUncheckedUpdateManyWithoutTeachersNestedInput
    performance?: performanceUncheckedUpdateManyWithoutTeachersNestedInput
    student_routine?: student_routineUncheckedUpdateManyWithoutTeachersNestedInput
  }

  export type teachersUncheckedUpdateManyWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    specialised_subject?: StringFieldUpdateOperationsInput | string
    assigned_class?: NullableStringFieldUpdateOperationsInput | string | null
    assigned_section?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type workroom_messagesUpdateWithoutUsers_workroom_messages_receiver_idTousersInput = {
    message?: StringFieldUpdateOperationsInput | string
    sent_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    users_workroom_messages_sender_idTousers?: usersUpdateOneWithoutWorkroom_messages_workroom_messages_sender_idTousersNestedInput
  }

  export type workroom_messagesUncheckedUpdateWithoutUsers_workroom_messages_receiver_idTousersInput = {
    id?: IntFieldUpdateOperationsInput | number
    sender_id?: NullableIntFieldUpdateOperationsInput | number | null
    message?: StringFieldUpdateOperationsInput | string
    sent_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type workroom_messagesUncheckedUpdateManyWithoutUsers_workroom_messages_receiver_idTousersInput = {
    id?: IntFieldUpdateOperationsInput | number
    sender_id?: NullableIntFieldUpdateOperationsInput | number | null
    message?: StringFieldUpdateOperationsInput | string
    sent_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type workroom_messagesUpdateWithoutUsers_workroom_messages_sender_idTousersInput = {
    message?: StringFieldUpdateOperationsInput | string
    sent_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    users_workroom_messages_receiver_idTousers?: usersUpdateOneWithoutWorkroom_messages_workroom_messages_receiver_idTousersNestedInput
  }

  export type workroom_messagesUncheckedUpdateWithoutUsers_workroom_messages_sender_idTousersInput = {
    id?: IntFieldUpdateOperationsInput | number
    receiver_id?: NullableIntFieldUpdateOperationsInput | number | null
    message?: StringFieldUpdateOperationsInput | string
    sent_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type workroom_messagesUncheckedUpdateManyWithoutUsers_workroom_messages_sender_idTousersInput = {
    id?: IntFieldUpdateOperationsInput | number
    receiver_id?: NullableIntFieldUpdateOperationsInput | number | null
    message?: StringFieldUpdateOperationsInput | string
    sent_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}